<!DOCTYPE html>
<html>

<head>
  
  <!-- Begin Jekyll SEO tag v2.6.1 -->
<title>设计模式 | Acemyzoe</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="设计模式" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="奥卡姆剃刀 ： 如无必要，勿增实体" />
<meta property="og:description" content="奥卡姆剃刀 ： 如无必要，勿增实体" />
<link rel="canonical" href="https://acemyzoe.github.io/_posts/2020-08-01-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" />
<meta property="og:url" content="https://acemyzoe.github.io/_posts/2020-08-01-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" />
<meta property="og:site_name" content="Acemyzoe" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-08-01T00:00:00+08:00" />
<script type="application/ld+json">
{"@type":"BlogPosting","url":"https://acemyzoe.github.io/_posts/2020-08-01-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","headline":"设计模式","dateModified":"2020-08-01T00:00:00+08:00","datePublished":"2020-08-01T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://acemyzoe.github.io/_posts/2020-08-01-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},"description":"奥卡姆剃刀 ： 如无必要，勿增实体","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  
  
  <meta
  name="viewport"
  content="width=device-width, initial-scale=1.0, maximum-scale=1"
/>
<meta
  http-equiv="content-type"
  content="text/html; charset=utf-8"
/>
<link
  rel="alternate"
  href="/feed.xml"
  title="RSS"
  type="application/rss+xml"
/>

  
  <link
  rel="apple-touch-icon-precomposed"
  href="/assets/image/Avatar.jpg"
/>
<link
  rel="shortcut
  icon"
  href="/assets/image/Avatar.jpg"
/>

  
  <link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/combine/gh/poole/lanyon@v1.1.0/public/css/poole.min.css,gh/poole/lanyon@v1.1.0/public/css/lanyon.min.css"
/>

  
  <link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13.0/css/all.min.css"
/>

  
  <script
  src='https://zz.bdstatic.com/linksubmit/push.js'
  async="async"
></script>

  
  <style>
  .wrap {
    transition-property: width,background-size,transform;
    transition-duration: .3s;
    transition-timing-function: ease-in-out;
    min-height: 100%;
    display: inline-block;
    background-size: 100% auto;
    background-position: 0% 0%;
    background-repeat: no-repeat;
    background-attachment: fixed;
    background-image: url(/assets/image/background-wap.jpg);
  }
  @media (min-aspect-ratio: 2400/1850) {
    .wrap {
      background-image: url(/assets/image/background.jpg);
    }
  }
  .sidebar-overlay #sidebar-checkbox:checked ~ .wrap {
    width: calc(100% - 14rem);
    background-size: calc(100% - 14rem) auto;
    transform: translateX(14rem);
  }
  .layout-reverse.sidebar-overlay #sidebar-checkbox:checked ~ .wrap {
    transform: translateX(0);
  }
</style>

  
  <style>
  .sidebar,
  html,
  h1,
  h2,
  h3,
  h4,
  h5,
  h6 {
    font-family: PingFang SC, Menlo, Monaco, "Courier New", Microsoft JhengHei, monospace;
  }
</style>

  
  <style>
  h1,
  h2,
  h3,
  h4,
  h5,
  h6 {
    font-weight: bold;
  }
</style>

  
  <style>
  img {
    display: inline-block;
    margin: 0;
  }
</style>

  
  <style>
  ::-webkit-scrollbar {
    width: 4px;
    height: 4px;
  }
  ::-webkit-scrollbar-thumb {
    background-image: linear-gradient(45deg, Cyan 0%, Magenta 50%, Yellow 100%);
  }
</style>

  
  <style>
  ::selection {
    color: White;
    background: Black;
  }
</style>

  
</head>

<body
  class="theme-base-07 layout-reverse sidebar-overlay">
  
  
  
  <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
  <input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox"
     />
  <!-- Toggleable sidebar -->
  <div class="sidebar" id="sidebar">
    
    <div class="sidebar-item">
      <div class="effect effect-right_to_left">
        <img class="effect-img" src="/assets/image/Avatar.jpg" alt="img" />
        <div class="effect-info">
          人类世界<br/>
真是<br/>
太有趣了<br/>
QAQ<br/>
<a href="mailto:acemyzoe@outlook.com">
  <i class="fas fa-envelope"></i>
</a>
<a href="https://github.com/acemyzoe">
  <i class="fab fa-github"></i>
</a>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=52 src="//music.163.com/outchain/player?type=2&id=486806&auto=1&height=32"></iframe>

        </div>
      </div>
    </div>
    
    <nav class="sidebar-nav">
      
      <a class="sidebar-nav-item" href="/">
        <i class="fas fa-home fa-fw"></i> 首页
      </a>
      
      <a class="sidebar-nav-item" href="/comments/">
        <i class="fas fa-comments fa-fw"></i> 留言
      </a>
      
      <a class="sidebar-nav-item" href="/tags/">
        <i class="fas fa-tags fa-fw"></i> 标签
      </a>
      
      <a class="sidebar-nav-item" href="/archive/">
        <i class="fas fa-archive fa-fw"></i> 归档
      </a>
      
      <a class="sidebar-nav-item" href="/merger/">
        <i class="fas fa-coffee fa-fw"></i> 打赏
      </a>
      
    </nav>
    <div class="sidebar-item">
      
      <style>
  #sidebar-search-input {
    background: none;
    border: none;
    color: White;
    width: 100%;
  }
  #sidebar-search-results-container {
    overflow: auto auto;
    max-height: 60vh;
  }
</style>
<input
  id="sidebar-search-input"
  placeholder="搜索博文"
/>
<ol
  id="sidebar-search-results-container"
></ol>
<script
  src='https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.7/dest/simple-jekyll-search.min.js'
  async='async'
  onload='
    SimpleJekyllSearch({
      json: "/assets/simple-jekyll-search/search.json",
      searchInput: document.getElementById("sidebar-search-input"),
      resultsContainer: document.getElementById("sidebar-search-results-container"),
      searchResultTemplate: `<li><a href="{url}">{title}</a></li>`,
      limit: 999,
      fuzzy: true
    })'
></script>

      
      
      <style>
  #toc {
    overflow: auto auto;
    max-height: 50vh;
  }
</style>

      <ol id="toc">
  <li><a href="#%E5%A6%82%E4%BD%95%E8%AF%84%E4%BB%B7%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E9%AB%98%E4%BD%8E">如何评价代码质量高低？</a></li>
  <li><a href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1">面向对象</a>
    <ol>
      <li><a href="#%E5%B0%81%E8%A3%85%E6%8A%BD%E8%B1%A1%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81">封装、抽象、继承、多态</a></li>
      <li><a href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B-vs-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%BC%96%E7%A8%8B">面向对象编程 VS 面向过程编程</a></li>
      <li><a href="#%E6%8E%A5%E5%8F%A3-vs-%E6%8A%BD%E8%B1%A1%E7%B1%BB">接口 VS 抽象类</a></li>
      <li><a href="#%E5%9F%BA%E4%BA%8E%E6%8E%A5%E5%8F%A3%E8%80%8C%E9%9D%9E%E5%AE%9E%E7%8E%B0%E7%BC%96%E7%A8%8B--%E5%9F%BA%E4%BA%8E%E6%8A%BD%E8%B1%A1%E8%80%8C%E9%9D%9E%E5%AE%9E%E7%8E%B0%E7%BC%96%E7%A8%8B">基于接口而非实现编程 / 基于抽象而非实现编程</a></li>
      <li><a href="#%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E8%B4%AB%E8%A1%80%E6%A8%A1%E5%9E%8B%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%85%E8%A1%80%E6%A8%A1%E5%9E%8B">面向过程的贫血模型和面向对象的充血模型</a></li>
    </ol>
  </li>
  <li><a href="#%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99">设计原则</a>
    <ol>
      <li><a href="#solid-%E5%8E%9F%E5%88%99--srp">SOLID 原则 -SRP</a></li>
      <li><a href="#solid-%E5%8E%9F%E5%88%99--ocp">SOLID 原则 -OCP</a></li>
      <li><a href="#solid-%E5%8E%9F%E5%88%99--lsp">SOLID 原则 -LSP</a></li>
      <li><a href="#solid-%E5%8E%9F%E5%88%99--isp">SOLID 原则 -ISP</a></li>
      <li><a href="#solid-%E5%8E%9F%E5%88%99--dip">SOLID 原则 -DIP</a></li>
      <li><a href="#more">More</a></li>
    </ol>
  </li>
  <li><a href="#%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91">业务系统开发</a></li>
  <li><a href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">设计模式</a>
    <ol>
      <li><a href="#%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F">创建型模式</a>
        <ol>
          <li><a href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F">单例模式</a></li>
          <li><a href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F">工厂模式</a></li>
          <li><a href="#%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F">建造者模式</a></li>
          <li><a href="#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F">原型模式</a></li>
        </ol>
      </li>
      <li><a href="#%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F">结构型模式</a>
        <ol>
          <li><a href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F">代理模式</a></li>
          <li><a href="#%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F">桥接模式</a></li>
          <li><a href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F">装饰器模式</a></li>
          <li><a href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F">适配器模式</a></li>
        </ol>
      </li>
      <li><a href="#%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F">行为型模式</a>
        <ol>
          <li><a href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F">观察者模式</a></li>
          <li><a href="#%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F">模板模式</a></li>
          <li><a href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F">策略模式</a></li>
          <li><a href="#%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F">职责链模式</a></li>
          <li><a href="#%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F">状态模式</a></li>
          <li><a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F">迭代器模式</a></li>
        </ol>
      </li>
    </ol>
  </li>
  <li><a href="#%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83">编程规范</a></li>
  <li><a href="#%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84">代码重构</a></li>
</ol>
      
      
      <script defer="defer" src="https://cdn.jsdelivr.net/gh/poole/lanyon@v1.1.0/public/js/script.min.js"></script>
      
      <style>
  .sidebar-checkbox {
    display: none;
  }
  .sidebar-toggle {
    position: fixed;
  }
</style>

      
      <style>
  .effect {
    margin: 1rem;
    perspective: 900px;
  }
  .effect-info {
    text-align: center;
    backface-visibility: hidden;
    position: absolute;
    top: 0;
    transform-style: preserve-3d;
  }
  .effect-img {
    z-index: 11;
    width: 100%;
    height: 100%;
    position: relative;
    transition: all 0.5s ease-in-out;
  }
  .effect-img:before {
    position: absolute;
    display: block;
  }
  .effect-right_to_left .effect-img {
    transform-origin: 0% 50%;
  }
  .effect-right_to_left:hover .effect-img {
    transform: rotate3d(0, 1, 0, -180deg);
  }
</style>

      
      <div>
  <i class="fas fa-cog fa-spin fa-fw"></i>
  <span id="run_time_day">
    <i class="fas fa-spinner fa-pulse"></i>
  </span>天
  <span id="run_time_hour">
    <i class="fas fa-spinner fa-pulse"></i>
  </span>时
  <span id="run_time_minute">
    <i class="fas fa-spinner fa-pulse"></i>
  </span>分
  <span id="run_time_second">
    <i class="fas fa-spinner fa-pulse"></i>
  </span>秒
  <script>
    setInterval(function (d,h,m,s,b) {
      function setzero(i) {
        return i < 10 ? "0" + i : i;
      }
      let BirthDay = new Date(b);
      let today = new Date();
      let timeold = (today.getTime() - BirthDay.getTime());
      let sectimeold = timeold / 1000;
      let secondsold = Math.floor(sectimeold);
      let msPerDay = 24 * 60 * 60 * 1000;
      let e_daysold = timeold / msPerDay;
      let daysold = Math.floor(e_daysold);
      let e_hrsold = (e_daysold - daysold) * 24;
      let hrsold = Math.floor(e_hrsold);
      let e_minsold = (e_hrsold - hrsold) * 60;
      let minsold = Math.floor((e_hrsold - hrsold) * 60);
      let seconds = Math.floor((e_minsold - minsold) * 60);
      d.textContent = daysold;
      h.textContent = setzero(hrsold);
      m.textContent = setzero(minsold);
      s.textContent = setzero(seconds);
    },
    1000,
    document.getElementById("run_time_day"),
    document.getElementById("run_time_hour"),
    document.getElementById("run_time_minute"),
    document.getElementById("run_time_second"),
    "04/01/2020 12:00:00")// 这是我第一篇博客的时间
  </script>
</div>

      
      <div>
  <div>
    <i class="fas fa-eye fa-fw"></i>
    <span id="busuanzi_value_page_pv">
      <i class="fas fa-spinner fa-pulse"></i>
    </span>次
  </div>
  <div>
    <i class="fas fa-paw fa-fw"></i>
    <span id="busuanzi_value_site_pv">
      <i class="fas fa-spinner fa-pulse"></i>
    </span>枚
  </div>
  <div>
    <i class="fas fa-user-friends fa-fw"></i>
    <span id="busuanzi_value_site_uv">
      <i class="fas fa-spinner fa-pulse"></i>
    </span>人
  </div>
  <script
    src='https://cdn.jsdelivr.net/npm/busuanzi@2.3.0'
    async='async'
  ></script>
</div>

      
      <div>
  <i class="fas fa-thumbs-up fa-fw"></i>
  <a href="https://github.com/acemyzoe">
    Github
  </a>
</div>

      
      <div>
  <i class="fas fa-copyright fa-fw"></i>
  acemyzoe
</div>

      
      
    </div>
  </div>
  <!-- Wrap is the content to shift when toggling the sidebar. We wrap the content to avoid any CSS collisions with our real content. -->
  
  <div class="wrap">
    
<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
/>
<script
  src="https://cdn.jsdelivr.net/combine/npm/katex@0.11.1/dist/katex.min.js,npm/katex@0.11.1/dist/contrib/mathtex-script-type.min.js,npm/katex@0.11.1/dist/contrib/auto-render.min.js"
  defer="defer"
  onload='renderMathInElement(document.body, { delimiters: [{ left: "$", right: "$", display: false }] })'
></script>



<style>
  pre.language-mermaid,
  code.language-mermaid {
    display: none;
  }
</style>
<script
  src="https://cdn.jsdelivr.net/npm/mermaid@8.5.1/dist/mermaid.min.js"
  defer="defer"
  onload='
    for(let x of document.getElementsByClassName("language-mermaid"))
      if(x.nodeName=="CODE")
      {
        let m = document.createElement("div");
        m.classList.add("mermaid");
        m.textContent = x.textContent;
        x.parentNode.insertAdjacentElement("beforebegin", m);
      }'
></script>



<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/combine/npm/prismjs@1.20.0/plugins/line-numbers/prism-line-numbers.min.css,npm/prismjs@1.20.0/plugins/toolbar/prism-toolbar.min.css,gh/PrismJS/prism-themes@1955cfef6953b3a59e66016e8a1e016b45d6cc79/themes/prism-nord.min.css"
/>
<script
  src="https://cdn.jsdelivr.net/combine/npm/prismjs@1.20.0/components/prism-core.min.js,npm/prismjs@1.20.0/plugins/autoloader/prism-autoloader.min.js,npm/prismjs@1.20.0/plugins/line-numbers/prism-line-numbers.min.js,npm/prismjs@1.20.0/plugins/toolbar/prism-toolbar.min.js"
  defer="defer"
  onload='
    Prism.plugins.autoloader.languages_path = "https:\/\/cdn.jsdelivr.net/npm/prismjs/components/";
    for(let x of document.getElementsByTagName("pre"))
      x.classList.add("line-numbers");
    Prism.plugins.toolbar.registerButton("select-code", function (env) {
      let button = document.createElement("button");
      button.textContent = "select this " + env.language;
      button.addEventListener("click", function () {
        if (document.body.createTextRange) {
          let range = document.body.createTextRange();
          range.moveToElementText(env.element);
          range.select();
        } else if (window.getSelection) {
          let selection = window.getSelection();
          let range = document.createRange();
          range.selectNodeContents(env.element);
          selection.removeAllRanges();
            selection.addRange(range);
        }
      });
      return button;
    })'
></script>



<style>
  pre {
    max-height: 50vh;
    overflow: auto;
  }
</style>


<style>
  @media (min-width: 56em) {
    .container {
      max-width: 66.6%;
    }
  }
</style>


<style>
  .masthead,
  .container.content {
    padding-top: 1rem;
    padding-bottom: 1rem;
    box-shadow: 0 0 .75rem rgba(0, 0, 0, 0.1);
    background-color: rgba(255, 255, 255, 0.95);
    animation-duration: 2s;
    animation-name: fadeIn;
  }
  @keyframes fadeIn {
    from {
      opacity: 0;
    }
    to {
      opacity: 1;
    }
  }
</style>



<div class="masthead">
  <h3 class="container masthead-title">
    
    设计模式
    <a href="/" title="Home">
      <small>
        Acemyzoe
      </small>
    </a>
    
  </h3>
</div>

<div class="container content">
  <div class="post">
  <span class="post-date">
    
    <i class="fas fa-calendar-day fa-fw"></i>
    01 Aug 2020
    
    
    <i class="fas fa-file-word fa-fw"></i>
    8338字
    
    
    <i class="fas fa-clock fa-fw"></i>
    28分
    
    
    <span class="leancloud-visitors" id="/_posts/2020-08-01-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" data-xid="/_posts/2020-08-01-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" data-flag-title="设计模式">
      <i class="fas fa-book-reader fa-fw"></i>
      <span class="leancloud-visitors-count">
        <i class="fas fa-spinner fa-pulse"></i>
      </span>次
    </span>
    
    
    
    <i class="fas fa-tag fa-fw"></i>
    Software
    
    
    <i class="fab fa-creative-commons-by fa-fw"></i>
<a
  href="https://creativecommons.org/licenses/by/4.0/deed.zh"
  rel="license">
  CC BY 4.0
</a>
（除特别声明或转载文章外）

    
  </span>
  <blockquote>
  <p>奥卡姆剃刀 ： 如无必要，勿增实体</p>
</blockquote>

<p>目的：告别写被人吐槽的烂代码，提高复杂代码的设计开发能力，让读源码学框架事半功倍。</p>

<h1 id="如何评价代码质量高低">如何评价代码质量高低？</h1>

<ul>
  <li>可维护性 maintainability</li>
</ul>

<blockquote>
  <p>主观、侧面： bug是否容易修复，修改、添加功能是否能够轻松完成。</p>
</blockquote>

<ul>
  <li>可读性 readability</li>
</ul>

<blockquote>
  <p>代码是否符合编码规范、命名是否达意、注释是否详尽、函数是否长短合适、模块划分是否清晰、是否符合高内聚低耦合等等。</p>

  <p>code review 测验代码可读性</p>
</blockquote>

<ul>
  <li>可拓展性 extensibility</li>
</ul>

<blockquote>
  <p>代码预留了一些功能扩展点，可以把新功能代码直接插到扩展点上。</p>

  <p>“对修改关闭，对扩展开放”</p>
</blockquote>

<ul>
  <li>灵活性 flexibility</li>
</ul>

<blockquote>
  <p>代码易扩展、易复用或者易用</p>
</blockquote>

<ul>
  <li>简洁性 simplicity</li>
</ul>

<blockquote>
  <p>KISS</p>
</blockquote>

<ul>
  <li>可复用性 reusability</li>
</ul>

<blockquote>
  <p>DRY (Don’t Repeat Yourself)</p>
</blockquote>

<ul>
  <li>可测试性 testability</li>
</ul>

<p>思考：函数是较小的可复用单位，面向对象把可复用单位提升到类层次，设计模式把可复用对提升到框架层次。</p>

<h1 id="面向对象">面向对象</h1>

<blockquote>
  <p>面向对象中的继承、多态能让我们写出可复用的代码</p>

  <p>面向对象编程是一种编程范式或编程风格。它以<strong>类或对象</strong>作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石 。</p>

  <p>面向对象软件开发：OOA&gt;OOD&gt;OOP (分析&gt;设计&gt;编程)</p>

  <p>UML(Unified Model Language) 统一建模语言</p>
</blockquote>

<h2 id="封装抽象继承多态">封装、抽象、继承、多态</h2>

<ul>
  <li>封装：隐藏信息、保护数据</li>
  <li>抽象 : 隐藏方法的具体实现</li>
  <li>继承：Java 使用extends 关键字，C++ 使用冒号（class B : public A），Python 使用()，Ruby 使用 &lt;。</li>
  <li>多态：子类可以替换父类。用接口类来实现多态特性；duck-typing(只要两个类具有相同的方法，就可以实现多态)</li>
</ul>

<h2 id="面向对象编程-vs-面向过程编程">面向对象编程 VS 面向过程编程</h2>

<ul>
  <li>面向过程风格的代码被组织成了一组方法集合及其数据结构，方法和数据结构的定义是分开的。</li>
  <li>面向对象风格的代码被组织成一组类，方法和数据结构被绑定一起，定义在类中。</li>
</ul>

<h2 id="接口-vs-抽象类">接口 VS 抽象类</h2>

<ul>
  <li>接口：协议/约定，实现面向对象的抽象多态和基于接口而非实现的设计原则，为了代码复用。
    <ul>
      <li>接口不能包含属性（也就是成员变量）</li>
      <li>接口只能声明方法，方法不能包含代码实现。</li>
      <li>类实现接口的时候，必须实现接口中声明的所有方法。</li>
    </ul>
  </li>
  <li>抽象类：实现面向对象的继承和模板设计模式,侧重于解耦。
    <ul>
      <li>抽象类不允许实例化，只能被继承</li>
      <li>抽象类可以包含属性和方法</li>
      <li>子类继承抽象类，必须实现抽象类中的所有抽象方法</li>
    </ul>
  </li>
  <li>C++ 只支持抽象类，不支持接口；Python <a href="https://docs.python.org/zh-cn/3/library/abc.html#module-abc"><code>abc</code></a> 抽象基类<a href="https://docs.python.org/zh-cn/3/library/abc.html#module-abc">¶</a>(可用普通类/duck-typing来模拟)。</li>
  <li>表示is-a的关系，为解决代码复用的问题，用抽象类。(先有子类的代码重复，然后再抽象成上层的父类。)</li>
  <li>表示has-a / behaves like的关系，为解决抽象的问题，用接口。(先设计接口，再去考虑具体的实现。)</li>
</ul>

<h2 id="基于接口而非实现编程--基于抽象而非实现编程">基于接口而非实现编程 / 基于抽象而非实现编程</h2>

<ul>
  <li>函数的命名不能暴露任何实现细节</li>
  <li>封装具体的实现细节</li>
  <li>
    <p>为实现类定义抽象的接口</p>
  </li>
  <li>多用组合少用继承
    <ul>
      <li>继承主要有三个作用：表示 is-a 关系，支持多态特性，代码复用。</li>
      <li>这三个作用可以通过组合、接口、委托三个技术手段来达成。</li>
    </ul>
  </li>
</ul>

<h2 id="面向过程的贫血模型和面向对象的充血模型">面向过程的贫血模型和面向对象的充血模型</h2>

<ul>
  <li>
    <p>基于贫血模型的 MVC 三层架构开发模式</p>

    <ul>
      <li>Model/View/Controller 展示层、逻辑层、数据层
        <ul>
          <li>后端项目分为 Repository 数据访问、Service业务逻辑 、Controller暴露接口</li>
          <li>贫血模型的Service层将数据与操作分离</li>
        </ul>
      </li>
    </ul>

    <blockquote>
      <p>大部分都是SQL 驱动（SQL-Driven）的开发模式。一个后端接口的开发，看接口需要的数据对应到数据库中，需要哪张表或者哪几张表，然后编写 SQL 语句来获取数据。之后就是定义类，然后模板式地往对应的 Repository、Service、Controller 类中添加代码。</p>
    </blockquote>
  </li>
  <li>
    <p>基于充血模型的 DDD (领域驱动设计)开发模式</p>

    <ul>
      <li>更适合业务复杂的系统开发，比如金融系统</li>
      <li>DDD ：用来指导如何解耦业务系统，划分业务模块，定义业务领域模型及其交互</li>
      <li>微服务加速了领域驱动设计的盛行。关键在于对业务的熟悉程度。</li>
      <li>充血模型的Service层分service和domain，包含数据和业务逻辑</li>
    </ul>

    <blockquote>
      <p>应用基于充血模型的 DDD 的开发模式，需要事先理清楚所有的业务，定义领域模型所包含的属性和
方法。领域模型相当于可复用的业务中间层。新功能需求的开发，都基于之前定义好的这些领域模型来完成。</p>
    </blockquote>
  </li>
</ul>

<h1 id="设计原则">设计原则</h1>

<blockquote>
  <p>设计原则中的单一职责、DRY、基于接口而非实现、里式替换原则等，可以让我们写出可复用、灵活、可性好、易扩展、易维护的代码；</p>
</blockquote>

<h2 id="solid-原则--srp">SOLID 原则 -SRP</h2>

<p>单一职责原则 Single Responsibility Principle</p>

<ul>
  <li>A class or module should have a single responsibility.</li>
  <li>持续重构：粗粒度的类 &gt; 细粒度的类
    <ul>
      <li>类中的代码行数、函数或属性过多，会影响代码的可读性和可维护性，考虑对类拆分。</li>
      <li>类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想，考虑拆分。</li>
      <li>私有方法过多，能否将私有方法独立到新的类中，设置为 public 方法，供更多的类使用。</li>
      <li>比较难给类起一个合适名字或用业务名词概括，说明类的职责定义不够清晰。</li>
      <li>类中大量的方法都是集中操作类中的某几个属性，将这几个属性和对应的方法拆分出来。</li>
    </ul>
  </li>
</ul>

<h2 id="solid-原则--ocp">SOLID 原则 -OCP</h2>

<p>开闭原则 Open Closed Principle</p>

<ul>
  <li>software entities (modules, classes, functions, etc.) should be open for extension ,but closed for modification.</li>
  <li>在写代码的时候后，思考一下这段代码未来可能有哪些需求变更、如何设计代码结构，预留扩展点。在识别出代码可变部分和不可变部分之后，我们要将可变部分封装起来，隔离变化，提供抽象化的不可变接口，给上层系统使用。</li>
  <li>利用多态、依赖注入、抽象意识、基于接口而非实现编程，来实现“对扩展开放、对修改关闭”。</li>
</ul>

<h2 id="solid-原则--lsp">SOLID 原则 -LSP</h2>

<p>里式替换原则 Liskov Substitution Principle</p>

<ul>
  <li>If S is a subtype of T, then objects of type T may be replaced with objects of type S, without breaking the program.</li>
  <li>子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏原有程序的正确性。</li>
  <li>Design By Contract 子类在设计的时候，要遵守父类的行为约定/协议，在保证兼容的前提条件下做扩展和调整，相当于细粒度的开闭原则。</li>
</ul>

<h2 id="solid-原则--isp">SOLID 原则 -ISP</h2>

<p>接口隔离原则 Interface Segregation Principle</p>

<ul>
  <li>Clients should not be forced to depend upon interfaces that they do not use.</li>
  <li>接口调用者不应该强迫依赖它不需要的接口。</li>
  <li>接口调用者只使用部分接口或者接口部分功能，则接口设计NO SRP</li>
  <li>多个特定客户端接口要好于一个宽泛用途的接口.</li>
</ul>

<h2 id="solid-原则--dip">SOLID 原则 -DIP</h2>

<p>依赖反转原则 Dependency Inversion Principle</p>

<ul>
  <li>
    <p>High-level modules shouldn’t depend on low-level modules. Both modules should depend on abstractions. In addition, abstractions shouldn’t depend on details. Details depend on abstractions.
用来指导框架层面的设计：高层模块不依赖低层模块，它们共同依赖同一个抽象。抽象不要依赖具体实现细
节，具体实现细节依赖抽象。</p>
  </li>
  <li>
    <p>控制反转 IOC Inversion Of Control</p>
  </li>
</ul>

<blockquote>
  <p>“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程可以通过框架来控制。流程的控制权从程序员“反转”到了框架。</p>
</blockquote>

<ul>
  <li>依赖注入 DI Dependency Injection</li>
</ul>

<blockquote>
  <p>不通过 new() 的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。</p>
</blockquote>

<h2 id="more">More</h2>

<ul>
  <li>
    <p>KISS 原则 Keep It Simple and Stupid.</p>

    <ul>
      <li>不要使用同事可能不懂的技术来实现代码</li>
      <li>不要重复造轮子，要善于使用已经有的工具类库</li>
      <li>不要过度优化</li>
    </ul>
  </li>
  <li>
    <p>YAGNI 原则 You Ain’t Gonna Need It</p>
  </li>
  <li>
    <p>DRY 原则 Don’t Repeat Yourself</p>

    <ul>
      <li>实现逻辑重复、功能语义重复、代码执行重复</li>
      <li>代码复用意识：。在设计每个模块、类、函数的时候，要像设计一个外部 API 一样去思考它的复用性。</li>
    </ul>
  </li>
  <li>
    <p>LOD 原则 Law of Demeter</p>

    <blockquote>
      <p>高内聚、松耦合 ： 对于类，“高内聚”用来指导类本身的设计，相近的功能往往会被同时修改，放到同一个类中，修改会比较集中，代码容易维护。“松耦合”用来指导类与类之间依赖关系的设计。</p>
    </blockquote>

    <ul>
      <li>又称：最小知识原则 The Least Knowledge Principle</li>
    </ul>

    <blockquote>
      <p>Each unit should have only limited knowledge about other units: only units “closely” related to the current unit. Or: Each unit should only talk to its friends; Don’t talk to strangers.</p>
    </blockquote>

    <ul>
      <li>不该有直接依赖关系的类之间，不要有依赖</li>
      <li>有依赖关系的类之间，尽量只依赖必要的接口</li>
      <li>迪米特法则是希望减少类之间的耦合，让类越独立越好。每个类都应该少了解系统的其他部分。一旦发生变化，需要了解这一变化的类就会比较少。</li>
    </ul>
  </li>
</ul>

<h1 id="业务系统开发">业务系统开发</h1>

<blockquote>
  <p>端到端（end to end）开发一个完整的系统，工作包括：前期的需求沟通分析、中期的代码设计实现、后期的系统上线维护等。</p>
</blockquote>

<ul>
  <li>需求分析</li>
</ul>

<blockquote>
  <p>爱因斯坦说过，“创造的一大秘诀是要懂得如何隐藏你的来源”</p>

  <p>产品设计文档（PRD）、线框图、、用户用例（user case）</p>
</blockquote>

<ul>
  <li>系统设计</li>
</ul>

<blockquote>
  <p>聚焦架构层面，针对模块。</p>

  <ol>
    <li>合理地将功能划分到不同模块。为了避免业务知识的耦合，让下层系统更加通用，下层系统（也就是被调用的系统）不应该包含太多上层系统（也就是调用系统）的业务信息。</li>
    <li>设计模块与模块之间的交互关系。常见交互方式一种是同步接口调用，另一种是利用消息中间件异步调用。</li>
    <li>设计模块的接口、数据库、业务模型</li>
    <li>业务模型/业务逻辑：Controller 层负责接口暴露，Repository 层负责数据读写，Service 层负责核心业务逻辑。
      <ol>
        <li>分层的作用：代码复用、隔离变化、提高代码可测试性。</li>
        <li>应对复杂系统：水平方向基于业务拆分-模块化；垂直方向基于流程拆分-分层。</li>
      </ol>
    </li>
  </ol>
</blockquote>

<h1 id="设计模式">设计模式</h1>

<blockquote>
  <p>设计模式可以让我们写出易扩展的代码</p>
</blockquote>

<ul>
  <li>创建型
    <ul>
      <li>常用：单例模式、工厂模式、建造者模式</li>
      <li>不常用：原型模式</li>
    </ul>
  </li>
  <li>结构型
    <ul>
      <li>常用：代理模式、桥接模式、装饰者模式、适配器模式</li>
      <li>不常用：门面模式、组合模式、享元模式</li>
    </ul>
  </li>
  <li>行为型
    <ul>
      <li>常用：观察者模式、模板模式、策略模式、职责链模式、迭代器模式、状态模式</li>
      <li>不常用：访问者模式、备忘录模式、命令模式、解释器模式、中介模式</li>
    </ul>
  </li>
</ul>

<h2 id="创建型模式">创建型模式</h2>

<blockquote>
  <p>创建型模式主要解决对象的创建问题，封装复杂的创建过程，解耦对象的创建代码和使用代码。</p>
</blockquote>

<ul>
  <li>单例模式用来创建全局唯一的对象。</li>
  <li>工厂模式用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。</li>
  <li>建造者模式是用来创建复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象。</li>
  <li>原型模式针对创建成本比较大的对象，利用对已有对象进行复制的方式进行创建，以达到节省创建时间的目的。</li>
</ul>

<h3 id="单例模式">单例模式</h3>

<blockquote>
  <p>Singleton Design Pattern 一个类只允许创建一个对象（或者实例）</p>
</blockquote>

<blockquote>
  <p>实例：处理资源访问冲突、表示全局唯一类</p>

  <p>实现方式：饿汉式、懒汉式、双重检测、静态内部类、枚举。</p>
</blockquote>

<h3 id="工厂模式">工厂模式</h3>

<blockquote>
  <p>Factory Design Pattern</p>

  <p>当创建逻辑比较复杂时考虑使用工厂模式，封装对象的创建过程，将对象的创建和使用相分离。</p>

  <p>实例：规则配置解析，代码中存在 if-else 分支判断，动态地根据不同的类型创建不同的对象</p>
</blockquote>

<ul>
  <li>
    <p>简单工厂/静态工厂方法</p>

    <blockquote>
      <p>一个类只负责对象的创建，类一般以“Factory”结尾，创建对象的方法一般以create 开头</p>
    </blockquote>
  </li>
  <li>
    <p>工厂方法</p>

    <blockquote>
      <p>将复杂的创建逻辑拆分到多个工厂类</p>
    </blockquote>
  </li>
  <li>
    <p>抽象工厂</p>
  </li>
</ul>

<h3 id="建造者模式">建造者模式</h3>

<blockquote>
  <p>builder模式/生成器模式</p>

  <p>让建造者类来负责对象的创建工作，用来创建一种类型的复杂对象，通过设置不同的可选参数，“定制化”地创建不同的对象。</p>
</blockquote>

<blockquote>
  <p>顾客走进一家餐馆点餐，我们利用工厂模式，根据用户不同的选择，来制作不同的食物，比如披萨、汉堡、沙拉。对于披萨来说，用户又有各种配料可以定制，比如奶酪、西红柿、起司，我们通过建造者模式根据用户选择的不同配料来制作披萨。</p>
</blockquote>

<h3 id="原型模式">原型模式</h3>

<blockquote>
  <p>对象的创建成本比较大时，利用对已有对象（原型）进行复制（或者叫拷贝）的方式来创建新对象。</p>

  <p>对象的创建成本比较大：对象中的数据需要经过复杂的计算才能得到（比如排序、计算哈希值），或者需要从 RPC、网络、数据库、文件系统等非常慢速的 IO 中读取。</p>

  <p>实现方式：深拷贝、浅拷贝</p>
</blockquote>

<h2 id="结构型模式">结构型模式</h2>

<blockquote>
  <p>结构型设计模式主要解决“类或对象的组合或组装”问题，即将不同功能代码解耦。</p>
</blockquote>

<ul>
  <li>代理模式：代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同。</li>
  <li>桥接模式：桥接模式的目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变。</li>
  <li>装饰器模式：装饰者模式在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用。</li>
  <li>适配器模式：适配器模式是一种事后的补救策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口。</li>
</ul>

<h3 id="代理模式">代理模式</h3>

<blockquote>
  <p>Proxy Design Pattern ：在不改变原始类（或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能。一般情况下，我们让代理类和原始类实现同样的接口，或者让代理类继承原始类的方法。</p>

  <p>动态代理（Dynamic Proxy），就是不事先为每个原始类编写代理类，而是在运行的时候，动态地创建原始类对应的代理类。</p>

  <p>应用场景：业务系统的非功能性需求开发比如：监控、统计、鉴权、限流、事务、幂等、日志。</p>

  <p>​					在 RPC(远程代理)、缓存中的应用。</p>
</blockquote>

<h3 id="桥接模式">桥接模式</h3>

<blockquote>
  <p>Bridge Design Pattern ：Decouple an abstraction from its implementation so that the two can vary independently.  将抽象和实现解耦，让它们可以独立变化。</p>

  <p>组合优于继承。</p>
</blockquote>

<h3 id="装饰器模式">装饰器模式</h3>

<blockquote>
  <p>解决继承关系过于复杂的问题，通过组合来替代继承。主要作用是给原始类添加增强功能。</p>
</blockquote>

<h3 id="适配器模式">适配器模式</h3>

<blockquote>
  <p>Adapter Design Pattern 让原本由于接口不兼容而不能一起工作的类可以一起工作</p>

  <p>两种实现方式：类适配器 (使用继承实现) 和对象适配器 (使用组合实现)</p>

  <p>使用场景(事后补救)：封装有缺陷的接口设计、统一多个类的接口设计、替换依赖的外部系统、兼容老版本接口、适配不同格式的数据</p>
</blockquote>

<h2 id="行为型模式">行为型模式</h2>

<blockquote>
  <p>行为型设计模式主要解决的就是“类或对象之间的交互”问题，即将不同的行为代码解耦。</p>
</blockquote>

<h3 id="观察者模式">观察者模式</h3>

<blockquote>
  <p>Observer Design Pattern 或称发布订阅模式（Publish-Subscribe Design Pattern）。</p>

  <p>Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically. 在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。</p>

  <p>Subject-Observer、Publisher-Subscriber、Producer-Consumer、Event Emitter-Event Listener、Dispatcher-Listener。</p>
</blockquote>

<h3 id="模板模式">模板模式</h3>

<blockquote>
  <p>Template Method Design Pattern</p>

  <p>Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure. 模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。</p>

  <p>模板模式的两大作用：复用和扩展。复用指所有的子类可以复用父类中提供的模板方法的代码。扩展指框架通过模板模式提供功能扩展点，让框架用户可以在不修改框架源码的情况下，基于扩展点定制化框架的功能。回调具有同样功能。</p>

  <p>应用场景上看，同步回调看起来更像模板模式，异步回调看起来更像观察者模式。</p>

  <p>代码实现上看，回调基于组合，把一个对象传递给另一个对象。模板模式基于继承，子类重写父类的抽
象方法。</p>
</blockquote>

<h3 id="策略模式">策略模式</h3>

<blockquote>
  <p>Strategy Design Pattern</p>

  <p>Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it. 定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。策略模式可以使算法的变化独立于使用它们的客户端（这里的客户端代指使用算法的代码）。</p>

  <ul>
    <li>策略类的定义，包含一个策略接口和一组实现这个接口的策略类</li>
    <li>策略的创建，一般会通过类型（type）来判断创建哪个策略来使用</li>
    <li>策略的使用，运行时动态确定使用哪种策略</li>
  </ul>

  <p>应用场景：利用它来避免冗长的 if-else 或 switch 分支判断。</p>

  <p>​					本质上点讲，是借助“查表法”，根据 type 查表替代根据 type 分支判断。</p>
</blockquote>

<h3 id="职责链模式">职责链模式</h3>

<blockquote>
  <p>Chain Of Responsibility Design Pattern</p>

  <p>Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it. 将请求的发送和接收解耦，让多个接收对象都有机会处理这个请求。将这些接收对象串成一条链，并沿着这条链传递这个请求，直到链上的某个接收对象能够处理它为止。</p>

  <p>应用场景：常用来开发框架的过滤器和拦截器，让框架的使用者在不需要修改框架源码的情况下，添加新的过滤拦截功能。</p>
</blockquote>

<h3 id="状态模式">状态模式</h3>

<blockquote>
  <p>状态机/有限状态机 FSM ，Finite State Machine</p>

  <p>状态机有3 个组成部分：状态（State）、事件（Event）、动作（Action）</p>

  <p>实现方式：分支逻辑法、查表法、状态模式</p>
</blockquote>

<h3 id="迭代器模式">迭代器模式</h3>

<blockquote>
  <p>Iterator Design Pattern</p>

  <p>用来遍历集合对象/容器，如数组、链表、树、图。</p>

  <p>一个完整的迭代器模式，一般会涉及容器和容器迭代器两部分内容。</p>

  <p>为了达到基于接口而非实现编程的目的，容器又包含容器接口、容器实现类，迭代器又包含迭代器接口、迭代器实现类。</p>

  <p>容器中需要定义 iterator() 方法，用来创建迭代器。迭代器接口中需要定义hasNext()、currentItem()、next() 三个最基本的方法。容器对象通过依赖注入传递到迭代器类中。</p>
</blockquote>

<h1 id="编程规范">编程规范</h1>

<blockquote>
  <p>编码规范能让我们写出可读性好的代码</p>
</blockquote>

<h1 id="代码重构">代码重构</h1>

<blockquote>
  <p>持续重构可以时刻保持代码的可维护性</p>
</blockquote>

<ul>
  <li>重构的目的（why）、对象（what）、时机（when）、方法（how）</li>
  <li>保证重构不出错的技术手段：单元测试 (代码的可测试性)
    <ul>
      <li>单元测试的测试对象是类或者函数，用来测试一个类和函数是否都按照预期的逻辑执行。</li>
    </ul>
  </li>
  <li>两种不同规模的重构：大重构（大规模高层次）和小重构（小规模低层次、编程规范）。
    <ul>
      <li>大型重构：系统、模块、代码结构、类与类之间的关系等的重构
        <ul>
          <li>重构的手段有：分层、模块化、解耦、抽象可复用组件</li>
        </ul>
      </li>
      <li>小型重构：对类、函数、变量等代码级别的重构
        <ul>
          <li>编码规范：规范命名、规范注释、消除超大类或函数、提取重复代码</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>


</div>
<div class="v">
  <i class="fas fa-spinner fa-pulse"></i>
</div>
<script
  src='https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js'
  defer='defer'
  onload='
    new Valine({
      "el": document.getElementsByClassName("v")[0],
      "appId": "sJhaa5UF52fhugGM95buMpIT-gzGzoHsz",
      "appKey": "Tp95IdLx1TBXyH9tXflqNnXx",
      "placeholder": "在这里评论吧！填写邮箱可以获得Gravatar头像和回复通知",
      "requiredFields": ["nick","mail"],
      "visitor": true,
      "recordIP": true
    })'
></script>

</div>
  </div>
  
  <label for="sidebar-checkbox" class="sidebar-toggle"></label>
  
</body>

</html>