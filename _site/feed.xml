<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="https://acemyzoe.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://acemyzoe.github.io/" rel="alternate" type="text/html" /><updated>2020-11-13T16:02:19+08:00</updated><id>https://acemyzoe.github.io/feed.xml</id><title type="html">Acemyzoe</title><subtitle>人类世界&lt;br/&gt;
真是&lt;br/&gt;
太有趣了&lt;br/&gt;
QAQ&lt;br/&gt;
&lt;a href=&quot;mailto:acemyzoe@outlook.com&quot;&gt;
  &lt;i class=&quot;fas fa-envelope&quot;&gt;&lt;/i&gt;
&lt;/a&gt;
&lt;a href=&quot;https://github.com/acemyzoe&quot;&gt;
  &lt;i class=&quot;fab fa-github&quot;&gt;&lt;/i&gt;
&lt;/a&gt;
&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=100% height=52 src=&quot;//music.163.com/outchain/player?type=2&amp;id=486806&amp;auto=1&amp;height=32&quot;&gt;&lt;/iframe&gt;
</subtitle><entry><title type="html">pyecharts</title><link href="https://acemyzoe.github.io/_posts/2020-11-01-pyecharts/" rel="alternate" type="text/html" title="pyecharts" /><published>2020-11-01T00:00:00+08:00</published><updated>2020-11-01T00:00:00+08:00</updated><id>https://acemyzoe.github.io/_posts/pyecharts</id><content type="html" xml:base="https://acemyzoe.github.io/_posts/2020-11-01-pyecharts/">&lt;h1 id=&quot;pyecharts&quot;&gt;pyecharts&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://pyecharts.org/&quot;&gt;pyecharts.org&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;def draw_charts(userId):
    &quot;&quot;&quot;
    绘图
    &quot;&quot;&quot;
    print(&quot;用户编号：&quot;,userId)
    data_x,data_y,data_x_2,data_y_2,data_x_3,data_y_3 = load_data(userId)
    line = (
        Line()
        .add_xaxis(data_x)
        .add_xaxis(data_x_2)
        .add_xaxis(data_x_3)
        .add_yaxis(&quot;电流有效值&quot;,data_y)
        .add_yaxis(&quot;合并后的电流有效值&quot;,data_y_2)
        .add_yaxis(&quot;电流变化量值&quot;,data_y_3)
        .set_global_opts(
            title_opts=opts.TitleOpts(
                title=&quot;A&quot;,
                subtitle=&quot;ace&quot;,
                ),
            brush_opts=opts.BrushOpts(tool_box = ['rect','polygon','lineX','lineY','keep','clear',]),
            tooltip_opts=opts.TooltipOpts(trigger=&quot;axis&quot;, axis_pointer_type=&quot;cross&quot;),
            legend_opts=opts.LegendOpts(pos_left=&quot;center&quot;),
            datazoom_opts=[
                opts.DataZoomOpts(is_show=True,type_=&quot;inside&quot;, range_start=0, range_end=100),
            ],
            toolbox_opts=opts.ToolboxOpts(is_show=True),
            xaxis_opts=opts.AxisOpts(type_=&quot;time&quot;,min_=&quot;dataMin&quot;,boundary_gap=False),
            )
        .set_series_opts(label_opts=opts.LabelOpts(is_show=False)) # 隐藏数值标签
    )
    if not os.path.exists(&quot;charts&quot;):os.makedirs(&quot;charts&quot;)
    (
        Grid(init_opts=opts.InitOpts(width=&quot;1024px&quot;, height=&quot;1024px&quot;,page_title=userId))
        .add(chart=line, grid_opts=opts.GridOpts(pos_left=50, pos_right=50, height=&quot;35%&quot;))
        .render(&quot;./charts/&quot; + str(userId) + &quot;.html&quot;)
    )
&lt;/code&gt;&lt;/pre&gt;</content><author><name></name></author><category term="python" /><summary type="html">pyecharts</summary></entry><entry><title type="html">毛选阅读摘录</title><link href="https://acemyzoe.github.io/_posts/2020-10-30-%E6%AF%9B%E9%80%89%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" rel="alternate" type="text/html" title="毛选阅读摘录" /><published>2020-10-30T00:00:00+08:00</published><updated>2020-10-30T00:00:00+08:00</updated><id>https://acemyzoe.github.io/_posts/%E6%AF%9B%E9%80%89%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0</id><content type="html" xml:base="https://acemyzoe.github.io/_posts/2020-10-30-%E6%AF%9B%E9%80%89%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">&lt;blockquote&gt;
  &lt;p&gt;《毛泽东选集》第五卷是一九四九年九月到一九五七年的重要著作。毛泽东同志关于在生产资料所有制的社会主义改 造基本完成以后无产阶级和资产阶级、社会主义道路和资本主义道路的斗争还长期存在的科学论断，关于正确区分和处理社会主义社会中敌我矛盾和人民内部矛盾这 两类不同性质的矛盾的学说，关于无产阶级专政下继续革命的伟大理论，关于社会主义建设总路线的基本思想，就是在这卷著作中首次提出的。以后，特别是在无产 阶级文化大革命中，毛泽东同志根据革命实践经验，不断地充实和发展了这些光辉思想。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;三年以来，在人民解放战争和人民革命中牺牲的人民英雄们永垂不朽!&lt;/p&gt;

  &lt;p&gt;三十年以来，在人民解放战争和人民革命中牺牲的人民英雄们永垂不朽!&lt;/p&gt;

  &lt;p&gt;由此上溯到一千八百四十年，从那时起，为了反对内外敌人，争取民族独立和人民自由幸福，在历次斗争中牺牲的人民英雄们永垂不朽 !&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name></name></author><category term="阅读" /><summary type="html">《毛泽东选集》第五卷是一九四九年九月到一九五七年的重要著作。毛泽东同志关于在生产资料所有制的社会主义改 造基本完成以后无产阶级和资产阶级、社会主义道路和资本主义道路的斗争还长期存在的科学论断，关于正确区分和处理社会主义社会中敌我矛盾和人民内部矛盾这 两类不同性质的矛盾的学说，关于无产阶级专政下继续革命的伟大理论，关于社会主义建设总路线的基本思想，就是在这卷著作中首次提出的。以后，特别是在无产 阶级文化大革命中，毛泽东同志根据革命实践经验，不断地充实和发展了这些光辉思想。</summary></entry><entry><title type="html">Java调用Python</title><link href="https://acemyzoe.github.io/_posts/2020-10-28-Java%E8%B0%83%E7%94%A8Python/" rel="alternate" type="text/html" title="Java调用Python" /><published>2020-10-28T00:00:00+08:00</published><updated>2020-10-28T00:00:00+08:00</updated><id>https://acemyzoe.github.io/_posts/Java%E8%B0%83%E7%94%A8Python</id><content type="html" xml:base="https://acemyzoe.github.io/_posts/2020-10-28-Java%E8%B0%83%E7%94%A8Python/">&lt;h1 id=&quot;在java类中直接执行python语句&quot;&gt;在java类中直接执行python语句&lt;/h1&gt;

&lt;h1 id=&quot;在java类中直接调用本地python脚本&quot;&gt;在java类中直接调用本地python脚本&lt;/h1&gt;

&lt;h1 id=&quot;使用runtimegetruntime执行python脚本文件推荐&quot;&gt;使用Runtime.getRuntime()执行python脚本文件（推荐）&lt;/h1&gt;

&lt;h1 id=&quot;调用python脚本中的函数&quot;&gt;调用python脚本中的函数&lt;/h1&gt;</content><author><name></name></author><category term="python" /><summary type="html">在java类中直接执行python语句</summary></entry><entry><title type="html">scikit-learn</title><link href="https://acemyzoe.github.io/_posts/2020-10-28-scikit-learn/" rel="alternate" type="text/html" title="scikit-learn" /><published>2020-10-28T00:00:00+08:00</published><updated>2020-10-28T00:00:00+08:00</updated><id>https://acemyzoe.github.io/_posts/scikit-learn</id><content type="html" xml:base="https://acemyzoe.github.io/_posts/2020-10-28-scikit-learn/">&lt;h1 id=&quot;scikit-learn&quot;&gt;scikit-learn&lt;/h1&gt;

&lt;h2 id=&quot;神经网络mlp&quot;&gt;神经网络MLP&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://scikit-learn.org/stable/modules/classes.html#module-sklearn.neural_network&quot;&gt;&lt;code&gt;sklearn.neural_network&lt;/code&gt;&lt;/a&gt;.MLPRegressor&lt;a href=&quot;https://scikit-learn.org/stable/modules/generated/sklearn.neural_network.MLPRegressor.html#sklearn-neural-network-mlpregressor&quot;&gt;¶&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><category term="python" /><summary type="html">scikit-learn</summary></entry><entry><title type="html">损失函数&amp;amp;评价指标</title><link href="https://acemyzoe.github.io/_posts/2020-10-20-%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0&%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/" rel="alternate" type="text/html" title="损失函数&amp;评价指标" /><published>2020-10-20T00:00:00+08:00</published><updated>2020-10-20T00:00:00+08:00</updated><id>https://acemyzoe.github.io/_posts/%20%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0&amp;%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87</id><content type="html" xml:base="https://acemyzoe.github.io/_posts/2020-10-20-%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0&amp;%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/">&lt;h1 id=&quot;损失函数&quot;&gt;损失函数&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;损失函数&lt;/strong&gt;用来评价模型的&lt;strong&gt;预测值&lt;/strong&gt;和&lt;strong&gt;真实值&lt;/strong&gt;不一样的程度，损失函数越好，通常模型的性能越好。&lt;/p&gt;

&lt;h2 id=&quot;回归问题&quot;&gt;回归问题&lt;/h2&gt;

&lt;h3 id=&quot;平均损失函数最小二乘法&quot;&gt;平均损失函数（最小二乘法）&lt;/h3&gt;

&lt;p&gt;回归问题中常用的损失函数，在线性回归中，可以通过极大似然估计（MLE）推导。计算的是预测值与真实值之间距离的平方和。实际更常用的是&lt;strong&gt;均方误差（MSE）&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;平均值绝对误差l1损失mae&quot;&gt;平均值绝对误差（L1损失）——MAE&lt;/h3&gt;

&lt;p&gt;MAE是目标值和预测值之差的绝对值之和，可以用来衡量预测值和真实值的距离。&lt;/p&gt;

&lt;h3 id=&quot;mael1损失-vs-msel2损失&quot;&gt;MAE（L1损失） VS MSE（L2损失）&lt;/h3&gt;

&lt;p&gt;MSE计算简便，但MAE对异常点有更好的鲁棒性:当数据中存在异常点时，用RMSE计算损失的模型以牺牲了其他样本的误差为代价，朝着减小异常点误差的方向更新，会降低模型的整体性能。&lt;/p&gt;

&lt;p&gt;NN中MAE更新梯度始终相同，而MSE则不同： MSE损失的梯度随损失增大而增大，而损失趋于0时则会减小。&lt;/p&gt;

&lt;p&gt;使用MAE训练神经网络最大的一个问题就是不变的大梯度，这可能导致在使用梯度下降快要结束时，错过了最小点，为了解决这个缺陷，我们可以使用变化的学习率，在损失接近最小值时降低学习率。而对于MSE，梯度会随着损失的减小而减小，这使得在训练结束时，使用MSE模型的结果会更精确。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Loss选择建议：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;MSE：&lt;/strong&gt; 如果异常点代表在商业中很重要的异常情况，并且需要被检测出来&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;MAE：&lt;/strong&gt; 如果只把异常值当作受损数据&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;huber损失&quot;&gt;Huber损失&lt;/h3&gt;

&lt;p&gt;Huber损失是绝对误差，只是在误差很小时，就变为平方误差。&lt;/p&gt;

&lt;p&gt;当δ&lt;em&gt;很大时，等价为&lt;strong&gt;MSE&lt;/strong&gt;曲线，当&lt;/em&gt;δ很小时，等价为&lt;strong&gt;MAE&lt;/strong&gt;曲线。
\(L_\delta(y,f(x))=\{ {
{1\over2}(y-f(x))^2 \qquad for|y-f(x)|&amp;lt;\delta
\atop 
{\delta|y-f(x)|-{1\over2}\delta^2 \qquad otherwise}
}\)&lt;/p&gt;

&lt;h3 id=&quot;logloss&quot;&gt;LogLoss&lt;/h3&gt;

&lt;p&gt;对数损失(Logarithmic Loss), 即对数似然损失(Log-likelihood Loss), 也称交叉熵损失(cross-entropy Loss)。&lt;/p&gt;

&lt;p&gt;对数损失通过惩罚错误的分类,实现对分类器的准确度(Accuracy)的量化。 最小化对数损失基本等价于最大化分类器的准确度。&lt;/p&gt;

&lt;p&gt;当使用sigmoid作为激活函数的时候，常用&lt;strong&gt;交叉熵损失函数&lt;/strong&gt;而不用&lt;strong&gt;均方误差损失函数&lt;/strong&gt;，因为它可以&lt;strong&gt;完美解决平方损失函数权重更新过慢&lt;/strong&gt;的问题，具有“误差大的时候，权重更新快；误差小的时候，权重更新慢”的良好性质。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;#!/usr/bin/env python
# -*- coding: utf8 -*-
# y_true: list, the true labels of input instances 
# y_pred: list, the probability when the predicted label of input instances equals to 1
def logloss(y_true, y_pred, eps=1e-15):
    import numpy as np

    # Prepare numpy array data
    y_true = np.array(y_true)
    y_pred = np.array(y_pred)
    assert (len(y_true) and len(y_true) == len(y_pred))

    # Clip y_pred between eps and 1-eps
    p = np.clip(y_pred, eps, 1-eps)
    loss = np.sum(- y_true * np.log(p) - (1 - y_true) * np.log(1-p))

    return loss / len(y_true)

def unitest():
    y_true = [0, 0, 1, 1]
    y_pred = [0.1, 0.2, 0.7, 0.99]

    print (&quot;Use self-defined logloss() in binary classification, the result is {}&quot;.format(logloss(y_true, y_pred)))

    from sklearn.metrics import log_loss
    print (&quot;Use log_loss() in scikit-learn, the result is {} &quot;.format(log_loss(y_true, y_pred)))

if __name__ == '__main__':
    unitest()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;exponential-loss&quot;&gt;exponential loss&lt;/h3&gt;

&lt;p&gt;指数损失函数，对离群点、噪声非常敏感。经常用在AdaBoost算法中。&lt;/p&gt;

&lt;h1 id=&quot;评价指标&quot;&gt;评价指标&lt;/h1&gt;

&lt;p&gt;如何评估机器学习算法模型是任何项目中一个非常重要的环节。分类问题一般会选择准确率（Accuracy）或者AUC作为metric，回归问题使用MSE。上述损失函数大部分可以直接作为评价指标来使用。&lt;/p&gt;

&lt;h2 id=&quot;回归问题-1&quot;&gt;回归问题&lt;/h2&gt;

&lt;h3 id=&quot;mse&quot;&gt;MSE&lt;/h3&gt;

&lt;p&gt;均方误差 (Mean Square Error)
\(MSE={1\over n}{\sum^{n}_{i=1}(\hat{y_i} -{y_i})^2}\)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;范围[0,+∞)，当预测值与真实值完全吻合时等于0，即完美模型；误差越大，该值越大。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;rmse&quot;&gt;RMSE&lt;/h3&gt;

&lt;p&gt;均方根误差 (Root Mean Square Error)
\(RMSE=\sqrt {MSE} = \sqrt {\frac{1}{n} \sum_{i=1}^{n} (\hat{y}_i - y_i)^2}\)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;数量级上比较直观，比如RMSE=10，可以认为回归效果相比真实值平均相差10。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;mae&quot;&gt;MAE&lt;/h3&gt;

&lt;p&gt;平均绝对误差(Mean Absolute Error)
\(MAE=\frac{1}{n} \sum_{i=1}^{n} |\hat{y}_i - y_i|\)&lt;/p&gt;

&lt;h3 id=&quot;mape&quot;&gt;MAPE&lt;/h3&gt;

&lt;p&gt;平方绝对百分比误差 (Mean Absolute Percentage Error)
\(MAPE=\frac{100\%}{n}\sum_{i=1}^n |\frac{ \hat{y}_i - y_i }{ y_i }|\)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;当真实值有数据等于0时，存在分母0除问题，该公式不可用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;smape&quot;&gt;SMAPE&lt;/h3&gt;

&lt;p&gt;对称平均绝对百分比误差 (Symmetric Mean Absolute Percentage Error)
\(SMAPE=\frac{100\%}{n}\sum_{i=1}^n \frac{ |\hat{y}_i - y_i| }{ (|\hat{y}_i| + |y_i|)/2 }\)&lt;/p&gt;

&lt;h3 id=&quot;r-squared&quot;&gt;R Squared&lt;/h3&gt;

&lt;p&gt;决定系数 (coefficient of determination)
\(R^2=1-{\frac {\sum _i (\hat y_i-y_i)^2}{\sum _i (\overline y-y_i)^2}}\)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;分母代表baseline（平均值）的误差，分子代表模型的预测结果产生的误差；&lt;/li&gt;
    &lt;li&gt;预测结果越大越好，R为1说明完美拟合， 为0说明和baseline一致；&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;分类问题&quot;&gt;分类问题&lt;/h2&gt;

&lt;h3 id=&quot;confusion-matrix&quot;&gt;Confusion Matrix&lt;/h3&gt;

&lt;p&gt;混淆矩阵，后续多个指标的基础。&lt;/p&gt;

&lt;p&gt;eg. 二类混淆矩阵(训练目的：减少FP、FN)&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;预测正例&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;预测反例&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;真实正例&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;TP 真正例&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;FN 假反例&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;真实反例&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;FP 假反例&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;TN 真反例&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;accuracy&quot;&gt;Accuracy&lt;/h3&gt;

&lt;p&gt;准确率：当样本类别均衡时，Accuracy是一个很好的指标。但在样本不平衡的情况下，产生效果较差。
\(Acc=\frac {TP+TN}{TP+TN+FP+FN}\)&lt;/p&gt;

&lt;h3 id=&quot;precision&quot;&gt;Precision&lt;/h3&gt;

&lt;p&gt;精准率：预测为正例的样本中有多少实际为正。
\(P=\frac {TP}{TP+FP}\)&lt;/p&gt;

&lt;h3 id=&quot;recall&quot;&gt;Recall&lt;/h3&gt;

&lt;p&gt;召回率：实际为正例的样本有多少被预测为正。
\(R=\frac {TP}{TP+FN}\)&lt;/p&gt;

&lt;h3 id=&quot;p-r曲线&quot;&gt;P-R曲线&lt;/h3&gt;

&lt;p&gt;通过选择不同的阈值，得到Recall和Precision，以Recall为横坐标，Precision为纵坐标得到的曲线图。&lt;/p&gt;

&lt;h3 id=&quot;加权调和平均调和平均&quot;&gt;加权调和平均&amp;amp;调和平均&lt;/h3&gt;

&lt;p&gt;beta&amp;gt;1时召回率（Recall）影响更大。&lt;/p&gt;

&lt;p&gt;beta&amp;lt;1时，精确率（Precision）影响更大。
\(F_\beta=\frac{(1+\beta^2)PR}{\beta^2P+R},(\beta=1时)F_1=\frac {2PR}{P+R}\)&lt;/p&gt;

&lt;h3 id=&quot;roc-auc&quot;&gt;ROC-AUC&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Area Under Curve(AUC)&lt;/strong&gt; 是&lt;strong&gt;二分类&lt;/strong&gt;问题中使用非常广泛的一个评价指标。&lt;strong&gt;AUC的本质是，任取一个正样本和负样本，模型输出正样本的值大于负样本值的概率&lt;/strong&gt;。构成AUC的两个基本指标是假正例率和真正例率。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;横轴-假正例率：&lt;/strong&gt; 实际为负的样本多少被预测为正。FPR。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;纵轴-真正例率：&lt;/strong&gt; 实际为正的样本多少被预测为正。TPR。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;TPR和FPR的范围均是[0,1]，通过选择不同的阈值得到TPR和FPR，然后绘制ROC曲线。ROC曲线下的面积为AUC值。&lt;/p&gt;

&lt;h2 id=&quot;代码&quot;&gt;代码&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# coding=utf-8
import numpy as np
from sklearn import metrics
y_true=np.array([1.1,3.3,5.5,7.7])
y_pred=np.array([1.0,3.0,5.0,7.0])

# MSE
def MSE(true, pred):
    return np.sum((true - pred)**2)
mse=metrics.mean_squared_error(y_true,y_pred)
# RMSE
rmse=np.sqrt(mse)
# MAE
def mae(true, pred):
    return np.sum(np.abs(true - pred))
mae=metrics.mean_absolute_error(y_true,y_pred)
# MAPE
mape=np.mean(np.abs(y_pred-y_true)/y_true)*100
#SMPAE
smape=np.mean(2*np.abs(y_pred-y_true)/(np.abs(y_pred)+np.abs(y_true)))*100
# R Squared
RS=metrics.r2_score(y_true,y_pred)
# huber loss
def huber(true, pred, delta):
    loss = np.where(np.abs(true-pred) &amp;lt; delta , 0.5*((true-pred)**2), delta*np.abs(true - pred) - 0.5*(delta**2))
    return np.sum(loss)

y_trues = [1,1,1,1,0,0,1,1,1,0,0]
y_preds = [1,1,1,0,1,1,0,1,1,1,0] 

# ACC准确率
acc=metrics.accuracy_score(y_trues,y_preds)
# Precision精准率
P=metrics.precision_score(y_trues,y_preds)
# Recall召回率
R=metrics.recall_score(y_trues,y_preds)
# F
F=metrics.fbeta_score(y_trues,y_preds,beta=1)
&lt;/code&gt;&lt;/pre&gt;</content><author><name></name></author><category term="ML" /><summary type="html">损失函数</summary></entry><entry><title type="html">pandas</title><link href="https://acemyzoe.github.io/_posts/2020-10-20-pandas/" rel="alternate" type="text/html" title="pandas" /><published>2020-10-20T00:00:00+08:00</published><updated>2020-10-20T00:00:00+08:00</updated><id>https://acemyzoe.github.io/_posts/pandas</id><content type="html" xml:base="https://acemyzoe.github.io/_posts/2020-10-20-pandas/">&lt;h1 id=&quot;pandas&quot;&gt;pandas&lt;/h1&gt;

&lt;h1 id=&quot;some-issues&quot;&gt;some issues&lt;/h1&gt;

&lt;h2 id=&quot;pandasto_datetime-&quot;&gt;pandas.to_datetime &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.to_datetime.html#pandas-to-datetime&quot;&gt;¶&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;将参数转换为日期时间。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;import pandas as pd
print(pd.to_datetime('20200101', format='%Y%m%d', errors='ignore'))
df = pd.DataFrame({'year': [2015, 2016],
                   'month': [2, 3],
                   'day': [4, 5]})
print(pd.to_datetime(df))
&lt;/code&gt;&lt;/pre&gt;</content><author><name></name></author><category term="python" /><summary type="html">pandas</summary></entry><entry><title type="html">Markdown数学公式</title><link href="https://acemyzoe.github.io/_posts/2020-10-18-markdown%E5%85%AC%E5%BC%8F/" rel="alternate" type="text/html" title="Markdown数学公式" /><published>2020-10-18T00:00:00+08:00</published><updated>2020-10-18T00:00:00+08:00</updated><id>https://acemyzoe.github.io/_posts/%20markdown%E5%85%AC%E5%BC%8F</id><content type="html" xml:base="https://acemyzoe.github.io/_posts/2020-10-18-markdown%E5%85%AC%E5%BC%8F/">&lt;h1 id=&quot;markdown数学公式&quot;&gt;Markdown数学公式&lt;/h1&gt;

&lt;h2 id=&quot;上标下标与组合&quot;&gt;上标、下标与组合&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;上标符号，符号：&lt;code&gt;^&lt;/code&gt;，如：$x^4$&lt;/li&gt;
  &lt;li&gt;下标符号，符号：&lt;code&gt;_&lt;/code&gt;，如：$ x_1 $&lt;/li&gt;
  &lt;li&gt;组合符号，符号：&lt;code&gt;{}&lt;/code&gt;，如：${16}&lt;em&gt;{8}O{2+}&lt;/em&gt;{2}$&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;汉字字体与格式&quot;&gt;汉字、字体与格式&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;汉字形式，符号：&lt;code&gt;\mbox{}&lt;/code&gt;，如：$V_{\mbox{初始}}$&lt;/li&gt;
  &lt;li&gt;字体控制，符号：&lt;code&gt;\displaystyle&lt;/code&gt;，如：$\displaystyle \frac{x+y}{y+z}$&lt;/li&gt;
  &lt;li&gt;下划线符号，符号：&lt;code&gt;\underline&lt;/code&gt;，如：$\underline{x+y}$&lt;/li&gt;
  &lt;li&gt;标签，符号&lt;code&gt;\tag{数字}&lt;/code&gt;，如：$\tag{11}$&lt;/li&gt;
  &lt;li&gt;上大括号，符号：&lt;code&gt;\overbrace{算式}&lt;/code&gt;，如：$\overbrace{a+b+c+d}^{2.0}$&lt;/li&gt;
  &lt;li&gt;下大括号，符号：&lt;code&gt;\underbrace{算式}&lt;/code&gt;，如：$a+\underbrace{b+c}_{1.0}+d$&lt;/li&gt;
  &lt;li&gt;上位符号，符号：&lt;code&gt;\stacrel{上位符号}{基位符号}&lt;/code&gt;，如：$\vec{x}\stackrel{\mathrm{def}}{=}{x_1,\dots,x_n}$&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;占位符&quot;&gt;占位符&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;两个quad空格，符号：&lt;code&gt;\qquad&lt;/code&gt;，如：$x \qquad y$&lt;/li&gt;
  &lt;li&gt;quad空格，符号：&lt;code&gt;\quad&lt;/code&gt;，如：$x \quad y$&lt;/li&gt;
  &lt;li&gt;大空格，符号&lt;code&gt;\&lt;/code&gt;，如：$x \  y$&lt;/li&gt;
  &lt;li&gt;中空格，符号&lt;code&gt;\:&lt;/code&gt;，如：$x : y$&lt;/li&gt;
  &lt;li&gt;小空格，符号&lt;code&gt;\,&lt;/code&gt;，如：$x , y$&lt;/li&gt;
  &lt;li&gt;没有空格，符号``，如：$xy$&lt;/li&gt;
  &lt;li&gt;紧贴，符号&lt;code&gt;\!&lt;/code&gt;，如：$x ! y$&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;定界符与组合&quot;&gt;定界符与组合&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;括号，符号：&lt;code&gt;（）\big(\big) \Big(\Big) \bigg(\bigg) \Bigg(\Bigg)&lt;/code&gt;，如：$（）\big(\big) \Big(\Big) \bigg(\bigg) \Bigg(\Bigg)$&lt;/li&gt;
  &lt;li&gt;中括号，符号：&lt;code&gt;[]&lt;/code&gt;，如：$[x+y]$&lt;/li&gt;
  &lt;li&gt;大括号，符号：&lt;code&gt;\{ \}&lt;/code&gt;，如：${x+y}$&lt;/li&gt;
  &lt;li&gt;自适应括号，符号：&lt;code&gt;\left \right&lt;/code&gt;，如：$\left(x\right)$，$\left(x{yz}\right)$&lt;/li&gt;
  &lt;li&gt;组合公式，符号：&lt;code&gt;{上位公式 \choose 下位公式}&lt;/code&gt;，如：${n+1 \choose k}={n \choose k}+{n \choose k-1}$&lt;/li&gt;
  &lt;li&gt;组合公式，符号：&lt;code&gt;{上位公式 \atop 下位公式}&lt;/code&gt;，如：$\sum_{k_0,k_1,\ldots&amp;gt;0 \atop k_0+k_1+\cdots=n}A_{k_0}A_{k_1}\cdots$&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;四则运算&quot;&gt;四则运算&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;加法运算，符号：&lt;code&gt;+&lt;/code&gt;，如：$x+y=z$&lt;/li&gt;
  &lt;li&gt;减法运算，符号：&lt;code&gt;-&lt;/code&gt;，如：$x-y=z$&lt;/li&gt;
  &lt;li&gt;加减运算，符号：&lt;code&gt;\pm&lt;/code&gt;，如：$x \pm y=z$&lt;/li&gt;
  &lt;li&gt;减甲运算，符号：&lt;code&gt;\mp&lt;/code&gt;，如：$x \mp y=z$&lt;/li&gt;
  &lt;li&gt;乘法运算，符号：&lt;code&gt;\times&lt;/code&gt;，如：$x \times y=z$&lt;/li&gt;
  &lt;li&gt;点乘运算，符号：&lt;code&gt;\cdot&lt;/code&gt;，如：$x \cdot y=z$&lt;/li&gt;
  &lt;li&gt;星乘运算，符号：&lt;code&gt;\ast&lt;/code&gt;，如：$x \ast y=z$&lt;/li&gt;
  &lt;li&gt;除法运算，符号：&lt;code&gt;\div&lt;/code&gt;，如：$x \div y=z$&lt;/li&gt;
  &lt;li&gt;斜法运算，符号：&lt;code&gt;/&lt;/code&gt;，如：$x/y=z$&lt;/li&gt;
  &lt;li&gt;分式表示，符号：&lt;code&gt;\frac{分子}{分母}&lt;/code&gt;，如：$\frac{x+y}{y+z}$&lt;/li&gt;
  &lt;li&gt;分式表示，符号：&lt;code&gt;{分子} \voer {分母}&lt;/code&gt;，如：${x+y} \over {y+z}$&lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;绝对值表示，符号：&lt;code&gt;||&lt;/code&gt;，如：$&lt;/td&gt;
          &lt;td&gt;x+y&lt;/td&gt;
          &lt;td&gt;$&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;高级运算&quot;&gt;高级运算&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;平均数运算，符号：&lt;code&gt;\overline{算式}&lt;/code&gt;，如：$\overline{xyz}$&lt;/li&gt;
  &lt;li&gt;开二次方运算，符号：&lt;code&gt;\sqrt&lt;/code&gt;，如：$\sqrt x$&lt;/li&gt;
  &lt;li&gt;开方运算，符号：&lt;code&gt;\sqrt[开方数]{被开方数}&lt;/code&gt;，如：$\sqrt[3]{x+y}$&lt;/li&gt;
  &lt;li&gt;对数运算，符号：&lt;code&gt;\log&lt;/code&gt;，如：$\log(x)$&lt;/li&gt;
  &lt;li&gt;极限运算，符号：&lt;code&gt;\lim&lt;/code&gt;，如：$\lim^{x \to \infty}_{y \to 0}{\frac{x}{y}}$&lt;/li&gt;
  &lt;li&gt;极限运算，符号：&lt;code&gt;\displaystyle \lim&lt;/code&gt;，如：$\displaystyle \lim^{x \to \infty}_{y \to 0}{\frac{x}{y}}$&lt;/li&gt;
  &lt;li&gt;求和运算，符号：&lt;code&gt;\sum&lt;/code&gt;，如：$\sum^{x \to \infty}_{y \to 0}{\frac{x}{y}}$&lt;/li&gt;
  &lt;li&gt;求和运算，符号：&lt;code&gt;\displaystyle \sum&lt;/code&gt;，如：$\displaystyle \sum^{x \to \infty}_{y \to 0}{\frac{x}{y}}$&lt;/li&gt;
  &lt;li&gt;积分运算，符号：&lt;code&gt;\int&lt;/code&gt;，如：$\int^{\infty}_{0}{xdx}$&lt;/li&gt;
  &lt;li&gt;积分运算，符号：&lt;code&gt;\displaystyle \int&lt;/code&gt;，如：$\displaystyle \int^{\infty}_{0}{xdx}$&lt;/li&gt;
  &lt;li&gt;微分运算，符号：&lt;code&gt;\partial&lt;/code&gt;，如：$\frac{\partial x}{\partial y}$&lt;/li&gt;
  &lt;li&gt;矩阵表示，符号：&lt;code&gt;\begin{matrix} \end{matrix}&lt;/code&gt;，如：$\left[ \begin{matrix} 1 &amp;amp;2 &amp;amp;\cdots &amp;amp;4 &amp;amp;5 &amp;amp;6 &amp;amp;\cdots &amp;amp;8\vdots &amp;amp;\vdots &amp;amp;\ddots &amp;amp;\vdots&amp;amp;13 &amp;amp;14 &amp;amp;\cdots &amp;amp;16\end{matrix} \right]$&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;逻辑运算&quot;&gt;逻辑运算&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;等于运算，符号：&lt;code&gt;=&lt;/code&gt;，如：$x+y=z$&lt;/li&gt;
  &lt;li&gt;大于运算，符号：&lt;code&gt;&amp;gt;&lt;/code&gt;，如：$x+y&amp;gt;z$&lt;/li&gt;
  &lt;li&gt;小于运算，符号：&lt;code&gt;&amp;lt;&lt;/code&gt;，如：$x+y&amp;lt;z$&lt;/li&gt;
  &lt;li&gt;大于等于运算，符号：&lt;code&gt;\geq&lt;/code&gt;，如：$x+y \geq z$&lt;/li&gt;
  &lt;li&gt;小于等于运算，符号：&lt;code&gt;\leq&lt;/code&gt;，如：$x+y \leq z$&lt;/li&gt;
  &lt;li&gt;不等于运算，符号：&lt;code&gt;\neq&lt;/code&gt;，如：$x+y \neq z$&lt;/li&gt;
  &lt;li&gt;不大于等于运算，符号：&lt;code&gt;\ngeq&lt;/code&gt;，如：$x+y \ngeq z$&lt;/li&gt;
  &lt;li&gt;不大于等于运算，符号：&lt;code&gt;\not\geq&lt;/code&gt;，如：$x+y \not\geq z$&lt;/li&gt;
  &lt;li&gt;不小于等于运算，符号：&lt;code&gt;\nleq&lt;/code&gt;，如：$x+y \nleq z$&lt;/li&gt;
  &lt;li&gt;不小于等于运算，符号：&lt;code&gt;\not\leq&lt;/code&gt;，如：$x+y \not\leq z$&lt;/li&gt;
  &lt;li&gt;约等于运算，符号：&lt;code&gt;\approx&lt;/code&gt;，如：$x+y \approx z$&lt;/li&gt;
  &lt;li&gt;恒定等于运算，符号：&lt;code&gt;\equiv&lt;/code&gt;，如：$x+y \equiv z$&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;集合运算&quot;&gt;集合运算&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;属于运算，符号：&lt;code&gt;\in&lt;/code&gt;，如：$x \in y$&lt;/li&gt;
  &lt;li&gt;不属于运算，符号：&lt;code&gt;\notin&lt;/code&gt;，如：$x \notin y$&lt;/li&gt;
  &lt;li&gt;不属于运算，符号：&lt;code&gt;\not\in&lt;/code&gt;，如：$x \not\in y$&lt;/li&gt;
  &lt;li&gt;子集运算，符号：&lt;code&gt;\subset&lt;/code&gt;，如：$x \subset y$&lt;/li&gt;
  &lt;li&gt;子集运算，符号：&lt;code&gt;\supset&lt;/code&gt;，如：$x \supset y$&lt;/li&gt;
  &lt;li&gt;真子集运算，符号：&lt;code&gt;\subseteq&lt;/code&gt;，如：$x \subseteq y$&lt;/li&gt;
  &lt;li&gt;非真子集运算，符号：&lt;code&gt;\subsetneq&lt;/code&gt;，如：$x \subsetneq y$&lt;/li&gt;
  &lt;li&gt;真子集运算，符号：&lt;code&gt;\supseteq&lt;/code&gt;，如：$x \supseteq y$&lt;/li&gt;
  &lt;li&gt;非真子集运算，符号：&lt;code&gt;\supsetneq&lt;/code&gt;，如：$x \supsetneq y$&lt;/li&gt;
  &lt;li&gt;非子集运算，符号：&lt;code&gt;\not\subset&lt;/code&gt;，如：$x \not\subset y$&lt;/li&gt;
  &lt;li&gt;非子集运算，符号：&lt;code&gt;\not\supset&lt;/code&gt;，如：$x \not\supset y$&lt;/li&gt;
  &lt;li&gt;并集运算，符号：&lt;code&gt;\cup&lt;/code&gt;，如：$x \cup y$&lt;/li&gt;
  &lt;li&gt;交集运算，符号：&lt;code&gt;\cap&lt;/code&gt;，如：$x \cap y$&lt;/li&gt;
  &lt;li&gt;差集运算，符号：&lt;code&gt;\setminus&lt;/code&gt;，如：$x \setminus y$&lt;/li&gt;
  &lt;li&gt;同或运算，符号：&lt;code&gt;\bigodot&lt;/code&gt;，如：$x \bigodot y$&lt;/li&gt;
  &lt;li&gt;同与运算，符号：&lt;code&gt;\bigotimes&lt;/code&gt;，如：$x \bigotimes y$&lt;/li&gt;
  &lt;li&gt;实数集合，符号：&lt;code&gt;\mathbb{R}&lt;/code&gt;，如：&lt;code&gt;\mathbb{R}&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;自然数集合，符号：&lt;code&gt;\mathbb{Z}&lt;/code&gt;，如：&lt;code&gt;\mathbb{Z}&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;空集，符号：&lt;code&gt;\emptyset&lt;/code&gt;，如：$\emptyset$&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;数学符号&quot;&gt;数学符号&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;无穷，符号：&lt;code&gt;\infty&lt;/code&gt;，如：$\infty$&lt;/li&gt;
  &lt;li&gt;虚数，符号：&lt;code&gt;\imath&lt;/code&gt;，如：$\imath$&lt;/li&gt;
  &lt;li&gt;虚数，符号：&lt;code&gt;\jmath&lt;/code&gt;，如：$\jmath$&lt;/li&gt;
  &lt;li&gt;数学符号，符号&lt;code&gt;\hat{a}&lt;/code&gt;，如：$\hat{a}$&lt;/li&gt;
  &lt;li&gt;数学符号，符号&lt;code&gt;\check{a}&lt;/code&gt;，如：$\check{a}$&lt;/li&gt;
  &lt;li&gt;数学符号，符号&lt;code&gt;\breve{a}&lt;/code&gt;，如：$\breve{a}$&lt;/li&gt;
  &lt;li&gt;数学符号，符号&lt;code&gt;\tilde{a}&lt;/code&gt;，如：$\tilde{a}$&lt;/li&gt;
  &lt;li&gt;数学符号，符号&lt;code&gt;\bar{a}&lt;/code&gt;，如：$\bar{a}$&lt;/li&gt;
  &lt;li&gt;矢量符号，符号&lt;code&gt;\vec{a}&lt;/code&gt;，如：$\vec{a}$&lt;/li&gt;
  &lt;li&gt;数学符号，符号&lt;code&gt;\acute{a}&lt;/code&gt;，如：$\acute{a}$&lt;/li&gt;
  &lt;li&gt;数学符号，符号&lt;code&gt;\grave{a}&lt;/code&gt;，如：$\grave{a}$&lt;/li&gt;
  &lt;li&gt;数学符号，符号&lt;code&gt;\mathring{a}&lt;/code&gt;，如：$\mathring{a}$&lt;/li&gt;
  &lt;li&gt;一阶导数符号，符号&lt;code&gt;\dot{a}&lt;/code&gt;，如：$\dot{a}$&lt;/li&gt;
  &lt;li&gt;二阶导数符号，符号&lt;code&gt;\ddot{a}&lt;/code&gt;，如：$\ddot{a}$&lt;/li&gt;
  &lt;li&gt;上箭头，符号：&lt;code&gt;\uparrow&lt;/code&gt;，如：$\uparrow$&lt;/li&gt;
  &lt;li&gt;上箭头，符号：&lt;code&gt;\Uparrow&lt;/code&gt;，如：$\Uparrow$&lt;/li&gt;
  &lt;li&gt;下箭头，符号：&lt;code&gt;\downarrow&lt;/code&gt;，如：$\downarrow$&lt;/li&gt;
  &lt;li&gt;下箭头，符号：&lt;code&gt;\Downarrow&lt;/code&gt;，如：$\Downarrow$&lt;/li&gt;
  &lt;li&gt;左箭头，符号：&lt;code&gt;\leftarrow&lt;/code&gt;，如：$\leftarrow$&lt;/li&gt;
  &lt;li&gt;左箭头，符号：&lt;code&gt;\Leftarrow&lt;/code&gt;，如：$\Leftarrow$&lt;/li&gt;
  &lt;li&gt;右箭头，符号：&lt;code&gt;\rightarrow&lt;/code&gt;，如：$\rightarrow$&lt;/li&gt;
  &lt;li&gt;右箭头，符号：&lt;code&gt;\Rightarrow&lt;/code&gt;，如：$\Rightarrow$&lt;/li&gt;
  &lt;li&gt;底端对齐的省略号，符号：&lt;code&gt;\ldots&lt;/code&gt;，如：$1,2,\ldots,n$&lt;/li&gt;
  &lt;li&gt;中线对齐的省略号，符号：&lt;code&gt;\cdots&lt;/code&gt;，如：$x_1^2 + x_2^2 + \cdots + x_n^2$&lt;/li&gt;
  &lt;li&gt;竖直对齐的省略号，符号：&lt;code&gt;\vdots&lt;/code&gt;，如：$\vdots$&lt;/li&gt;
  &lt;li&gt;斜对齐的省略号，符号：&lt;code&gt;\ddots&lt;/code&gt;，如：$\ddots$&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;希腊字母&quot;&gt;希腊字母&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;字母&lt;/th&gt;
      &lt;th&gt;实现&lt;/th&gt;
      &lt;th&gt;字母&lt;/th&gt;
      &lt;th&gt;实现&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;A&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;A&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;α&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\alhpa&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;B&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;B&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;β&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\beta&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Γ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\Gamma&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;γ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\gamma&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Δ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\Delta&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;δ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\delta&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;E&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;E&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;ϵ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\epsilon&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Z&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;Z&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;ζ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\zeta&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;H&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;H&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;η&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\eta&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Θ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\Theta&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;θ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\theta&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;I&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;I&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;ι&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\iota&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;K&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;K&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;κ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\kappa&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Λ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\Lambda&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;λ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\lambda&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;M&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;M&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;μ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\mu&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;N&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;N&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;ν&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\nu&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ξ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\Xi&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;ξ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\xi&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;O&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;O&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;ο&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\omicron&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Π&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\Pi&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;π&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\pi&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;P&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;P&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;ρ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\rho&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Σ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\Sigma&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;σ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\sigma&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;T&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;T&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;τ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\tau&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Υ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\Upsilon&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;υ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\upsilon&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Φ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\Phi&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;ϕ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\phi&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;X&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;X&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;χ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\chi&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ψ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\Psi&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;ψ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\psi&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ω&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\v&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;ω&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\omega&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name></name></author><category term="wiki" /><summary type="html">Markdown数学公式</summary></entry><entry><title type="html">celery</title><link href="https://acemyzoe.github.io/_posts/2020-08-20-celery/" rel="alternate" type="text/html" title="celery" /><published>2020-08-20T00:00:00+08:00</published><updated>2020-08-20T00:00:00+08:00</updated><id>https://acemyzoe.github.io/_posts/celery</id><content type="html" xml:base="https://acemyzoe.github.io/_posts/2020-08-20-celery/">&lt;h1 id=&quot;celery&quot;&gt;Celery&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://www.celerycn.io/&quot;&gt;Celery 中文手册&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Celery 分布式任务队列，可用于处理实时数据以及任务调度。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;选择并且安装一个消息中间件（Broker）&lt;/li&gt;
  &lt;li&gt;安装 Celery 并且创建第一个任务&lt;/li&gt;
  &lt;li&gt;运行职程（Worker）以及调用任务&lt;/li&gt;
  &lt;li&gt;跟踪任务的情况以及返回值&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用 Redis 作为中间人（Broker）必须要安装 Celery 的依赖库&lt;/p&gt;</content><author><name></name></author><category term="python" /><summary type="html">Celery</summary></entry><entry><title type="html">python-QA</title><link href="https://acemyzoe.github.io/_posts/2020-08-18-python-QA/" rel="alternate" type="text/html" title="python-QA" /><published>2020-08-18T00:00:00+08:00</published><updated>2020-08-18T00:00:00+08:00</updated><id>https://acemyzoe.github.io/_posts/python-QA</id><content type="html" xml:base="https://acemyzoe.github.io/_posts/2020-08-18-python-QA/">&lt;h1 id=&quot;python-interview&quot;&gt;python Interview&lt;/h1&gt;

&lt;p&gt;Python基本功和基本原理，重点考察运算符、装饰器、生成器的原理和实现，垃圾回收机制、各种数据类型，以及线程、进程、协程的概念和应用。&lt;/p&gt;

&lt;p&gt;计算机基础，重点考察数据结构（链表、哈希、堆栈、二叉树）和算法分析（时间复杂度分析）&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;这两个参数是什么意思：*args，**kwargs？我们为什么要使用它们？&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;如果我们不确定往一个函数中传入多少参数，或者我们希望以元组（tuple）或者列表（list）的形式传参数的时候，我们可以使用*args（单星号）。如果我们不知道往函数中传递多少个关键词参数或者想传入字典的值作为关键词参数的时候我们可以使用**kwargs（双星号），args、kwargs两个标识符是约定俗成的用法。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;谈一谈Python的装饰器（decorator）&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;装饰器本质上是一个Python函数，它可以让其它函数在不作任何变动的情况下增加额外功能，装饰器的返回值也是一个函数对象。它经常用于有切面需求的场景。比如：插入日志、性能测试、事务处理、缓存、权限校验等。有了装饰器我们就可以抽离出大量的与函数功能无关的雷同代码进行重用。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;简要描述Python的垃圾回收机制（garbage collection）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Python多线程（multi-threading）。这是个好主意吗？&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;说明&lt;strong&gt;os,sys&lt;/strong&gt;模块不同，并列举常用的模块方法？&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;什么是lambda表达式？它有什么好处？&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Python中pass语句的作用是什么？&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Python是如何进行类型转换的？&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Python里面如何拷贝一个对象？&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;__new__&lt;/code&gt;和&lt;code&gt;__init__&lt;/code&gt;的区别。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Python中单下划线和双下划线分别是什么？&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;说一说Python自省。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如何反序迭代一个序列？&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如何用Python来进行查询和替换一个文本字符串？&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用Python实现单例模式。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;重新实现str.strip()，注意不能使用string.*strip()&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;super&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Python的函数参数传递&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;strong&gt;Python&lt;/strong&gt;中&lt;strong&gt;string、tuple、number&lt;/strong&gt;属于不可更改对象，而&lt;strong&gt;list&lt;/strong&gt;和&lt;strong&gt;dict&lt;/strong&gt;属于可修改对象。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;类变量和实例变量&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Python在函数式编程方面的支持。&lt;strong&gt;lambda&lt;/strong&gt;表达式\内建函数：&lt;strong&gt;filter()、reduce()、map()&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;试图访问一个列表的以超出列表成员数作为开始索引的切片将不会导致&lt;strong&gt;IndexError&lt;/strong&gt;，并且仅仅返回一个空&lt;strong&gt;list&lt;/strong&gt;&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;templist = [1,2,3,4,5]
print(temolist[10:])
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;late binding&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;def testfun():
    temp = [lambda x: i*x for i in range(4)]
    return temp
  
for lb in testfun():
    print(lb(2))
  
def testfun():
    temp = [lambda x,i=i : i*x for i in range(4)]
    return temp
  
for lb in testfun():
    print(lb(2))
      
def testfun():
    return (lambda x: i*x for i in range(4))
  
for lb in testfun():
    print(lb(2))
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;笔试试题“一个芬兰人进了一个房间，房间有一排椅子，椅子上有一些人坐着，还剩一些空位，他要选择一个位子坐下，这个位子要尽可能远离已经坐着的人，请给出算法。请自行定义数据结构和输入输出。”&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;import unittest
# 分析空位情况：1,首位有人；2，尾位有人；3中间占人
# 输入：空位列表 输出：结果位置和最大距离
# 1.输入：list=[1,0,0,0] 输出：[3],3
# 2.输入：list=[0,0,0,1] 输出：[0],3
# 3.输入：list=[1,0,0,0,1,0,1] 输出：[2],2
# 4.输入：list=[1,0,0,1,0] 输出:[1,2,4],1
  
class Testlist(unittest.TestCase):
  
    def test_case1(self):
        list=[1,0,0,0]
        self.assertEqual(solution(list),([3], 3))
      
    def test_case2(self):
        list=[0,0,0,1]
        self.assertEqual(solution(list), ([0], 3))
  
    def test_case3(self):
        list=[1,0,0,0,1,0,1]
        self.assertEqual(solution(list), ([2], 2))
  
    def test_case4(self):
        list=[1,0,0,1,0]
        self.assertEqual(solution(list), ([1,2,4], 1))
  
def solution(seats):
    &quot;&quot;&quot;
    seats: List[int]
    return: ans[int],int
    &quot;&quot;&quot;
    persons = [p for p, seat in enumerate(seats) if seat == 1]
    nullseat = [p for p, seat in enumerate(seats) if seat == 0]
    maxdict = max(persons[0], 
              len(seats)-1-persons[-1], 
              max([(persons[r]-persons[r-1])//2 for r in range(1, len(persons))]+[0]))
    ans=[]
    for i in nullseat:
        if min([abs(i-j) for j in persons])==maxdict:
           ans.append(i) 
    return ans,maxdict
  
if __name__ == '__main__':
    unittest.main()
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="python" /><summary type="html">python Interview</summary></entry><entry><title type="html">苏菲的世界</title><link href="https://acemyzoe.github.io/_posts/2020-08-15-%E8%8B%8F%E8%8F%B2%E7%9A%84%E4%B8%96%E7%95%8C-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" rel="alternate" type="text/html" title="苏菲的世界" /><published>2020-08-15T00:00:00+08:00</published><updated>2020-08-15T00:00:00+08:00</updated><id>https://acemyzoe.github.io/_posts/%E3%80%8A%E8%8B%8F%E8%8F%B2%E7%9A%84%E4%B8%96%E7%95%8C%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0</id><content type="html" xml:base="https://acemyzoe.github.io/_posts/2020-08-15-%E8%8B%8F%E8%8F%B2%E7%9A%84%E4%B8%96%E7%95%8C-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">&lt;h1 id=&quot;伊甸园&quot;&gt;伊甸园&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;我是谁？&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;唯有清晰地意识到有一天她终将死去，她才能体会活在世上是多么美好。&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;blockquote&gt;
      &lt;p&gt;“小小玛丽来到人间，惊鸿一瞥魂归高天。”&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;世界从何而来？&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;在某一时刻，事物必然曾经从无到有。然而，这可能吗？这不就和世界一直存在的看法一样不可思议吗？&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;魔术师的礼帽&quot;&gt;魔术师的礼帽&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;要成为一个优秀的哲学家只有一个条件：要有好奇心……&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;探讨哲学最好的方式就是问一些哲学性的问题，如：这世界是如何创造出来的?其背后是否有某种意志或意义?人死后还有生命吗?我们如何能够解答这些问题呢?最重要的是，我们应该如何生活?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;生命是一种很庞大的、神秘的存在。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;神话&quot;&gt;神话&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;人们总是想为大自然的变迁寻求解释。这就是他们何以在科学还没有产生之前会编造出那些神话故事的原因。&lt;/p&gt;

  &lt;p&gt;从神话的思考模式发展到以经验与理性为基础的思考模式。&lt;/p&gt;

  &lt;p&gt;早期希腊哲学家的目标乃是为大自然的变化寻找自然的——而非超自然的——解释。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;自然派哲学家&quot;&gt;自然派哲学家&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;万事万物是否由一种基本的物质组成？&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;最早的希腊哲学家有时被称为“自然派哲学家”，因为他们关切的主题是大自然与它的循环与变化。&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;blockquote&gt;
      &lt;p&gt;没有任何事物会来自虚无这三位米雷特斯的哲学家都相信，宇宙间有一种基本物质是所有事物的源头。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;帕梅尼德斯：
    &lt;ul&gt;
      &lt;li&gt;“没有任何事物会来自虚无。”没有任何事物会改变。&lt;/li&gt;
      &lt;li&gt;“感官幻象”-“理性主义”&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;赫拉克利特斯：
    &lt;ul&gt;
      &lt;li&gt;“所有事物都是流动的。”因此我们不可能“在同一条河流中涉水两次”。&lt;/li&gt;
      &lt;li&gt;世间的事物是相对的。&lt;/li&gt;
      &lt;li&gt;普遍的理性&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;恩培窦可里斯：
    &lt;ul&gt;
      &lt;li&gt;四种基本元素：土、气、火、水&lt;/li&gt;
      &lt;li&gt;两种力量：爱使事物聚合，而恨则使他们分散。&lt;/li&gt;
      &lt;li&gt;将物质与力量分开。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;安纳塞格拉斯：
    &lt;ul&gt;
      &lt;li&gt;大自然是由无数肉眼看不见的微小粒子所组成，而所有事物都可以被分割成更小的部分。然而，即使是在最小的部分中也有其他每种事物的成分存在。&lt;/li&gt;
      &lt;li&gt;整体存在于每一个微小的部分中。&lt;/li&gt;
      &lt;li&gt;天文学：太阳的本质、月亮的光、日蚀。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;哲学不是一般人能够学到的，但也许我们可以学习如何以哲学的方式思考。&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name></name></author><category term="阅读" /><summary type="html">伊甸园</summary></entry></feed>