<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="https://acemyzoe.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://acemyzoe.github.io/" rel="alternate" type="text/html" /><updated>2020-11-04T18:10:10+08:00</updated><id>https://acemyzoe.github.io/feed.xml</id><title type="html">Acemyzoe</title><subtitle>人类世界&lt;br/&gt;
真是&lt;br/&gt;
太有趣了&lt;br/&gt;
QAQ&lt;br/&gt;
&lt;a href=&quot;mailto:acemyzoe@outlook.com&quot;&gt;
  &lt;i class=&quot;fas fa-envelope&quot;&gt;&lt;/i&gt;
&lt;/a&gt;
&lt;a href=&quot;https://github.com/acemyzoe&quot;&gt;
  &lt;i class=&quot;fab fa-github&quot;&gt;&lt;/i&gt;
&lt;/a&gt;
&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=100% height=52 src=&quot;//music.163.com/outchain/player?type=2&amp;id=486806&amp;auto=1&amp;height=32&quot;&gt;&lt;/iframe&gt;
</subtitle><entry><title type="html">毛选阅读摘录</title><link href="https://acemyzoe.github.io/_posts/2020-10-30-%E6%AF%9B%E9%80%89%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" rel="alternate" type="text/html" title="毛选阅读摘录" /><published>2020-10-30T00:00:00+08:00</published><updated>2020-10-30T00:00:00+08:00</updated><id>https://acemyzoe.github.io/_posts/%E6%AF%9B%E9%80%89%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0</id><content type="html" xml:base="https://acemyzoe.github.io/_posts/2020-10-30-%E6%AF%9B%E9%80%89%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">&lt;blockquote&gt;
  &lt;p&gt;《毛泽东选集》第五卷是一九四九年九月到一九五七年的重要著作。毛泽东同志关于在生产资料所有制的社会主义改 造基本完成以后无产阶级和资产阶级、社会主义道路和资本主义道路的斗争还长期存在的科学论断，关于正确区分和处理社会主义社会中敌我矛盾和人民内部矛盾这 两类不同性质的矛盾的学说，关于无产阶级专政下继续革命的伟大理论，关于社会主义建设总路线的基本思想，就是在这卷著作中首次提出的。以后，特别是在无产 阶级文化大革命中，毛泽东同志根据革命实践经验，不断地充实和发展了这些光辉思想。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;三年以来，在人民解放战争和人民革命中牺牲的人民英雄们永垂不朽!&lt;/p&gt;

  &lt;p&gt;三十年以来，在人民解放战争和人民革命中牺牲的人民英雄们永垂不朽!&lt;/p&gt;

  &lt;p&gt;由此上溯到一千八百四十年，从那时起，为了反对内外敌人，争取民族独立和人民自由幸福，在历次斗争中牺牲的人民英雄们永垂不朽 !&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name></name></author><category term="阅读" /><summary type="html">《毛泽东选集》第五卷是一九四九年九月到一九五七年的重要著作。毛泽东同志关于在生产资料所有制的社会主义改 造基本完成以后无产阶级和资产阶级、社会主义道路和资本主义道路的斗争还长期存在的科学论断，关于正确区分和处理社会主义社会中敌我矛盾和人民内部矛盾这 两类不同性质的矛盾的学说，关于无产阶级专政下继续革命的伟大理论，关于社会主义建设总路线的基本思想，就是在这卷著作中首次提出的。以后，特别是在无产 阶级文化大革命中，毛泽东同志根据革命实践经验，不断地充实和发展了这些光辉思想。</summary></entry><entry><title type="html">Java调用Python</title><link href="https://acemyzoe.github.io/_posts/2020-10-28-Java%E8%B0%83%E7%94%A8Python/" rel="alternate" type="text/html" title="Java调用Python" /><published>2020-10-28T00:00:00+08:00</published><updated>2020-10-28T00:00:00+08:00</updated><id>https://acemyzoe.github.io/_posts/Java%E8%B0%83%E7%94%A8Python</id><content type="html" xml:base="https://acemyzoe.github.io/_posts/2020-10-28-Java%E8%B0%83%E7%94%A8Python/"></content><author><name></name></author><category term="python" /><summary type="html"></summary></entry><entry><title type="html">scikit-learn</title><link href="https://acemyzoe.github.io/_posts/2020-10-28-scikit-learn/" rel="alternate" type="text/html" title="scikit-learn" /><published>2020-10-28T00:00:00+08:00</published><updated>2020-10-28T00:00:00+08:00</updated><id>https://acemyzoe.github.io/_posts/scikit-learn</id><content type="html" xml:base="https://acemyzoe.github.io/_posts/2020-10-28-scikit-learn/">&lt;h1 id=&quot;scikit-learn&quot;&gt;scikit-learn&lt;/h1&gt;

&lt;h2 id=&quot;神经网络mlp&quot;&gt;神经网络MLP&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://scikit-learn.org/stable/modules/classes.html#module-sklearn.neural_network&quot;&gt;&lt;code&gt;sklearn.neural_network&lt;/code&gt;&lt;/a&gt;.MLPRegressor&lt;a href=&quot;https://scikit-learn.org/stable/modules/generated/sklearn.neural_network.MLPRegressor.html#sklearn-neural-network-mlpregressor&quot;&gt;¶&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><category term="python" /><summary type="html">scikit-learn</summary></entry><entry><title type="html">损失函数&amp;amp;评价指标</title><link href="https://acemyzoe.github.io/_posts/2020-10-20-%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0&%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/" rel="alternate" type="text/html" title="损失函数&amp;评价指标" /><published>2020-10-20T00:00:00+08:00</published><updated>2020-10-20T00:00:00+08:00</updated><id>https://acemyzoe.github.io/_posts/%20%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0&amp;%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87</id><content type="html" xml:base="https://acemyzoe.github.io/_posts/2020-10-20-%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0&amp;%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/">&lt;h1 id=&quot;损失函数&quot;&gt;损失函数&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;损失函数&lt;/strong&gt;用来评价模型的&lt;strong&gt;预测值&lt;/strong&gt;和&lt;strong&gt;真实值&lt;/strong&gt;不一样的程度，损失函数越好，通常模型的性能越好。&lt;/p&gt;

&lt;h2 id=&quot;回归问题&quot;&gt;回归问题&lt;/h2&gt;

&lt;h3 id=&quot;平均损失函数最小二乘法&quot;&gt;平均损失函数（最小二乘法）&lt;/h3&gt;

&lt;p&gt;回归问题中常用的损失函数，在线性回归中，可以通过极大似然估计（MLE）推导。计算的是预测值与真实值之间距离的平方和。实际更常用的是&lt;strong&gt;均方误差（MSE）&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;平均值绝对误差l1损失mae&quot;&gt;平均值绝对误差（L1损失）——MAE&lt;/h3&gt;

&lt;p&gt;MAE是目标值和预测值之差的绝对值之和，可以用来衡量预测值和真实值的距离。&lt;/p&gt;

&lt;h3 id=&quot;mael1损失-vs-msel2损失&quot;&gt;MAE（L1损失） VS MSE（L2损失）&lt;/h3&gt;

&lt;p&gt;MSE计算简便，但MAE对异常点有更好的鲁棒性:当数据中存在异常点时，用RMSE计算损失的模型以牺牲了其他样本的误差为代价，朝着减小异常点误差的方向更新，会降低模型的整体性能。&lt;/p&gt;

&lt;p&gt;NN中MAE更新梯度始终相同，而MSE则不同： MSE损失的梯度随损失增大而增大，而损失趋于0时则会减小。&lt;/p&gt;

&lt;p&gt;使用MAE训练神经网络最大的一个问题就是不变的大梯度，这可能导致在使用梯度下降快要结束时，错过了最小点，为了解决这个缺陷，我们可以使用变化的学习率，在损失接近最小值时降低学习率。而对于MSE，梯度会随着损失的减小而减小，这使得在训练结束时，使用MSE模型的结果会更精确。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Loss选择建议：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;MSE：&lt;/strong&gt; 如果异常点代表在商业中很重要的异常情况，并且需要被检测出来&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;MAE：&lt;/strong&gt; 如果只把异常值当作受损数据&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;huber损失&quot;&gt;Huber损失&lt;/h3&gt;

&lt;p&gt;Huber损失是绝对误差，只是在误差很小时，就变为平方误差。&lt;/p&gt;

&lt;p&gt;当δ&lt;em&gt;很大时，等价为&lt;strong&gt;MSE&lt;/strong&gt;曲线，当&lt;/em&gt;δ很小时，等价为&lt;strong&gt;MAE&lt;/strong&gt;曲线。
\(L_\delta(y,f(x))=\{ {
{1\over2}(y-f(x))^2 \qquad for|y-f(x)|&amp;lt;\delta
\atop 
{\delta|y-f(x)|-{1\over2}\delta^2 \qquad otherwise}
}\)&lt;/p&gt;

&lt;h3 id=&quot;logloss&quot;&gt;LogLoss&lt;/h3&gt;

&lt;p&gt;对数损失(Logarithmic Loss), 即对数似然损失(Log-likelihood Loss), 也称交叉熵损失(cross-entropy Loss)。&lt;/p&gt;

&lt;p&gt;对数损失通过惩罚错误的分类,实现对分类器的准确度(Accuracy)的量化。 最小化对数损失基本等价于最大化分类器的准确度。&lt;/p&gt;

&lt;p&gt;当使用sigmoid作为激活函数的时候，常用&lt;strong&gt;交叉熵损失函数&lt;/strong&gt;而不用&lt;strong&gt;均方误差损失函数&lt;/strong&gt;，因为它可以&lt;strong&gt;完美解决平方损失函数权重更新过慢&lt;/strong&gt;的问题，具有“误差大的时候，权重更新快；误差小的时候，权重更新慢”的良好性质。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;#!/usr/bin/env python
# -*- coding: utf8 -*-
# y_true: list, the true labels of input instances 
# y_pred: list, the probability when the predicted label of input instances equals to 1
def logloss(y_true, y_pred, eps=1e-15):
    import numpy as np

    # Prepare numpy array data
    y_true = np.array(y_true)
    y_pred = np.array(y_pred)
    assert (len(y_true) and len(y_true) == len(y_pred))

    # Clip y_pred between eps and 1-eps
    p = np.clip(y_pred, eps, 1-eps)
    loss = np.sum(- y_true * np.log(p) - (1 - y_true) * np.log(1-p))

    return loss / len(y_true)

def unitest():
    y_true = [0, 0, 1, 1]
    y_pred = [0.1, 0.2, 0.7, 0.99]

    print (&quot;Use self-defined logloss() in binary classification, the result is {}&quot;.format(logloss(y_true, y_pred)))

    from sklearn.metrics import log_loss
    print (&quot;Use log_loss() in scikit-learn, the result is {} &quot;.format(log_loss(y_true, y_pred)))

if __name__ == '__main__':
    unitest()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;exponential-loss&quot;&gt;exponential loss&lt;/h3&gt;

&lt;p&gt;指数损失函数，对离群点、噪声非常敏感。经常用在AdaBoost算法中。&lt;/p&gt;

&lt;h1 id=&quot;评价指标&quot;&gt;评价指标&lt;/h1&gt;

&lt;p&gt;如何评估机器学习算法模型是任何项目中一个非常重要的环节。分类问题一般会选择准确率（Accuracy）或者AUC作为metric，回归问题使用MSE。上述损失函数大部分可以直接作为评价指标来使用。&lt;/p&gt;

&lt;h2 id=&quot;回归问题-1&quot;&gt;回归问题&lt;/h2&gt;

&lt;h3 id=&quot;mse&quot;&gt;MSE&lt;/h3&gt;

&lt;p&gt;均方误差 (Mean Square Error)
\(MSE={1\over n}{\sum^{n}_{i=1}(\hat{y_i} -{y_i})^2}\)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;范围[0,+∞)，当预测值与真实值完全吻合时等于0，即完美模型；误差越大，该值越大。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;rmse&quot;&gt;RMSE&lt;/h3&gt;

&lt;p&gt;均方根误差 (Root Mean Square Error)
\(RMSE=\sqrt {MSE} = \sqrt {\frac{1}{n} \sum_{i=1}^{n} (\hat{y}_i - y_i)^2}\)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;数量级上比较直观，比如RMSE=10，可以认为回归效果相比真实值平均相差10。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;mae&quot;&gt;MAE&lt;/h3&gt;

&lt;p&gt;平均绝对误差(Mean Absolute Error)
\(MAE=\frac{1}{n} \sum_{i=1}^{n} |\hat{y}_i - y_i|\)&lt;/p&gt;

&lt;h3 id=&quot;mape&quot;&gt;MAPE&lt;/h3&gt;

&lt;p&gt;平方绝对百分比误差 (Mean Absolute Percentage Error)
\(MAPE=\frac{100\%}{n}\sum_{i=1}^n |\frac{ \hat{y}_i - y_i }{ y_i }|\)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;当真实值有数据等于0时，存在分母0除问题，该公式不可用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;smape&quot;&gt;SMAPE&lt;/h3&gt;

&lt;p&gt;对称平均绝对百分比误差 (Symmetric Mean Absolute Percentage Error)
\(SMAPE=\frac{100\%}{n}\sum_{i=1}^n \frac{ |\hat{y}_i - y_i| }{ (|\hat{y}_i| + |y_i|)/2 }\)&lt;/p&gt;

&lt;h3 id=&quot;r-squared&quot;&gt;R Squared&lt;/h3&gt;

&lt;p&gt;决定系数 (coefficient of determination)
\(R^2=1-{\frac {\sum _i (\hat y_i-y_i)^2}{\sum _i (\overline y-y_i)^2}}\)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;分母代表baseline（平均值）的误差，分子代表模型的预测结果产生的误差；&lt;/li&gt;
    &lt;li&gt;预测结果越大越好，R为1说明完美拟合， 为0说明和baseline一致；&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;分类问题&quot;&gt;分类问题&lt;/h2&gt;

&lt;h3 id=&quot;confusion-matrix&quot;&gt;Confusion Matrix&lt;/h3&gt;

&lt;p&gt;混淆矩阵，后续多个指标的基础。&lt;/p&gt;

&lt;p&gt;eg. 二类混淆矩阵(训练目的：减少FP、FN)&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;预测正例&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;预测反例&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;真实正例&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;TP 真正例&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;FN 假反例&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;真实反例&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;FP 假反例&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;TN 真反例&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;accuracy&quot;&gt;Accuracy&lt;/h3&gt;

&lt;p&gt;准确率：当样本类别均衡时，Accuracy是一个很好的指标。但在样本不平衡的情况下，产生效果较差。
\(Acc=\frac {TP+TN}{TP+TN+FP+FN}\)&lt;/p&gt;

&lt;h3 id=&quot;precision&quot;&gt;Precision&lt;/h3&gt;

&lt;p&gt;精准率：预测为正例的样本中有多少实际为正。
\(P=\frac {TP}{TP+FP}\)&lt;/p&gt;

&lt;h3 id=&quot;recall&quot;&gt;Recall&lt;/h3&gt;

&lt;p&gt;召回率：实际为正例的样本有多少被预测为正。
\(R=\frac {TP}{TP+FN}\)&lt;/p&gt;

&lt;h3 id=&quot;p-r曲线&quot;&gt;P-R曲线&lt;/h3&gt;

&lt;p&gt;通过选择不同的阈值，得到Recall和Precision，以Recall为横坐标，Precision为纵坐标得到的曲线图。&lt;/p&gt;

&lt;h3 id=&quot;加权调和平均调和平均&quot;&gt;加权调和平均&amp;amp;调和平均&lt;/h3&gt;

&lt;p&gt;beta&amp;gt;1时召回率（Recall）影响更大。&lt;/p&gt;

&lt;p&gt;beta&amp;lt;1时，精确率（Precision）影响更大。
\(F_\beta=\frac{(1+\beta^2)PR}{\beta^2P+R},(\beta=1时)F_1=\frac {2PR}{P+R}\)&lt;/p&gt;

&lt;h3 id=&quot;roc-auc&quot;&gt;ROC-AUC&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Area Under Curve(AUC)&lt;/strong&gt; 是&lt;strong&gt;二分类&lt;/strong&gt;问题中使用非常广泛的一个评价指标。&lt;strong&gt;AUC的本质是，任取一个正样本和负样本，模型输出正样本的值大于负样本值的概率&lt;/strong&gt;。构成AUC的两个基本指标是假正例率和真正例率。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;横轴-假正例率：&lt;/strong&gt; 实际为负的样本多少被预测为正。FPR。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;纵轴-真正例率：&lt;/strong&gt; 实际为正的样本多少被预测为正。TPR。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;TPR和FPR的范围均是[0,1]，通过选择不同的阈值得到TPR和FPR，然后绘制ROC曲线。ROC曲线下的面积为AUC值。&lt;/p&gt;

&lt;h2 id=&quot;代码&quot;&gt;代码&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# coding=utf-8
import numpy as np
from sklearn import metrics
y_true=np.array([1.1,3.3,5.5,7.7])
y_pred=np.array([1.0,3.0,5.0,7.0])

# MSE
def MSE(true, pred):
    return np.sum((true - pred)**2)
mse=metrics.mean_squared_error(y_true,y_pred)
# RMSE
rmse=np.sqrt(mse)
# MAE
def mae(true, pred):
    return np.sum(np.abs(true - pred))
mae=metrics.mean_absolute_error(y_true,y_pred)
# MAPE
mape=np.mean(np.abs(y_pred-y_true)/y_true)*100
#SMPAE
smape=np.mean(2*np.abs(y_pred-y_true)/(np.abs(y_pred)+np.abs(y_true)))*100
# R Squared
RS=metrics.r2_score(y_true,y_pred)
# huber loss
def huber(true, pred, delta):
    loss = np.where(np.abs(true-pred) &amp;lt; delta , 0.5*((true-pred)**2), delta*np.abs(true - pred) - 0.5*(delta**2))
    return np.sum(loss)

y_trues = [1,1,1,1,0,0,1,1,1,0,0]
y_preds = [1,1,1,0,1,1,0,1,1,1,0] 

# ACC准确率
acc=metrics.accuracy_score(y_trues,y_preds)
# Precision精准率
P=metrics.precision_score(y_trues,y_preds)
# Recall召回率
R=metrics.recall_score(y_trues,y_preds)
# F
F=metrics.fbeta_score(y_trues,y_preds,beta=1)
&lt;/code&gt;&lt;/pre&gt;</content><author><name></name></author><category term="ML" /><summary type="html">损失函数</summary></entry><entry><title type="html">Markdown数学公式</title><link href="https://acemyzoe.github.io/_posts/2020-10-18-markdown%E5%85%AC%E5%BC%8F/" rel="alternate" type="text/html" title="Markdown数学公式" /><published>2020-10-18T00:00:00+08:00</published><updated>2020-10-18T00:00:00+08:00</updated><id>https://acemyzoe.github.io/_posts/%20markdown%E5%85%AC%E5%BC%8F</id><content type="html" xml:base="https://acemyzoe.github.io/_posts/2020-10-18-markdown%E5%85%AC%E5%BC%8F/">&lt;h1 id=&quot;markdown数学公式&quot;&gt;Markdown数学公式&lt;/h1&gt;

&lt;h2 id=&quot;上标下标与组合&quot;&gt;上标、下标与组合&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;上标符号，符号：&lt;code&gt;^&lt;/code&gt;，如：$x^4$&lt;/li&gt;
  &lt;li&gt;下标符号，符号：&lt;code&gt;_&lt;/code&gt;，如：$ x_1 $&lt;/li&gt;
  &lt;li&gt;组合符号，符号：&lt;code&gt;{}&lt;/code&gt;，如：${16}&lt;em&gt;{8}O{2+}&lt;/em&gt;{2}$&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;汉字字体与格式&quot;&gt;汉字、字体与格式&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;汉字形式，符号：&lt;code&gt;\mbox{}&lt;/code&gt;，如：$V_{\mbox{初始}}$&lt;/li&gt;
  &lt;li&gt;字体控制，符号：&lt;code&gt;\displaystyle&lt;/code&gt;，如：$\displaystyle \frac{x+y}{y+z}$&lt;/li&gt;
  &lt;li&gt;下划线符号，符号：&lt;code&gt;\underline&lt;/code&gt;，如：$\underline{x+y}$&lt;/li&gt;
  &lt;li&gt;标签，符号&lt;code&gt;\tag{数字}&lt;/code&gt;，如：$\tag{11}$&lt;/li&gt;
  &lt;li&gt;上大括号，符号：&lt;code&gt;\overbrace{算式}&lt;/code&gt;，如：$\overbrace{a+b+c+d}^{2.0}$&lt;/li&gt;
  &lt;li&gt;下大括号，符号：&lt;code&gt;\underbrace{算式}&lt;/code&gt;，如：$a+\underbrace{b+c}_{1.0}+d$&lt;/li&gt;
  &lt;li&gt;上位符号，符号：&lt;code&gt;\stacrel{上位符号}{基位符号}&lt;/code&gt;，如：$\vec{x}\stackrel{\mathrm{def}}{=}{x_1,\dots,x_n}$&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;占位符&quot;&gt;占位符&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;两个quad空格，符号：&lt;code&gt;\qquad&lt;/code&gt;，如：$x \qquad y$&lt;/li&gt;
  &lt;li&gt;quad空格，符号：&lt;code&gt;\quad&lt;/code&gt;，如：$x \quad y$&lt;/li&gt;
  &lt;li&gt;大空格，符号&lt;code&gt;\&lt;/code&gt;，如：$x \  y$&lt;/li&gt;
  &lt;li&gt;中空格，符号&lt;code&gt;\:&lt;/code&gt;，如：$x : y$&lt;/li&gt;
  &lt;li&gt;小空格，符号&lt;code&gt;\,&lt;/code&gt;，如：$x , y$&lt;/li&gt;
  &lt;li&gt;没有空格，符号``，如：$xy$&lt;/li&gt;
  &lt;li&gt;紧贴，符号&lt;code&gt;\!&lt;/code&gt;，如：$x ! y$&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;定界符与组合&quot;&gt;定界符与组合&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;括号，符号：&lt;code&gt;（）\big(\big) \Big(\Big) \bigg(\bigg) \Bigg(\Bigg)&lt;/code&gt;，如：$（）\big(\big) \Big(\Big) \bigg(\bigg) \Bigg(\Bigg)$&lt;/li&gt;
  &lt;li&gt;中括号，符号：&lt;code&gt;[]&lt;/code&gt;，如：$[x+y]$&lt;/li&gt;
  &lt;li&gt;大括号，符号：&lt;code&gt;\{ \}&lt;/code&gt;，如：${x+y}$&lt;/li&gt;
  &lt;li&gt;自适应括号，符号：&lt;code&gt;\left \right&lt;/code&gt;，如：$\left(x\right)$，$\left(x{yz}\right)$&lt;/li&gt;
  &lt;li&gt;组合公式，符号：&lt;code&gt;{上位公式 \choose 下位公式}&lt;/code&gt;，如：${n+1 \choose k}={n \choose k}+{n \choose k-1}$&lt;/li&gt;
  &lt;li&gt;组合公式，符号：&lt;code&gt;{上位公式 \atop 下位公式}&lt;/code&gt;，如：$\sum_{k_0,k_1,\ldots&amp;gt;0 \atop k_0+k_1+\cdots=n}A_{k_0}A_{k_1}\cdots$&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;四则运算&quot;&gt;四则运算&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;加法运算，符号：&lt;code&gt;+&lt;/code&gt;，如：$x+y=z$&lt;/li&gt;
  &lt;li&gt;减法运算，符号：&lt;code&gt;-&lt;/code&gt;，如：$x-y=z$&lt;/li&gt;
  &lt;li&gt;加减运算，符号：&lt;code&gt;\pm&lt;/code&gt;，如：$x \pm y=z$&lt;/li&gt;
  &lt;li&gt;减甲运算，符号：&lt;code&gt;\mp&lt;/code&gt;，如：$x \mp y=z$&lt;/li&gt;
  &lt;li&gt;乘法运算，符号：&lt;code&gt;\times&lt;/code&gt;，如：$x \times y=z$&lt;/li&gt;
  &lt;li&gt;点乘运算，符号：&lt;code&gt;\cdot&lt;/code&gt;，如：$x \cdot y=z$&lt;/li&gt;
  &lt;li&gt;星乘运算，符号：&lt;code&gt;\ast&lt;/code&gt;，如：$x \ast y=z$&lt;/li&gt;
  &lt;li&gt;除法运算，符号：&lt;code&gt;\div&lt;/code&gt;，如：$x \div y=z$&lt;/li&gt;
  &lt;li&gt;斜法运算，符号：&lt;code&gt;/&lt;/code&gt;，如：$x/y=z$&lt;/li&gt;
  &lt;li&gt;分式表示，符号：&lt;code&gt;\frac{分子}{分母}&lt;/code&gt;，如：$\frac{x+y}{y+z}$&lt;/li&gt;
  &lt;li&gt;分式表示，符号：&lt;code&gt;{分子} \voer {分母}&lt;/code&gt;，如：${x+y} \over {y+z}$&lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;绝对值表示，符号：&lt;code&gt;||&lt;/code&gt;，如：$&lt;/td&gt;
          &lt;td&gt;x+y&lt;/td&gt;
          &lt;td&gt;$&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;高级运算&quot;&gt;高级运算&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;平均数运算，符号：&lt;code&gt;\overline{算式}&lt;/code&gt;，如：$\overline{xyz}$&lt;/li&gt;
  &lt;li&gt;开二次方运算，符号：&lt;code&gt;\sqrt&lt;/code&gt;，如：$\sqrt x$&lt;/li&gt;
  &lt;li&gt;开方运算，符号：&lt;code&gt;\sqrt[开方数]{被开方数}&lt;/code&gt;，如：$\sqrt[3]{x+y}$&lt;/li&gt;
  &lt;li&gt;对数运算，符号：&lt;code&gt;\log&lt;/code&gt;，如：$\log(x)$&lt;/li&gt;
  &lt;li&gt;极限运算，符号：&lt;code&gt;\lim&lt;/code&gt;，如：$\lim^{x \to \infty}_{y \to 0}{\frac{x}{y}}$&lt;/li&gt;
  &lt;li&gt;极限运算，符号：&lt;code&gt;\displaystyle \lim&lt;/code&gt;，如：$\displaystyle \lim^{x \to \infty}_{y \to 0}{\frac{x}{y}}$&lt;/li&gt;
  &lt;li&gt;求和运算，符号：&lt;code&gt;\sum&lt;/code&gt;，如：$\sum^{x \to \infty}_{y \to 0}{\frac{x}{y}}$&lt;/li&gt;
  &lt;li&gt;求和运算，符号：&lt;code&gt;\displaystyle \sum&lt;/code&gt;，如：$\displaystyle \sum^{x \to \infty}_{y \to 0}{\frac{x}{y}}$&lt;/li&gt;
  &lt;li&gt;积分运算，符号：&lt;code&gt;\int&lt;/code&gt;，如：$\int^{\infty}_{0}{xdx}$&lt;/li&gt;
  &lt;li&gt;积分运算，符号：&lt;code&gt;\displaystyle \int&lt;/code&gt;，如：$\displaystyle \int^{\infty}_{0}{xdx}$&lt;/li&gt;
  &lt;li&gt;微分运算，符号：&lt;code&gt;\partial&lt;/code&gt;，如：$\frac{\partial x}{\partial y}$&lt;/li&gt;
  &lt;li&gt;矩阵表示，符号：&lt;code&gt;\begin{matrix} \end{matrix}&lt;/code&gt;，如：$\left[ \begin{matrix} 1 &amp;amp;2 &amp;amp;\cdots &amp;amp;4 &amp;amp;5 &amp;amp;6 &amp;amp;\cdots &amp;amp;8\vdots &amp;amp;\vdots &amp;amp;\ddots &amp;amp;\vdots&amp;amp;13 &amp;amp;14 &amp;amp;\cdots &amp;amp;16\end{matrix} \right]$&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;逻辑运算&quot;&gt;逻辑运算&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;等于运算，符号：&lt;code&gt;=&lt;/code&gt;，如：$x+y=z$&lt;/li&gt;
  &lt;li&gt;大于运算，符号：&lt;code&gt;&amp;gt;&lt;/code&gt;，如：$x+y&amp;gt;z$&lt;/li&gt;
  &lt;li&gt;小于运算，符号：&lt;code&gt;&amp;lt;&lt;/code&gt;，如：$x+y&amp;lt;z$&lt;/li&gt;
  &lt;li&gt;大于等于运算，符号：&lt;code&gt;\geq&lt;/code&gt;，如：$x+y \geq z$&lt;/li&gt;
  &lt;li&gt;小于等于运算，符号：&lt;code&gt;\leq&lt;/code&gt;，如：$x+y \leq z$&lt;/li&gt;
  &lt;li&gt;不等于运算，符号：&lt;code&gt;\neq&lt;/code&gt;，如：$x+y \neq z$&lt;/li&gt;
  &lt;li&gt;不大于等于运算，符号：&lt;code&gt;\ngeq&lt;/code&gt;，如：$x+y \ngeq z$&lt;/li&gt;
  &lt;li&gt;不大于等于运算，符号：&lt;code&gt;\not\geq&lt;/code&gt;，如：$x+y \not\geq z$&lt;/li&gt;
  &lt;li&gt;不小于等于运算，符号：&lt;code&gt;\nleq&lt;/code&gt;，如：$x+y \nleq z$&lt;/li&gt;
  &lt;li&gt;不小于等于运算，符号：&lt;code&gt;\not\leq&lt;/code&gt;，如：$x+y \not\leq z$&lt;/li&gt;
  &lt;li&gt;约等于运算，符号：&lt;code&gt;\approx&lt;/code&gt;，如：$x+y \approx z$&lt;/li&gt;
  &lt;li&gt;恒定等于运算，符号：&lt;code&gt;\equiv&lt;/code&gt;，如：$x+y \equiv z$&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;集合运算&quot;&gt;集合运算&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;属于运算，符号：&lt;code&gt;\in&lt;/code&gt;，如：$x \in y$&lt;/li&gt;
  &lt;li&gt;不属于运算，符号：&lt;code&gt;\notin&lt;/code&gt;，如：$x \notin y$&lt;/li&gt;
  &lt;li&gt;不属于运算，符号：&lt;code&gt;\not\in&lt;/code&gt;，如：$x \not\in y$&lt;/li&gt;
  &lt;li&gt;子集运算，符号：&lt;code&gt;\subset&lt;/code&gt;，如：$x \subset y$&lt;/li&gt;
  &lt;li&gt;子集运算，符号：&lt;code&gt;\supset&lt;/code&gt;，如：$x \supset y$&lt;/li&gt;
  &lt;li&gt;真子集运算，符号：&lt;code&gt;\subseteq&lt;/code&gt;，如：$x \subseteq y$&lt;/li&gt;
  &lt;li&gt;非真子集运算，符号：&lt;code&gt;\subsetneq&lt;/code&gt;，如：$x \subsetneq y$&lt;/li&gt;
  &lt;li&gt;真子集运算，符号：&lt;code&gt;\supseteq&lt;/code&gt;，如：$x \supseteq y$&lt;/li&gt;
  &lt;li&gt;非真子集运算，符号：&lt;code&gt;\supsetneq&lt;/code&gt;，如：$x \supsetneq y$&lt;/li&gt;
  &lt;li&gt;非子集运算，符号：&lt;code&gt;\not\subset&lt;/code&gt;，如：$x \not\subset y$&lt;/li&gt;
  &lt;li&gt;非子集运算，符号：&lt;code&gt;\not\supset&lt;/code&gt;，如：$x \not\supset y$&lt;/li&gt;
  &lt;li&gt;并集运算，符号：&lt;code&gt;\cup&lt;/code&gt;，如：$x \cup y$&lt;/li&gt;
  &lt;li&gt;交集运算，符号：&lt;code&gt;\cap&lt;/code&gt;，如：$x \cap y$&lt;/li&gt;
  &lt;li&gt;差集运算，符号：&lt;code&gt;\setminus&lt;/code&gt;，如：$x \setminus y$&lt;/li&gt;
  &lt;li&gt;同或运算，符号：&lt;code&gt;\bigodot&lt;/code&gt;，如：$x \bigodot y$&lt;/li&gt;
  &lt;li&gt;同与运算，符号：&lt;code&gt;\bigotimes&lt;/code&gt;，如：$x \bigotimes y$&lt;/li&gt;
  &lt;li&gt;实数集合，符号：&lt;code&gt;\mathbb{R}&lt;/code&gt;，如：&lt;code&gt;\mathbb{R}&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;自然数集合，符号：&lt;code&gt;\mathbb{Z}&lt;/code&gt;，如：&lt;code&gt;\mathbb{Z}&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;空集，符号：&lt;code&gt;\emptyset&lt;/code&gt;，如：$\emptyset$&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;数学符号&quot;&gt;数学符号&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;无穷，符号：&lt;code&gt;\infty&lt;/code&gt;，如：$\infty$&lt;/li&gt;
  &lt;li&gt;虚数，符号：&lt;code&gt;\imath&lt;/code&gt;，如：$\imath$&lt;/li&gt;
  &lt;li&gt;虚数，符号：&lt;code&gt;\jmath&lt;/code&gt;，如：$\jmath$&lt;/li&gt;
  &lt;li&gt;数学符号，符号&lt;code&gt;\hat{a}&lt;/code&gt;，如：$\hat{a}$&lt;/li&gt;
  &lt;li&gt;数学符号，符号&lt;code&gt;\check{a}&lt;/code&gt;，如：$\check{a}$&lt;/li&gt;
  &lt;li&gt;数学符号，符号&lt;code&gt;\breve{a}&lt;/code&gt;，如：$\breve{a}$&lt;/li&gt;
  &lt;li&gt;数学符号，符号&lt;code&gt;\tilde{a}&lt;/code&gt;，如：$\tilde{a}$&lt;/li&gt;
  &lt;li&gt;数学符号，符号&lt;code&gt;\bar{a}&lt;/code&gt;，如：$\bar{a}$&lt;/li&gt;
  &lt;li&gt;矢量符号，符号&lt;code&gt;\vec{a}&lt;/code&gt;，如：$\vec{a}$&lt;/li&gt;
  &lt;li&gt;数学符号，符号&lt;code&gt;\acute{a}&lt;/code&gt;，如：$\acute{a}$&lt;/li&gt;
  &lt;li&gt;数学符号，符号&lt;code&gt;\grave{a}&lt;/code&gt;，如：$\grave{a}$&lt;/li&gt;
  &lt;li&gt;数学符号，符号&lt;code&gt;\mathring{a}&lt;/code&gt;，如：$\mathring{a}$&lt;/li&gt;
  &lt;li&gt;一阶导数符号，符号&lt;code&gt;\dot{a}&lt;/code&gt;，如：$\dot{a}$&lt;/li&gt;
  &lt;li&gt;二阶导数符号，符号&lt;code&gt;\ddot{a}&lt;/code&gt;，如：$\ddot{a}$&lt;/li&gt;
  &lt;li&gt;上箭头，符号：&lt;code&gt;\uparrow&lt;/code&gt;，如：$\uparrow$&lt;/li&gt;
  &lt;li&gt;上箭头，符号：&lt;code&gt;\Uparrow&lt;/code&gt;，如：$\Uparrow$&lt;/li&gt;
  &lt;li&gt;下箭头，符号：&lt;code&gt;\downarrow&lt;/code&gt;，如：$\downarrow$&lt;/li&gt;
  &lt;li&gt;下箭头，符号：&lt;code&gt;\Downarrow&lt;/code&gt;，如：$\Downarrow$&lt;/li&gt;
  &lt;li&gt;左箭头，符号：&lt;code&gt;\leftarrow&lt;/code&gt;，如：$\leftarrow$&lt;/li&gt;
  &lt;li&gt;左箭头，符号：&lt;code&gt;\Leftarrow&lt;/code&gt;，如：$\Leftarrow$&lt;/li&gt;
  &lt;li&gt;右箭头，符号：&lt;code&gt;\rightarrow&lt;/code&gt;，如：$\rightarrow$&lt;/li&gt;
  &lt;li&gt;右箭头，符号：&lt;code&gt;\Rightarrow&lt;/code&gt;，如：$\Rightarrow$&lt;/li&gt;
  &lt;li&gt;底端对齐的省略号，符号：&lt;code&gt;\ldots&lt;/code&gt;，如：$1,2,\ldots,n$&lt;/li&gt;
  &lt;li&gt;中线对齐的省略号，符号：&lt;code&gt;\cdots&lt;/code&gt;，如：$x_1^2 + x_2^2 + \cdots + x_n^2$&lt;/li&gt;
  &lt;li&gt;竖直对齐的省略号，符号：&lt;code&gt;\vdots&lt;/code&gt;，如：$\vdots$&lt;/li&gt;
  &lt;li&gt;斜对齐的省略号，符号：&lt;code&gt;\ddots&lt;/code&gt;，如：$\ddots$&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;希腊字母&quot;&gt;希腊字母&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;字母&lt;/th&gt;
      &lt;th&gt;实现&lt;/th&gt;
      &lt;th&gt;字母&lt;/th&gt;
      &lt;th&gt;实现&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;A&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;A&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;α&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\alhpa&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;B&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;B&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;β&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\beta&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Γ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\Gamma&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;γ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\gamma&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Δ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\Delta&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;δ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\delta&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;E&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;E&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;ϵ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\epsilon&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Z&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;Z&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;ζ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\zeta&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;H&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;H&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;η&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\eta&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Θ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\Theta&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;θ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\theta&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;I&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;I&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;ι&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\iota&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;K&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;K&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;κ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\kappa&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Λ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\Lambda&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;λ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\lambda&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;M&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;M&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;μ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\mu&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;N&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;N&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;ν&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\nu&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ξ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\Xi&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;ξ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\xi&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;O&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;O&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;ο&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\omicron&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Π&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\Pi&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;π&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\pi&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;P&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;P&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;ρ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\rho&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Σ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\Sigma&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;σ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\sigma&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;T&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;T&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;τ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\tau&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Υ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\Upsilon&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;υ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\upsilon&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Φ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\Phi&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;ϕ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\phi&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;X&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;X&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;χ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\chi&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ψ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\Psi&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;ψ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\psi&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ω&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\v&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;ω&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\omega&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name></name></author><category term="wiki" /><summary type="html">Markdown数学公式</summary></entry><entry><title type="html">celery</title><link href="https://acemyzoe.github.io/_posts/2020-08-20-celery/" rel="alternate" type="text/html" title="celery" /><published>2020-08-20T00:00:00+08:00</published><updated>2020-08-20T00:00:00+08:00</updated><id>https://acemyzoe.github.io/_posts/celery</id><content type="html" xml:base="https://acemyzoe.github.io/_posts/2020-08-20-celery/">&lt;h1 id=&quot;celery&quot;&gt;Celery&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://www.celerycn.io/&quot;&gt;Celery 中文手册&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Celery 分布式任务队列，可用于处理实时数据以及任务调度。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;选择并且安装一个消息中间件（Broker）&lt;/li&gt;
  &lt;li&gt;安装 Celery 并且创建第一个任务&lt;/li&gt;
  &lt;li&gt;运行职程（Worker）以及调用任务&lt;/li&gt;
  &lt;li&gt;跟踪任务的情况以及返回值&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用 Redis 作为中间人（Broker）必须要安装 Celery 的依赖库&lt;/p&gt;</content><author><name></name></author><category term="python" /><summary type="html">Celery</summary></entry><entry><title type="html">python-QA</title><link href="https://acemyzoe.github.io/_posts/2020-08-18-python-QA/" rel="alternate" type="text/html" title="python-QA" /><published>2020-08-18T00:00:00+08:00</published><updated>2020-08-18T00:00:00+08:00</updated><id>https://acemyzoe.github.io/_posts/python-QA</id><content type="html" xml:base="https://acemyzoe.github.io/_posts/2020-08-18-python-QA/">&lt;h1 id=&quot;python-interview&quot;&gt;python Interview&lt;/h1&gt;

&lt;p&gt;Python基本功和基本原理，重点考察运算符、装饰器、生成器的原理和实现，垃圾回收机制、各种数据类型，以及线程、进程、协程的概念和应用。&lt;/p&gt;

&lt;p&gt;计算机基础，重点考察数据结构（链表、哈希、堆栈、二叉树）和算法分析（时间复杂度分析）&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;这两个参数是什么意思：*args，**kwargs？我们为什么要使用它们？&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;如果我们不确定往一个函数中传入多少参数，或者我们希望以元组（tuple）或者列表（list）的形式传参数的时候，我们可以使用*args（单星号）。如果我们不知道往函数中传递多少个关键词参数或者想传入字典的值作为关键词参数的时候我们可以使用**kwargs（双星号），args、kwargs两个标识符是约定俗成的用法。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;谈一谈Python的装饰器（decorator）&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;装饰器本质上是一个Python函数，它可以让其它函数在不作任何变动的情况下增加额外功能，装饰器的返回值也是一个函数对象。它经常用于有切面需求的场景。比如：插入日志、性能测试、事务处理、缓存、权限校验等。有了装饰器我们就可以抽离出大量的与函数功能无关的雷同代码进行重用。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;简要描述Python的垃圾回收机制（garbage collection）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Python多线程（multi-threading）。这是个好主意吗？&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;说明&lt;strong&gt;os,sys&lt;/strong&gt;模块不同，并列举常用的模块方法？&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;什么是lambda表达式？它有什么好处？&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Python中pass语句的作用是什么？&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Python是如何进行类型转换的？&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Python里面如何拷贝一个对象？&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;__new__&lt;/code&gt;和&lt;code&gt;__init__&lt;/code&gt;的区别。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Python中单下划线和双下划线分别是什么？&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;说一说Python自省。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如何反序迭代一个序列？&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如何用Python来进行查询和替换一个文本字符串？&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用Python实现单例模式。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;重新实现str.strip()，注意不能使用string.*strip()&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;super&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Python的函数参数传递&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;strong&gt;Python&lt;/strong&gt;中&lt;strong&gt;string、tuple、number&lt;/strong&gt;属于不可更改对象，而&lt;strong&gt;list&lt;/strong&gt;和&lt;strong&gt;dict&lt;/strong&gt;属于可修改对象。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;类变量和实例变量&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Python在函数式编程方面的支持。&lt;strong&gt;lambda&lt;/strong&gt;表达式\内建函数：&lt;strong&gt;filter()、reduce()、map()&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;试图访问一个列表的以超出列表成员数作为开始索引的切片将不会导致&lt;strong&gt;IndexError&lt;/strong&gt;，并且仅仅返回一个空&lt;strong&gt;list&lt;/strong&gt;&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;templist = [1,2,3,4,5]
print(temolist[10:])
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;late binding&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;def testfun():
    temp = [lambda x: i*x for i in range(4)]
    return temp
  
for lb in testfun():
    print(lb(2))
  
def testfun():
    temp = [lambda x,i=i : i*x for i in range(4)]
    return temp
  
for lb in testfun():
    print(lb(2))
      
def testfun():
    return (lambda x: i*x for i in range(4))
  
for lb in testfun():
    print(lb(2))
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;笔试试题“一个芬兰人进了一个房间，房间有一排椅子，椅子上有一些人坐着，还剩一些空位，他要选择一个位子坐下，这个位子要尽可能远离已经坐着的人，请给出算法。请自行定义数据结构和输入输出。”&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;import unittest
# 分析空位情况：1,首位有人；2，尾位有人；3中间占人
# 输入：空位列表 输出：结果位置和最大距离
# 1.输入：list=[1,0,0,0] 输出：[3],3
# 2.输入：list=[0,0,0,1] 输出：[0],3
# 3.输入：list=[1,0,0,0,1,0,1] 输出：[2],2
# 4.输入：list=[1,0,0,1,0] 输出:[1,2,4],1
  
class Testlist(unittest.TestCase):
  
    def test_case1(self):
        list=[1,0,0,0]
        self.assertEqual(solution(list),([3], 3))
      
    def test_case2(self):
        list=[0,0,0,1]
        self.assertEqual(solution(list), ([0], 3))
  
    def test_case3(self):
        list=[1,0,0,0,1,0,1]
        self.assertEqual(solution(list), ([2], 2))
  
    def test_case4(self):
        list=[1,0,0,1,0]
        self.assertEqual(solution(list), ([1,2,4], 1))
  
def solution(seats):
    &quot;&quot;&quot;
    seats: List[int]
    return: ans[int],int
    &quot;&quot;&quot;
    persons = [p for p, seat in enumerate(seats) if seat == 1]
    nullseat = [p for p, seat in enumerate(seats) if seat == 0]
    maxdict = max(persons[0], 
              len(seats)-1-persons[-1], 
              max([(persons[r]-persons[r-1])//2 for r in range(1, len(persons))]+[0]))
    ans=[]
    for i in nullseat:
        if min([abs(i-j) for j in persons])==maxdict:
           ans.append(i) 
    return ans,maxdict
  
if __name__ == '__main__':
    unittest.main()
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="python" /><summary type="html">python Interview</summary></entry><entry><title type="html">苏菲的世界</title><link href="https://acemyzoe.github.io/_posts/2020-08-15-%E8%8B%8F%E8%8F%B2%E7%9A%84%E4%B8%96%E7%95%8C-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" rel="alternate" type="text/html" title="苏菲的世界" /><published>2020-08-15T00:00:00+08:00</published><updated>2020-08-15T00:00:00+08:00</updated><id>https://acemyzoe.github.io/_posts/%E3%80%8A%E8%8B%8F%E8%8F%B2%E7%9A%84%E4%B8%96%E7%95%8C%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0</id><content type="html" xml:base="https://acemyzoe.github.io/_posts/2020-08-15-%E8%8B%8F%E8%8F%B2%E7%9A%84%E4%B8%96%E7%95%8C-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">&lt;h1 id=&quot;伊甸园&quot;&gt;伊甸园&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;我是谁？&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;唯有清晰地意识到有一天她终将死去，她才能体会活在世上是多么美好。&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;blockquote&gt;
      &lt;p&gt;“小小玛丽来到人间，惊鸿一瞥魂归高天。”&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;世界从何而来？&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;在某一时刻，事物必然曾经从无到有。然而，这可能吗？这不就和世界一直存在的看法一样不可思议吗？&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;魔术师的礼帽&quot;&gt;魔术师的礼帽&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;要成为一个优秀的哲学家只有一个条件：要有好奇心……&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;探讨哲学最好的方式就是问一些哲学性的问题，如：这世界是如何创造出来的?其背后是否有某种意志或意义?人死后还有生命吗?我们如何能够解答这些问题呢?最重要的是，我们应该如何生活?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;生命是一种很庞大的、神秘的存在。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;神话&quot;&gt;神话&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;人们总是想为大自然的变迁寻求解释。这就是他们何以在科学还没有产生之前会编造出那些神话故事的原因。&lt;/p&gt;

  &lt;p&gt;从神话的思考模式发展到以经验与理性为基础的思考模式。&lt;/p&gt;

  &lt;p&gt;早期希腊哲学家的目标乃是为大自然的变化寻找自然的——而非超自然的——解释。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;自然派哲学家&quot;&gt;自然派哲学家&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;万事万物是否由一种基本的物质组成？&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;最早的希腊哲学家有时被称为“自然派哲学家”，因为他们关切的主题是大自然与它的循环与变化。&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;blockquote&gt;
      &lt;p&gt;没有任何事物会来自虚无这三位米雷特斯的哲学家都相信，宇宙间有一种基本物质是所有事物的源头。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;帕梅尼德斯：
    &lt;ul&gt;
      &lt;li&gt;“没有任何事物会来自虚无。”没有任何事物会改变。&lt;/li&gt;
      &lt;li&gt;“感官幻象”-“理性主义”&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;赫拉克利特斯：
    &lt;ul&gt;
      &lt;li&gt;“所有事物都是流动的。”因此我们不可能“在同一条河流中涉水两次”。&lt;/li&gt;
      &lt;li&gt;世间的事物是相对的。&lt;/li&gt;
      &lt;li&gt;普遍的理性&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;恩培窦可里斯：
    &lt;ul&gt;
      &lt;li&gt;四种基本元素：土、气、火、水&lt;/li&gt;
      &lt;li&gt;两种力量：爱使事物聚合，而恨则使他们分散。&lt;/li&gt;
      &lt;li&gt;将物质与力量分开。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;安纳塞格拉斯：
    &lt;ul&gt;
      &lt;li&gt;大自然是由无数肉眼看不见的微小粒子所组成，而所有事物都可以被分割成更小的部分。然而，即使是在最小的部分中也有其他每种事物的成分存在。&lt;/li&gt;
      &lt;li&gt;整体存在于每一个微小的部分中。&lt;/li&gt;
      &lt;li&gt;天文学：太阳的本质、月亮的光、日蚀。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;哲学不是一般人能够学到的，但也许我们可以学习如何以哲学的方式思考。&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name></name></author><category term="阅读" /><summary type="html">伊甸园</summary></entry><entry><title type="html">java基础语法</title><link href="https://acemyzoe.github.io/_posts/2020-08-01-java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/" rel="alternate" type="text/html" title="java基础语法" /><published>2020-08-01T00:00:00+08:00</published><updated>2020-08-01T00:00:00+08:00</updated><id>https://acemyzoe.github.io/_posts/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95</id><content type="html" xml:base="https://acemyzoe.github.io/_posts/2020-08-01-java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/">&lt;h1 id=&quot;java语法&quot;&gt;JAVA语法&lt;/h1&gt;

&lt;h2 id=&quot;hello-world&quot;&gt;hello world&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;在 Java 中，所有的代码都必须写在类里面，定义一个 HelloWorld 类。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;/* hello world demo */
public class HelloWorld{
    public static void main(String []args){
        System.out.println(&quot;Hello World!&quot;); // 打印
    }
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;基本数据类型&quot;&gt;基本数据类型&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;整型类型：byte（字节）、short（短整型）、int（整型）、long（长整型）&lt;/li&gt;
  &lt;li&gt;浮点类型：float（单精度浮点）、double（双精度浮点）&lt;/li&gt;
  &lt;li&gt;字符型：char&lt;/li&gt;
  &lt;li&gt;布尔型：boolean&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;封装这些基本数据类型的类&quot;&gt;封装这些基本数据类型的类&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Integer：对应封装了基本类型 int&lt;/li&gt;
  &lt;li&gt;Long：对应封装了基本类型 long&lt;/li&gt;
  &lt;li&gt;Float：对应封装了基本类型 float&lt;/li&gt;
  &lt;li&gt;Double：对应封装了基本类型 double&lt;/li&gt;
  &lt;li&gt;Boolean：对应封装了基本类型 boolean&lt;/li&gt;
  &lt;li&gt;String：对应封装了字符串类型 char[]&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;int a = 6;
Integer oa = new Integer(6);
int a[] = new int[10]; //定义长度为10的int类型数组
a[1] = 3;
System.out.println(a[2])
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;流程控制&quot;&gt;流程控制&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;/* if-else */
int a;
if (a&amp;gt;1){
    //todo
} else if (a=1){
    //todo
} else{
    //todo
}

/* switch-case */
switch (a) {
    case 1:
        //todo
        break;
    case 2:
        //todo
        break;
    default:
        //default
}

/*  for/while */
for (int i = 0; i &amp;lt; 10; ++i) {
    if(i==4){
        continue;//跳出本次循环
    }
    if(i==3){
        break;//提前终止循环
    }
}

while (i&amp;lt;10) {
    //todo
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;类对象&quot;&gt;类、对象&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class Dog {
    private int age;
    private int weight;
    
    public Dog(int age,int weight){//构造函数，命名同类名
        this.age=age;
        this.weight=weight;
    }
    
    public int getAge(){
        return age;
    }
    
    public void run(){
        //todo
    }
}

Dog dog1 = new Dog(2,111); //通过new创建一个Dog对象
int age = dog1.getAge();
dog1.run();
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;权限修饰符&quot;&gt;权限修饰符&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;private 修饰的函数或者成员变量，只能在类内部使用。&lt;/li&gt;
  &lt;li&gt;protected 修饰的函数或者成员变量，可以在类及其子类内使用。&lt;/li&gt;
  &lt;li&gt;public 修饰的函数或者成员变量，可以被任意访问。&lt;/li&gt;
  &lt;li&gt;权限修饰符还可以修饰类&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;继承&quot;&gt;继承&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Java 语言使用 extends 关键字来实现继承&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class Animal {//父类
    protected int age;//protected
    protected int weight;
    
    public Animal(int age,int weight){
        this.age=age;
        this.weight=weight;
    }
    
    public int getAge(){
        return age;
    }
}

public class Dog extends Animal {//子类
    public Dog(int age,int weight){
        super(age,weight);//调用父类的构造函数
    }
    
    public void wang(){
        //...
    }
}

Dog dog1 = new Dog(2,22);
dog1.run();
dog1.wang();
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;接口&quot;&gt;接口&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Java 语言通过 interface 关键字来定义接口。&lt;/p&gt;

  &lt;p&gt;接口中只能声明方法，不能包含实现，也不能定义属性。&lt;/p&gt;

  &lt;p&gt;类通过 implements 关键字来实现接口中定义的方法。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public interface Runable{
    void run();
}

public class Dog implements Runable {
    private int age;
    private int weight;
    
    public Dog(int age,int weight){
        this.age=age;
        this.weight=weight;
    }
    
    public int getAge(){
        return age;
    }
    
    @Override
    public void run(){//实现接口中定义的run方法
        //todo
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;容器&quot;&gt;容器&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;容器可以理解为一些工具类，底层封装了各种数据结构。&lt;/p&gt;

  &lt;p&gt;如 ArrayList 底层就是数组，LinkedList 底层就是链表，HashMap 底层就是散列表等&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class DemoA{
    private ArrayList&amp;lt;User&amp;gt; users;
    public void addUser(User user){
        users.add(user);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;异常处理&quot;&gt;异常处理&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;通过关键字 throw 来抛出一个异常，&lt;/p&gt;

  &lt;p&gt;通过 throws 声明函数抛出异常，&lt;/p&gt;

  &lt;p&gt;通过 try-catch-finally 语句来捕获异常。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class UserNotFoundException extends Exception{//自定义一个异常
    public UserNotFoundException(){
        super();
    }
    public UserNotFoundException(String message){
        super(message);
    }
    public UserNotFoundException(String message,Throwable e){
        super(message,e);
    }
}

public class UserService{
    private UserRepository uerRepo;
    public UserService(UseRepository userRepo){
        this.userRepo = userRepo;
    }
    public User getUserById(long userId) throws UserNotFoundException{
        User user = userRepo.findUserById(userId);
        if (user == null){// throw用来抛出异常
            throw new UserNotFoundException();// 代码从此处返回
        }
    }
}

public class UserController{
    private UserService userService;
    public UserController(UserService userService){
        this.userService = userService;
    }
    public User getUserById(long userId){
        User user = null;
        try{// 捕获异常
            user = userService.getUserById(userId);
        } catch (UserNotFoundException e){
            System.out.println(&quot;User not found: &quot; + userId);
        } finally {// 不管异常会不会发生，finally包裹的语句块总会被执行
            System.out.println(&quot;I am always printed.&quot;);
        }
        return user;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;package包&quot;&gt;package包&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Java 通过 pacakge 关键字来分门别类地组织类，通过 import 关键字来引入类或者package。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;/*class DemoA*/
package com.xzg.cd; // 包名 com.xzg.cd
public class DemoA{
    //...
}
/*class DemoB*/
package com.xzg.alg;
import java.util.HashMap; // Java 工具包JDK中的类
import java.util.Map;
import com.xzg.cd.DemoA;
public class DemoB{
    //...
}
&lt;/code&gt;&lt;/pre&gt;</content><author><name></name></author><category term="java" /><summary type="html">JAVA语法</summary></entry><entry><title type="html">python Interview</title><link href="https://acemyzoe.github.io/_posts/2020-08-01-python-interview/" rel="alternate" type="text/html" title="python Interview" /><published>2020-08-01T00:00:00+08:00</published><updated>2020-08-01T00:00:00+08:00</updated><id>https://acemyzoe.github.io/_posts/python%20interview</id><content type="html" xml:base="https://acemyzoe.github.io/_posts/2020-08-01-python-interview/">&lt;h1 id=&quot;python-interview&quot;&gt;python Interview&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;工作中真正的核心竞争力：写出整洁的代码和架构，面向对象的思维(原则与设计)，模式的使用。以及复杂性解决方法，抽象、分治、领域设计。&lt;/p&gt;

  &lt;p&gt;语言的特性，底层的原理，源码等特定细节的东西可以在使用时再去调研，但解决问题的能力，整洁的代码和架构并不是短期可以突击的。&lt;/p&gt;

  &lt;p&gt;系统：语言Python，Linux基础操作，SQL，消息队列，GIT…木桶理论&lt;/p&gt;

  &lt;p&gt;基础功扎实，新东西学得快，代码写得溜，命令敲得顺，bug解的好&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;基础语法&quot;&gt;基础语法&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;可变与不可变类型&lt;/li&gt;
  &lt;li&gt;浅拷贝与深拷贝的实现方式、区别；deepcopy如果你来设计，如何实现；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;__new__() 与 __init__()&lt;/code&gt;的区别；&lt;/li&gt;
  &lt;li&gt;你知道几种设计模式；&lt;/li&gt;
  &lt;li&gt;编码和解码你了解过么；&lt;/li&gt;
  &lt;li&gt;手写：正则邮箱地址；&lt;/li&gt;
  &lt;li&gt;介绍下垃圾回收：引用计数/分代回收/孤立引用环；&lt;/li&gt;
  &lt;li&gt;多进程与多线程的区别；CPU密集型适合用什么；&lt;/li&gt;
  &lt;li&gt;进程通信的方式有几种；&lt;/li&gt;
  &lt;li&gt;介绍下协程，为何比线程还快；&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;函数参数传递&quot;&gt;函数参数传递&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# Python的函数参数传递
# http://stackoverflow.com/questions/986006/how-do-i-pass-a-variable-by-reference
# 所有的变量都可以理解是内存中一个对象的“引用”

# strings, tuples, 和numbers 不可变对象
a=1
def fun1(a):
    print(id(a),id(1)) # 1798961072 1798961072
    a=2
    print(id(a),id(2)) # 1798961088 1798961088
    print(a) # 2
fun1(a)
print(a) # 1

# list, dict, set 可变对象
b=[]
def fun2(b):
    print(id(b)) # 9174792
    b.append(1)
    print(id(b)) # 9174792
    print(b) #[1]
fun2(b)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;元类&quot;&gt;元类&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 元类 metaclass
# http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python
# 元类是类的类，定义类的行为，常用作类工厂。type是Python用于在幕后创建所有类的元类。
class MyMeta(type):
    '''
        子类将获得一个class属性_order，该属性记录定义类的顺序。
    '''
    counter = 0
    def __init__(cls, name, bases, dic): # name:class名称 bases：父类的元组 dic/attrs：包含属性名称和值的字典
        type.__init__(cls, name, bases, dic)
        cls._order = MyMeta.counter
        MyMeta.counter += 1
class MyType0(metaclass=MyMeta):  
    pass

class MyType1(metaclass=MyMeta):  
    pass

class MyType2(MyMeta):
    pass

print(MyType0._order，MyType1._orderMyType2.counter) # 0 1 2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;类变量和实例变量&quot;&gt;类变量和实例变量&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 类变量和实例变量
class Test(object):  
    num_of_instance = 0  
    name = 'test'
    def __init__(self, name):  
        self.name = name  
        Test.num_of_instance += 1  
  
if __name__ == '__main__':  
    print(Test.name,Test.num_of_instance) # test 0
    t1 = Test('t1')  
    t2 = Test('t2')  
    print(t1.name , t1.num_of_instance) # t1 2
    print(t2.name , t2.num_of_instance) # t2 2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;python自省&quot;&gt;python自省&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 自省
# 运行时能够获得对象的类型.比如type(),dir(),getattr(),hasattr(),isinstance().
a = [1,2,3]
b = {'a':1,'b':2,'c':3}
c = True
print(type(a),type(b),type(c)) # &amp;lt;class 'list'&amp;gt; &amp;lt;class 'dict'&amp;gt; &amp;lt;class 'bool'&amp;gt;
print(isinstance(a,list))  # True
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;推导式&quot;&gt;推导式&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 推导式
# 列表推导式list
li=[i*2 for i in range(10) if i % 2 == 0]
print(li)
# 字典推导式dict
m={&quot;a&quot;:1, &quot;b&quot;:2, &quot;c&quot;:3, &quot;d&quot;:4}
di={v:k for k,v in m.items()}
print(di)
# 集合推导式set
# 集合是一种无重复无序的序列
s={i*2 for i in [1,1,2]}
print(s)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;单下划线和双下划线&quot;&gt;单下划线和双下划线&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 单下划线和双下划线
# http://stackoverflow.com/questions/1301346/the-meaning-of-a-single-and-a-double-underscore-before-an-object-name-in-python
class MyClass():
    def __init__(self):
            self.__superprivate = &quot;Hello&quot;  # 解释器将其替换为对象名._类名__xxx
            self._semiprivate = &quot;, world!&quot; # 用来指定变量私有

my = MyClass()
print(my.__dict__)
print(my._MyClass__superprivate)
print(my._semiprivate)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;迭代器和生成器&quot;&gt;迭代器和生成器&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 迭代器和生成器
# https://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do
# 列表可一一阅读它的项目。逐一读取其项称为迭代,所有值存储在内存。
# 生成器：边循环，边计算的机制—&amp;gt;generator
l = [x*x for x in range(10)] 
g = (x*x for x in range(10))
print(type(l),type(g)) # &amp;lt;class 'list'&amp;gt; &amp;lt;class 'generator'&amp;gt;
# itertools模块包含用于操纵可迭代对象的特殊功能
import itertools
horses=[1,2,3]
races = itertools.permutations(horses)
print(list(races)) # 三匹马比赛的可能到达顺序
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;args-and-kwargs&quot;&gt;*args and **kwargs&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# *args and **kwargs
# https://stackoverflow.com/questions/3394835/use-of-args-and-kwargs
# 用*args传递任意数量的参数
def print_everything(*args):
    for count, thing in enumerate(args):
        print('{0}. {1}'.format(count, thing))
print_everything('1','a')
# **kwargs为函数提供任意关键字参数,并将它们作为字典使用。
def table_things(**kwargs):
    for name, value in kwargs.items():
        print('{0}={1}'.format(name, value))
table_things(apple='fruit', cabbage='vegetable')
# 调用函数时用*和**语法
def print_three_things(a, b, c):
    print('a={0}, b={1}, c={2}'.format(a,b,c))
mylist = ['1', '2', '3']
print_three_things(*mylist)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;面向切面编程aop和装饰器&quot;&gt;面向切面编程AOP和装饰器&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 面向切面编程AOP和装饰器
# 装饰器的作用就是为已经存在的对象添加额外的功能,经常被用于有切面需求的场景
# https://stackoverflow.com/questions/739654/how-to-make-a-chain-of-function-decorators
'''装饰器只是语法糖
@decorator
def func():
    ...
等效于
def func():
    ...
func = decorator(func)
'''
###############################
# The decorator to make it bold
def makebold(fn):
    # The new function the decorator returns
    def wrapper():
        # Insertion of some code before and after
        return &quot;&amp;lt;b&amp;gt;&quot; + fn() + &quot;&amp;lt;/b&amp;gt;&quot;
    return wrapper

# The decorator to make it italic
def makeitalic(fn): 
    return lambda: &quot;&amp;lt;i&amp;gt;&quot; + fn() + &quot;&amp;lt;/i&amp;gt;&quot;

@makebold
@makeitalic
def say():
    return &quot;hello&quot;
print(say())
#################################
# This is the exact equivalent to
def says():
    return &quot;hello&quot;
my = makebold(makeitalic(says))
print(my())

class sty(object):
  def __init__(self, tag):
    self.tag = tag
  def __call__(self, f):
    def newf():
      return &quot;&amp;lt;{tag}&amp;gt;{res}&amp;lt;/{tag}&amp;gt;&quot;.format(res=f(), tag=self.tag)
    return newf

@sty('b')
@sty('i')
def sayhi():
  return 'hi'
print(sayhi())
###################################
# 使用functools.wraps
from functools import wraps
def wrap_in_tag(tag):
    def factory(func):
        @wraps(func)
        def decorator(val):
            return func('&amp;lt;%(tag)s&amp;gt;%(val)s&amp;lt;/%(tag)s&amp;gt;' %
                        {'tag': tag, 'val': val})
        return decorator
    return factory

@wrap_in_tag('b')
@wrap_in_tag('i')
def log(s):
    return s
print(log('hello')) # &amp;lt;b&amp;gt;&amp;lt;i&amp;gt;hello&amp;lt;/i&amp;gt;&amp;lt;/b&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;鸭子类型-duck-typing&quot;&gt;鸭子类型 duck typing&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。&lt;/p&gt;

  &lt;p&gt;一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由”当前方法和属性的集合”决定。&lt;/p&gt;

  &lt;p&gt;鸭子类型是多态性的一种表现，函数可以通过鸭子类型来处理不同类型的对象，函数重载在动态语言中就显得没有意义。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;python不支持函数重载&quot;&gt;Python不支持函数重载&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;函数重载主要是为了解决两个问题。&lt;/p&gt;

  &lt;ol&gt;
    &lt;li&gt;可变参数类型。而 python 可以接受任何类型的参数。&lt;/li&gt;
    &lt;li&gt;可变参数个数。而 python 使用缺省参数。&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;__new__和__init__的区别&quot;&gt;&lt;code&gt;__new__&lt;/code&gt;和&lt;code&gt;__init__&lt;/code&gt;的区别&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;&lt;code&gt;__new__&lt;/code&gt;是一个静态方法,而&lt;code&gt;__init__&lt;/code&gt;是一个实例方法.&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;__new__&lt;/code&gt;方法会返回一个创建的实例,而&lt;code&gt;__init__&lt;/code&gt;什么都不返回.&lt;/li&gt;
    &lt;li&gt;只有在&lt;code&gt;__new__&lt;/code&gt;返回一个cls的实例时后面的&lt;code&gt;__init__&lt;/code&gt;才能被调用.&lt;/li&gt;
    &lt;li&gt;当创建一个新实例时调用&lt;code&gt;__new__&lt;/code&gt;,初始化一个实例时用&lt;code&gt;__init__&lt;/code&gt;.&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;__new__&lt;/code&gt;除非要继承不可变类型（例如str，int，unicode或tuple），否则无需重写&lt;/li&gt;
    &lt;li&gt;可以分别使用&lt;code&gt;__metaclass__&lt;/code&gt;,&lt;code&gt;__new__&lt;/code&gt;和&lt;code&gt;__init__&lt;/code&gt;来分别在类创建,实例创建和实例初始化的时候做一些小手脚.&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;单例模式&quot;&gt;单例模式&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 使用__new__方法
class Singleton(object):
    def __new__(cls, *args, **kw):
        if not hasattr(cls, '_instance'):
            orig = super(Singleton, cls)
            cls._instance = orig.__new__(cls, *args, **kw)
        return cls._instance
class MyClass(Singleton):
    a = 1

# 共享属性:创建实例时把所有实例的__dict__指向同一个字典
class Borg(object):
    _state = {}
    def __new__(cls, *args, **kw):
        ob = super(Borg, cls).__new__(cls, *args, **kw)
        ob.__dict__ = cls._state
        return ob
class MyClass2(Borg):
    a = 1

# 装饰器版本
def singleton(cls):
    instances = {}
    def getinstance(*args, **kw):
        if cls not in instances:
            instances[cls] = cls(*args, **kw)
        return instances[cls]
    return getinstance
@singleton
class MyClass:
    a = 1

# import方法,作为python的模块是天然的单例模式
# mysingleton.py
class My_Singleton(object):
    def foo(self):
        pass
my_singleton = My_Singleton()
# to use
from mysingleton import my_singleton
my_singleton.foo()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;gil线程全局锁global-interpreter-lock&quot;&gt;GIL线程全局锁Global Interpreter Lock&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Python为了保证线程安全而采取的独立线程运行的限制,一个核只能在同一时间运行一个线程。&lt;/p&gt;

  &lt;p&gt;https://www.oschina.net/translate/pythons-hardest-problem&lt;/p&gt;

  &lt;p&gt;对于io密集型任务，python的多线程起到作用，但对于cpu密集型任务，python的多线程几乎占不到任何优势，还有可能因为争夺资源而变慢。&lt;/p&gt;

  &lt;p&gt;解决办法就是多进程和协程。&lt;/p&gt;

  &lt;p&gt;协程是进程和线程的升级版,进程和线程都面临着内核态和用户态的切换问题而耗费许多切换时间,而协程就是用户自己控制切换的时机,不再需要陷入系统的内核态。Python里最常见的yield就是协程的思想&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# yield是与return一样使用的关键字return，不同之处在于该函数将返回生成器。
# 第一次for调用从函数创建的生成器对象时，它将从头开始运行函数中的代码，直到命中yield，然后它将返回循环的第一个值。然后，每个后续调用将运行您在函数中编写的循环的另一个迭代，并返回下一个值。这将一直持续到生成器被认为是空的为止，这在函数运行时没有命中时就会发生yield。
def createGenerator():
    mylist = range(3)
    for i in mylist:
        yield i*i
mygenerator = createGenerator()# 在调用该函数时，在函数主体中编写的代码不会运行。该函数仅返回生成器对象
for i in mygenerator:
    print(i)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;闭包closure&quot;&gt;闭包closure&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 闭包
# https://zhuanlan.zhihu.com/p/22229197
# 在一个内部函数中，对外部作用域的变量进行引用，(并且一般外部函数的返回值为内部函数)
# 闭包作用：函数运行后并不会被撤销，用于保存当前的运行环境
def start(x):
    def increment(y): # 闭包
        return x+y
    return increment
a = start(1)
print(a) # &amp;lt;function start.&amp;lt;locals&amp;gt;.increment at 0x0384CC40&amp;gt;
print(a(1)) # 2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;python函数式编程&quot;&gt;Python函数式编程&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# Python函数式编程
# https://coolshell.cn/articles/10822.html
# lambda匿名函数
a = map(lambda x:x*2,[1,2,3]) # map函数是对一个序列的每个项依次执行函数
print((a))
b = filter(lambda x: x &amp;gt; 5, a) 
# filter函数的功能相当于过滤器。
# 调用一个布尔函数bool_func来迭代遍历每个seq中的元素；返回一个使bool_seq返回值为true的元素的序列
print(list(b))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;python里的拷贝&quot;&gt;Python里的拷贝&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 引用和copy(),deepcopy()的区别
# https://www.geeksforgeeks.org/copy-python-deep-copy-shallow-copy/
import copy
a = [1, 2, 3, 4, ['a', 'b']]  #原始对象

b = a  #赋值，传对象的引用
c = copy.copy(a)  #对象拷贝，浅拷贝
d = copy.deepcopy(a)  #对象拷贝，深拷贝

a.append(5)  #修改对象a
a[4].append('c')  #修改对象a中的['a', 'b']数组对象

print('原始对象a = ',a) # [1, 2, 3, 4, ['a', 'b', 'c'], 5]
print('引用b = ',b) # [1, 2, 3, 4, ['a', 'b', 'c'], 5]
print('浅拷贝c = ',c) # [1, 2, 3, 4, ['a', 'b', 'c']]
print('深拷贝d = ',d) # [1, 2, 3, 4, ['a', 'b']]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;python垃圾回收机制&quot;&gt;Python垃圾回收机制&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# Python垃圾回收机制
# https://sutune.me/2018/10/14/python-GC/
# https://juejin.im/post/6844903629556547598
# http://www.ityouknow.com/python/2020/01/06/python-gc-111.html
# Python GC主要使用引用计数（reference counting）来跟踪和回收垃圾
# 通过“标记-清除”（mark and sweep）解决容器对象可能产生的循环引用问题
# 通过“分代回收”（generation collection）以空间换时间的方法提高垃圾回收效率

# 『引用计数法』的原理是：每个对象维护一个ob_ref字段，用来记录该对象当前被引用的次数，每当新的引用指向该对象时，它的引用计数ob_ref加1，每当该对象的引用失效时计数ob_ref减1，一旦对象的引用计数为0，该对象立即被回收，对象占用的内存空间将被释放。
# 循环引用导致内存泄露。解决方法：gc模块提供一个接口给开发者设置垃圾回收的选项
import sys
import gc
class A():
    def __init__(self):
        '''初始化对象'''
        print('object born id:%s' %str(hex(id(self))))

def func(c):
    print('obejct refcount is: ',sys.getrefcount(c)) #getrefcount()方法用于返回对象的引用计数

def fnrc():
    #生成对象
    a=A()
    func(a)
    #增加引用
    b=a
    func(a)
    #销毁引用对象b
    del b
    func(a)

def fngc():  
    '''垃圾自动回收'''
    gc.isenabled = True  
    print(gc.get_count())
    a=A()
    print(gc.get_count())
    del a
    print(gc.get_count())

if __name__ == '__main__':
    fngc()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;python中list是如何实现的&quot;&gt;Python中list是如何实现的&lt;/h2&gt;

&lt;p&gt;https://www.jianshu.com/p/J4U6rR&lt;/p&gt;

&lt;h2 id=&quot;python的is&quot;&gt;Python的is/==&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# is 与 == 的区别
# https://stackoverflow.com/questions/132988/is-there-a-difference-between-and-is
# https://stackoverflow.com/questions/26595/is-there-any-difference-between-foo-is-none-and-foo-none
a=1000
b=1e3
c=1000.0
print(a is b) # False
print(a is c) # False
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;python2和3的区别&quot;&gt;Python2和3的区别&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/	
from __future__ import division,unicode_literals
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;数据结构算法&quot;&gt;数据结构&amp;amp;算法&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;手写：已知一个长度n的无序列表，元素均是数字，要求把所有间隔为d的组合找出来，你写的解法算法复杂度多少；&lt;/li&gt;
  &lt;li&gt;手写：一个列表A=[A1，A2，…,An]，要求把列表中所有的组合情况打印出来；&lt;/li&gt;
  &lt;li&gt;手写：用一行python写出1+2+3+…+10**8 ；&lt;/li&gt;
  &lt;li&gt;手写python：用递归的方式判断字符串是否为回文；&lt;/li&gt;
  &lt;li&gt;单向链表长度未知，如何判断其中是否有环；&lt;/li&gt;
  &lt;li&gt;单向链表如何使用快速排序算法进行排序；&lt;/li&gt;
  &lt;li&gt;手写：一个长度n的无序数字元素列表，如何求中位数，如何尽快的估算中位数，你的算法复杂度是多少；&lt;/li&gt;
  &lt;li&gt;如何遍历一个内部未知的文件夹（两种树的优先遍历方式）&lt;/li&gt;
  &lt;li&gt;给定一个数组，构建二叉树，并且按层次打印这个二叉树&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;台阶问题斐波那契&quot;&gt;台阶问题/斐波那契&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 方法一
fib = lambda n: n if n&amp;lt;=2 else fib(n-1)+fib(n-2)
# 第二种记忆方法
def memo(func):
    cache = {}
    def wrap(*args):
        if args not in cache:
            cache[args] = func(*args)
        return cache[args]
    return wrap
@memo
def fib(i):
    if i &amp;lt; 2:
        return 1
    return fib(i-1)+fib(i-2)
# 方法三
def fib(n):
    a, b = 0, 1
    for _ in range(n):
        a, b = b, a+b
    return b
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;fib = lambda n: n if n&amp;lt;2 else 2*fib(n-1)
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;用n个&lt;code&gt;2*1&lt;/code&gt;的小矩形无重叠地覆盖一个&lt;code&gt;2*n&lt;/code&gt;的大矩形，总共有多少种方法？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;f = lambda n: 1 if n &amp;lt; 2 else f(n-1) + f(n-2)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;去除列表中的重复元素&quot;&gt;去除列表中的重复元素&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 去除列表中的重复元素
l = [1,1,2,2,3,4]
# 用集合
print(list(set(l)))
# 用字典
print({}.fromkeys(l).keys())
# 列表推导式
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;链表成对调换&quot;&gt;链表成对调换&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4&lt;/code&gt;转换成&lt;code&gt;2-&amp;gt;1-&amp;gt;4-&amp;gt;3&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;合并两个有序列表&quot;&gt;合并两个有序列表&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 尾递归
a = [1,2,3,7]
b = [3,4,5]
def _recursion_merge_sort2(l1, l2, tmp):
    if len(l1) == 0 or len(l2) == 0:
        tmp.extend(l1)
        tmp.extend(l2)
        return tmp
    else:
        if l1[0] &amp;lt; l2[0]:
            tmp.append(l1[0])
            del l1[0]
        else:
            tmp.append(l2[0])
            del l2[0]
        return _recursion_merge_sort2(l1, l2, tmp)
def recursion_merge_sort2(l1, l2):
    return _recursion_merge_sort2(l1, l2, [])
print(recursion_merge_sort2(a,b))

# 循环算法
a = [1,2,3,7]
b = [3,4,5]
def loop_merge_sort(l1, l2):
    tmp = []
    while len(l1) &amp;gt; 0 and len(l2) &amp;gt; 0:
        if l1[0] &amp;lt; l2[0]:
            tmp.append(l1[0])
            del l1[0]
        else:
            tmp.append(l2[0])
            del l2[0]
    tmp.extend(l1)
    tmp.extend(l2)
    return tmp
print(loop_merge_sort(a,b))

# pop弹出
a = [1,2,3,7]
b = [3,4,5]
def merge_sortedlist(a,b):
    c = []
    while a and b:
        if a[0] &amp;gt;= b[0]:
            c.append(b.pop(0))
        else:
            c.append(a.pop(0))
    while a:
        c.append(a.pop(0))
    while b:
        c.append(b.pop(0))
    return c
print(merge_sortedlist(a,b))

# 先合并后排序
a = [1,2,3,7]
b = [3,4,5]
def merge_sort(a,b):
    c=a+b
    c.sort()
    return c
print(merge_sort(a,b))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;python链表&quot;&gt;python链表&lt;/h2&gt;

&lt;p&gt;https://juejin.im/post/6844903672661409800&lt;/p&gt;

&lt;p&gt;https://www.jianshu.com/p/e4000619232b&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 用python中的引用来实现链表
# 节点类
# 功能包括：更新数据，查询数据，更新后继节点和查询后继节点。
class Node(object):
    #初始化，需要传入节点的数据
    def __init__(self, data):
        self.data = data
        self.next = None
    
    #返回节点的数据
    def get_data(self):
        return self.data
    
    #更新节点的数据
    def set_data(self, new_data):
        self.data = new_data
        
    #返回后继节点
    def get_next(self):
        return self.next
    
    #变更后继节点
    def set_next(self, new_next):
        self.next = new_next

# 链表类
# 节点的增加、删除和查询，返回链表的长度，返回链表是否为空等
class Linked_list(object):
    #初始化，头结点为空
    def __init__(self):
        self.head = None
    
    #添加节点，添加的新节点作为新的头结点
    def add(self, data):
        new_node = Node(data)
        new_node.set_next() = self.head
        self.head = new_node
        
    #包含查询，传入值，返回该值在链表中是否存在
    def search(self, data):
        checking = self.head #从头结点开始查询
        while checking != None :
            if checking.get_data() == data: #查找到，返回True
                return True
            checking = checking.get_next() #查询下一个节点
        return False #遍历到最后也未能找到，返回False
        
    #删除节点，将第一个具有传入值的节点从链表中删除
    def remove(self, data):
        checking = self.head #从头结点开始查询
        previous = None #记录前一个节点，头结点的前一个节点为None
        
        while checking != None :
            if checking.get_data() == data: #查找到，跳出查找循环
                break
            previous = checking # 更新前一个节点
            checking = checking.get_next() #查询下一个节点

        if previous == None:# 如果头结点便是查找的节点
            self.head = checking.get_next()
        else: # 查找的节点不在头结点，即，存在前驱节点
            previous.set_next(checking.get_next())       
    
    #判断链表是否为空
    def isEmpty(self):
        return self.head == None
    
    #返回链表长度
    def size(self):
        count = 0
        counting = self.head #从头结点开始计数
        while counting != None :
            count += 1
            counting = counting.get_next()
        return count
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;单链表逆置&quot;&gt;单链表逆置&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Node(object):
    def __init__(self, data=None, next=None):
        self.data = data
        self.next = next

def relink(link):
    pre = link
    cur = link.next
    pre.next = None
    while cur:
        tmp = cur.next
        cur.next = pre
        pre = cur
        cur = tmp
    return pre

link = Node(1, Node(2, Node(3, Node(4))))
root = relink(link)
while root:
    print(root.data)
    root = root.next
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;交叉链表求交点&quot;&gt;交叉链表求交点&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 使用a,b两个list来模拟链表，可以看出交叉点是 7这个节点
a = [1,2,3,7,9,1,5]
b = [4,5,7,9,1,5]
# 从尾开始比较两个链表，如果相交，则从尾开始必然一致，只要从尾开始比较，直至不一致的地方即为交叉点
for i in range(1,min(len(a),len(b))):
    if i==1 and (a[-1] != b[-1]):
        print(&quot;No&quot;)
        break
    else:
        if a[-i] != b[-i]:
            print(&quot;交叉节点：&quot;,a[-i+1])
            break
        else:
            pass

# 构造链表类
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None

def node(l1, l2):
    length1, length2 = 0, 0
    # 求两个链表长度
    while l1.next:
        l1 = l1.next#尾节点
        length1 += 1
    while l2.next:
        l2 = l2.next#尾节点
        length2 += 1

    #如果相交
    if l1.next == l2.next:
        # 长的链表先走
        if length1 &amp;gt; length2:
            for _ in range(length1 - length2):
                l1 = l1.next
            return l1#返回交点
        else:
            for _ in range(length2 - length1):
                l2 = l2.next
            return l2#返回交点
    # 如果不相交
    else:
        return
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;二分查找&quot;&gt;二分查找&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 二分查找
# 给出一个已经排好序的列表,查找指定元素在列表中的位置
def binary_search(list, item):
    low = 0
    high = len(list) - 1
    while low &amp;lt;= high:
        mid = int((high-low)/2+low) # 避免(high+low)/2溢出
        guess = list[mid]
        if guess &amp;gt; item:
            high = mid - 1
        elif guess &amp;lt; item:
            low = mid + 1
        else:
            return mid
    return None
mylist = [1,3,5,7,9]
print(binary_search(mylist, 3))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;排序&quot;&gt;排序&lt;/h2&gt;

&lt;h3 id=&quot;冒泡排序-on2&quot;&gt;冒泡排序 O(n^2)&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 冒泡排序
def bubble_sort(list):
    if len(list)&amp;gt;2:
        for i in range(len(list)):
            flag=False
            for j in range(1,len(list)):
                if list[j] &amp;lt; list[j-1]:
                    list[j],list[j-1]=list[j-1],list[j] 
                    flag=True
            if flag is False: # 优化
                return list             
    return list
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;选择排序-on2&quot;&gt;选择排序 O(n^2)&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 选择排序
# 找到数组中最小的元素，然后往新数组里追加，时间复杂度O(n^2)
def min_index(list):
    min_index = 0
    min_value = list[min_index]
    for index,value in enumerate(list):
        if value&amp;lt;min_value:
            min_value=value
            min_index=index
    return min_index
def select_sort(list):
    new_list = []
    for i in range(len(list)):
        new_list.append(list.pop(min_index(list)))
        '''等效于
        new_list.append(min(list))
        list.remove(min(list))
        '''
    return new_list

# 方法二
def selectSort(list):
    for i in range(len(list)):
        min_index = i
        for j in range(i+1,len(list)):  # 这个循环会找到值比第i个索引所代表值小的索引
            if list[j] &amp;lt; list[min_index]:
                min_index = j
        list[i] ,list[min_index] = list[min_index], list[i]  # 互换两个索引位置
    return list

# 方法三，更加简便，但是注意和冒泡法进行区分
def selectSort(list):
    for i in range(len(list)):
        for j in range(len(list)-i):
            if list[i] &amp;gt; list[i+j]:
                list[i],list[i+j] = list[i+j],list[i]
    return list
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;快速排序-onlogn&quot;&gt;快速排序 O(n*logn)&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 快排 分片的思想+递归的思想，
# 栈高为O(log(n)),栈长O(n),运行时间为栈高x栈长，O(nlog(n))

def quickSort(list):
    if len(list) &amp;lt; 2:
        return list # 基线条件为空或者只包含一个元素的数组是有序的
    else:
        pivot = list[0] # 递归条件
        less = [i for i in list[1:] if i &amp;lt; pivot]
        greater = [j for j in list[1:] if j &amp;gt;= pivot]
        return quickSort(less) + [pivot] + quickSort(greater)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;插入排序-on2&quot;&gt;插入排序 O(n^2)&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 直接插入排序
# 每一步都将一个待排数据按其大小插入到已经排序的数据中的适当位置，直到全部插入完毕。
def insertSort(list):
    len_ = len(list)
    for i in range(1,len_):  
        for j in range(i):
            if list[i] &amp;lt; list[j]:
                list.insert(j,list[i])  # 首先碰到第一个比自己大的数字，赶紧刹车，停在那，所以选择insert
                list.pop(i+1)  # 因为前面的insert操作，所以后面位数+1，这个位置的数已经insert到前面去了，所以pop弹出
                break
    return list
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;希尔排序--onlogn&quot;&gt;希尔排序  O(nlogn)&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 希尔(Shell)排序又称为缩小增量排序，它是一种插入排序。它是直接插入排序算法的一种威力加强版
def shell_sort(list):
    n = len(list)
    gap = n//2  # 初始步长
    while gap &amp;gt; 0:
        for i in range(gap,n): # 插排
            for j in range(i):
                if list[i]&amp;lt;list[j]:
                    list.insert(j,list[i])
                    list.pop(i+1)
                    break       
        gap = gap//2  # 得到新的步长       
    return list
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;归并排序-onlogn&quot;&gt;归并排序 O(nlogn)&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 归并排序
# 使用分割的办法将这个序列分割成一个个已经排好序的子序列。然后再利用归并的方法将一个个的子序列合并成排序好的序列
def merge(left,right): # 合并的过程
    result = []
    while left and right:
        result.append(left.pop(0) if left[0] &amp;lt;= right[0] else right.pop(0))
    while left:
        result.append(left.pop(0))
    while right:
        result.append(right.pop(0))       
    return result

def mergeSort(list):
    if len(list) &amp;lt; 2:
        return list
    mid_index = len(list)//2
    left = mergeSort(list[:mid_index])  # 递归拆解的过程
    right = mergeSort(list[mid_index:])
    return merge(left,right)  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;堆排序-onlogn&quot;&gt;堆排序 O(nlogn)&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 堆排
def MAX_Heapify(heap,HeapSize,root):#在堆中做结构调整使得父节点的值大于子节点
    left = 2*root + 1
    right = left + 1
    larger = root
    if left &amp;lt; HeapSize and heap[larger] &amp;lt; heap[left]:
        larger = left
    if right &amp;lt; HeapSize and heap[larger] &amp;lt; heap[right]:
        larger = right
    if larger != root:#如果做了堆调整则larger的值等于左节点或者右节点的，这个时候做对调值操作
        heap[larger],heap[root] = heap[root],heap[larger]
        MAX_Heapify(heap, HeapSize, larger)

def Build_MAX_Heap(heap):#构造一个堆，将堆中所有数据重新排序
    HeapSize = len(heap)
    for i in range((HeapSize -2)//2,-1,-1):#从后往前出数
        MAX_Heapify(heap,HeapSize,i)

def HeapSort(heap):#将根节点取出与最后一位做对调，对前面len-1个节点继续进行对调整过程。
    Build_MAX_Heap(heap)
    for i in range(len(heap)-1,-1,-1):
        heap[0],heap[i] = heap[i],heap[0]
        MAX_Heapify(heap, i, 0)
    return heap
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;二叉树&quot;&gt;二叉树&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 二叉树节点
class Node(object):
    def __init__(self, value, left=None, right=None):
        self.value = value
        self.left = left
        self.right = right
tree = Node(1,Node(2),Node(3))
tree1 = Node(1, Node(3, Node(7, Node(0)), Node(6)), Node(2, Node(5), Node(4)))

# 深度优先遍历DFS
# 从根节点出发，沿着左子树方向进行纵向遍历，直到找到叶子节点为止。然后回溯到前一个节点，进行右子树节点的遍历，直到遍历完所有可达节点为止。
def dfs(root):
    if not root:
        return
    print(root.value)
    dfs(root.left)
    dfs(root.right)

# 广度优先遍历BFS / 层次遍历
# 从根节点出发，在横向遍历二叉树层段节点的基础上纵向遍历二叉树的层次。
def bfs(root):
    row = [root]
    while row:
        for i in range(len(row)):
            print(row[i].value)
        row = [kid for item in row for kid in (item.left, item.right) if kid]
        

# 中序遍历:遍历左子树,访问当前节点,遍历右子树
def mid_travelsal(root):
    if root.left is not None:
        mid_travelsal(root.left)
    #访问当前节点
    print(root.value)
    if root.right is not None:
        mid_travelsal(root.right)

# 前序遍历:访问当前节点,遍历左子树,遍历右子树
def pre_travelsal(root):
    print (root.value)
    if root.left is not None:
        pre_travelsal(root.left)
    if root.right is not None:
        pre_travelsal(root.right)

# 后序遍历:遍历左子树,遍历右子树,访问当前节点
def post_trvelsal(root):
    if root.left is not None:
        post_trvelsal(root.left)
    if root.right is not None:
        post_trvelsal(root.right)
    print (root.value)

# 最大树深
def maxDepth(root):
        if not root:
            return 0
        return max(maxDepth(root.left), maxDepth(root.right)) + 1

# 判断俩树是否相同
def isSameTree(p, q):
    if p == None and q == None:
        return True
    elif p and q :
        return p.value == q.value and isSameTree(p.left,q.left) and isSameTree(p.right,q.right)
    else :
        return False

# 已知前序中序求后序
def rebuild(pre, center): # 还原二叉树
    if not pre:
        return
    cur = Node(pre[0]) # 前序遍历的第一个值就是根节点
    index = center.index(pre[0]) # 在中序遍历中找到这个值
    cur.left = rebuild(pre[1:index + 1], center[:index]) # 值的左边为左子树部分前序遍历结果
    cur.right = rebuild(pre[index + 1:], center[index + 1:]) # 值的右边为右子树部分前序遍历结果
    return cur
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;判断两个字符串是否是变位词&quot;&gt;判断两个字符串是否是变位词&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Anagram:
    &quot;&quot;&quot;判断两个字符串是否是变位词
    @:param s1: The first string
    @:param s2: The second string
    @:return true or false
    &quot;&quot;&quot;
    def Solution1(s1,s2):
        alist = list(s2)
        pos1 = 0
        stillOK = True
        while pos1 &amp;lt; len(s1) and stillOK:
            pos2 = 0
            found = False
            while pos2 &amp;lt; len(alist) and not found:
                if s1[pos1] == alist[pos2]:
                    found = True
                else:
                    pos2 = pos2 + 1
            if found:
                alist[pos2] = None
            else:
                stillOK = False
            pos1 = pos1 + 1
        return stillOK

    def Solution2(s1,s2):
        alist1 = list(s1)
        alist2 = list(s2)
        alist1.sort()
        alist2.sort()
        pos = 0
        matches = True
        while pos &amp;lt; len(s1) and matches:
            if alist1[pos] == alist2[pos]:
                pos = pos + 1
            else:
                matches = False
        return matches

    def Solution3(s1,s2):
        c1 = [0]*26
        c2 = [0]*26
        for i in range(len(s1)):
            pos = ord(s1[i])-ord('a')
            c1[pos] = c1[pos] + 1
        for i in range(len(s2)):
            pos = ord(s2[i])-ord('a')
            c2[pos] = c2[pos] + 1
        j = 0
        stillOK = True
        while j&amp;lt;26 and stillOK:
            if c1[j] == c2[j]:
                j = j + 1
            else:
                stillOK = False
        return stillOK

print(Anagram.Solution1('abcd','dcba'))
print(Anagram.Solution2('abcde','edcbg'))
print(Anagram.Solution3('apple','pleap'))
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;网络基础&quot;&gt;网络基础&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;TCP/IP分别在模型的哪一层：传输层/网络层&lt;/li&gt;
  &lt;li&gt;socket长连接是什么意思；&lt;/li&gt;
  &lt;li&gt;select和epoll你了解么，区别在哪；&lt;/li&gt;
  &lt;li&gt;TIME_WAIT过多是因为什么；&lt;/li&gt;
  &lt;li&gt;http一次连接的全过程：你来说下从用户发起request——到用户接收到response；&lt;/li&gt;
  &lt;li&gt;http连接方式。get和post的区别，你还了解其他的方式么；&lt;/li&gt;
  &lt;li&gt;状态码你知道多少，比如200/403/404/504等等；&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;三次握手&quot;&gt;三次握手&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;客户端通过向服务器端发送一个SYN来创建一个主动打开，作为三次握手的一部分。客户端把这段连接的序号设定为随机数 A。&lt;/li&gt;
  &lt;li&gt;服务器端应当为一个合法的SYN回送一个SYN/ACK。ACK 的确认码应为 A+1，SYN/ACK 包本身又有一个随机序号 B。&lt;/li&gt;
  &lt;li&gt;最后，客户端再发送一个ACK。当服务端受到这个ACK的时候，就完成了三路握手，并进入了连接创建状态。此时包序号被设定为收到的确认号 A+1，而响应则为 B+1。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;四次挥手&quot;&gt;四次挥手&lt;/h2&gt;

&lt;p&gt;​	&lt;em&gt;以客户端断开连接举例&lt;/em&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;客户端发送一个数据分段, 其中的 FIN 标记设置为1. 客户端进入 FIN-WAIT 状态. 该状态下客户端只接收数据, 不再发送数据.&lt;/li&gt;
  &lt;li&gt;服务器接收到带有 FIN = 1 的数据分段, 发送带有 ACK = 1 的剩余数据分段, 确认收到客户端发来的 FIN 信息.&lt;/li&gt;
  &lt;li&gt;服务器等到所有数据传输结束, 向客户端发送一个带有 FIN = 1 的数据分段, 并进入 CLOSE-WAIT 状态, 等待客户端发来带有 ACK = 1 的确认报文.&lt;/li&gt;
  &lt;li&gt;客户端收到服务器发来带有 FIN = 1 的报文, 返回 ACK = 1 的报文确认, 为了防止服务器端未收到需要重发, 进入 TIME-WAIT 状态. 服务器接收到报文后关闭连接. 客户端等待 2MSL 后未收到回复, 则认为服务器成功关闭, 客户端关闭连接.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;arp协议&quot;&gt;ARP协议&lt;/h2&gt;

&lt;p&gt;地址解析协议(Address Resolution Protocol)，其基本功能为透过目标设备的IP地址，查询目标的MAC地址，以保证通信的顺利进行。它是IPv4网络层必不可少的协议，不过在IPv6中已不再适用，并被邻居发现协议（NDP）所替代。&lt;/p&gt;

&lt;h2 id=&quot;幂等-idempotence&quot;&gt;幂等 Idempotence&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;HTTP方法的幂等性是指一次和多次请求某一个资源应该具有同样的&lt;strong&gt;副作用&lt;/strong&gt;。(注意是副作用)&lt;/p&gt;

  &lt;p&gt;&lt;code&gt;GET http://www.bank.com/account/123456&lt;/code&gt;，不会改变资源的状态，不论调用一次还是N次都没有副作用。请注意，这里强调的是一次和N次具有相同的副作用，而不是每次GET的结果相同。&lt;code&gt;GET http://www.news.com/latest-news&lt;/code&gt;这个HTTP请求可能会每次得到不同的结果，但它本身并没有产生任何副作用，因而是满足幂等性的。&lt;/p&gt;

  &lt;p&gt;DELETE方法用于删除资源，有副作用，但它应该满足幂等性。比如：&lt;code&gt;DELETE http://www.forum.com/article/4231&lt;/code&gt;，调用一次和N次对系统产生的副作用是相同的，即删掉id为4231的帖子；因此，调用者可以多次调用或刷新页面而不必担心引起错误。&lt;/p&gt;

  &lt;p&gt;POST所对应的URI并非创建的资源本身，而是资源的接收者。比如：&lt;code&gt;POST http://www.forum.com/articles&lt;/code&gt;的语义是在&lt;code&gt;http://www.forum.com/articles&lt;/code&gt;下创建一篇帖子，HTTP响应中应包含帖子的创建状态以及帖子的URI。两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI；所以，POST方法不具备幂等性。&lt;/p&gt;

  &lt;p&gt;PUT所对应的URI是要创建或更新的资源本身。比如：&lt;code&gt;PUT http://www.forum/articles/4231&lt;/code&gt;的语义是创建或更新ID为4231的帖子。对同一URI进行多次PUT的副作用和一次PUT是相同的；因此，PUT方法具有幂等性。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;restful架构representational-state-transfer&quot;&gt;RESTful架构(Representational State Transfer)&lt;/h2&gt;

&lt;p&gt;http://www.ruanyifeng.com/blog/2011/09/restful.html&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;每一个URI代表一种资源；&lt;/p&gt;

  &lt;p&gt;客户端和服务器之间，传递这种资源的某种表现层；&lt;/p&gt;

  &lt;p&gt;客户端通过四个HTTP动词 GET、POST、PUT、DELETE，对服务器端资源进行操作，实现”表现层状态转化”。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;RPC -&amp;gt; SOAP -&amp;gt; RESTful&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;数据库&quot;&gt;数据库&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;MySQL锁有几种；死锁是怎么产生的；
    &lt;ul&gt;
      &lt;li&gt;悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作&lt;/li&gt;
      &lt;li&gt;乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;为何，以及如何分区、分表；&lt;/li&gt;
  &lt;li&gt;了解join么，有几种，有何区别，A LEFT JOIN B，查询的结果中，B没有的那部分是如何显示的（NULL）；&lt;/li&gt;
  &lt;li&gt;索引类型有几种，BTree索引和hash索引的区别（我没答上来这俩在磁盘结构上的区别）；&lt;/li&gt;
  &lt;li&gt;手写：如何对查询命令进行优化；&lt;/li&gt;
  &lt;li&gt;NoSQL了解么，和关系数据库的区别；redis有几种常用存储类型；&lt;/li&gt;
  &lt;li&gt;谈谈mysql字符集和排序规则？&lt;/li&gt;
  &lt;li&gt;.varchar与char的区别是什么？大小限制？utf8字符集下varchar最多能存多少个字符&lt;/li&gt;
  &lt;li&gt;外键有什么用，是否该用外键？外键一定需要索引吗？&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;数据库索引&quot;&gt;数据库索引&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.codinglabs.org/articles/theory-of-mysql-index.html&quot;&gt;MySQL索引背后的数据结构及算法原理&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;linux&quot;&gt;Linux&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;讲一下你常用的Linux/git命令和作用；&lt;/li&gt;
  &lt;li&gt;查看当前进程是用什么命令，除了文件相关的操作外，你平时还有什么操作命令；&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;项目&quot;&gt;项目&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;简单的介绍下你在公司的项目，不管是不是后端相关的，主要是要体现出你干了什么；&lt;/li&gt;
  &lt;li&gt;你在项目中遇到最难的部分是什么，你是怎么解决的；&lt;/li&gt;
  &lt;li&gt;你看过django的admin源码么；看过flask的源码么；你如何理解开源；&lt;/li&gt;
  &lt;li&gt;MVC / MTV；&lt;/li&gt;
  &lt;li&gt;缓存怎么用；&lt;/li&gt;
  &lt;li&gt;中间件是干嘛的；&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="python" /><summary type="html">python Interview</summary></entry></feed>