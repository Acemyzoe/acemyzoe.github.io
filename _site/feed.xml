<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="https://acemyzoe.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://acemyzoe.github.io/" rel="alternate" type="text/html" /><updated>2020-10-23T15:49:19+08:00</updated><id>https://acemyzoe.github.io/feed.xml</id><title type="html">Acemyzoe</title><subtitle>人类世界&lt;br/&gt;
真是&lt;br/&gt;
太有趣了&lt;br/&gt;
QAQ&lt;br/&gt;
&lt;a href=&quot;mailto:acemyzoe@outlook.com&quot;&gt;
  &lt;i class=&quot;fas fa-envelope&quot;&gt;&lt;/i&gt;
&lt;/a&gt;
&lt;a href=&quot;https://github.com/acemyzoe&quot;&gt;
  &lt;i class=&quot;fab fa-github&quot;&gt;&lt;/i&gt;
&lt;/a&gt;
&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=100% height=52 src=&quot;//music.163.com/outchain/player?type=2&amp;id=486806&amp;auto=1&amp;height=32&quot;&gt;&lt;/iframe&gt;
</subtitle><entry><title type="html">损失函数&amp;amp;评价指标</title><link href="https://acemyzoe.github.io/_posts/2020-10-20-%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0&%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/" rel="alternate" type="text/html" title="损失函数&amp;评价指标" /><published>2020-10-20T00:00:00+08:00</published><updated>2020-10-20T00:00:00+08:00</updated><id>https://acemyzoe.github.io/_posts/%20%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0&amp;%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87</id><content type="html" xml:base="https://acemyzoe.github.io/_posts/2020-10-20-%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0&amp;%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/">&lt;h1 id=&quot;损失函数&quot;&gt;损失函数&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;损失函数&lt;/strong&gt;用来评价模型的&lt;strong&gt;预测值&lt;/strong&gt;和&lt;strong&gt;真实值&lt;/strong&gt;不一样的程度，损失函数越好，通常模型的性能越好。&lt;/p&gt;

&lt;h2 id=&quot;回归问题&quot;&gt;回归问题&lt;/h2&gt;

&lt;h3 id=&quot;平均损失函数最小二乘法&quot;&gt;平均损失函数（最小二乘法）&lt;/h3&gt;

&lt;p&gt;回归问题中常用的损失函数，在线性回归中，可以通过极大似然估计（MLE）推导。计算的是预测值与真实值之间距离的平方和。实际更常用的是&lt;strong&gt;均方误差（MSE）&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;平均值绝对误差l1损失mae&quot;&gt;平均值绝对误差（L1损失）——MAE&lt;/h3&gt;

&lt;p&gt;MAE是目标值和预测值之差的绝对值之和，可以用来衡量预测值和真实值的距离。&lt;/p&gt;

&lt;h3 id=&quot;mael1损失-vs-msel2损失&quot;&gt;MAE（L1损失） VS MSE（L2损失）&lt;/h3&gt;

&lt;p&gt;MSE计算简便，但MAE对异常点有更好的鲁棒性:当数据中存在异常点时，用RMSE计算损失的模型以牺牲了其他样本的误差为代价，朝着减小异常点误差的方向更新，会降低模型的整体性能。&lt;/p&gt;

&lt;p&gt;NN中MAE更新梯度始终相同，而MSE则不同： MSE损失的梯度随损失增大而增大，而损失趋于0时则会减小。&lt;/p&gt;

&lt;p&gt;使用MAE训练神经网络最大的一个问题就是不变的大梯度，这可能导致在使用梯度下降快要结束时，错过了最小点，为了解决这个缺陷，我们可以使用变化的学习率，在损失接近最小值时降低学习率。而对于MSE，梯度会随着损失的减小而减小，这使得在训练结束时，使用MSE模型的结果会更精确。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Loss选择建议：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;MSE：&lt;/strong&gt; 如果异常点代表在商业中很重要的异常情况，并且需要被检测出来&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;MAE：&lt;/strong&gt; 如果只把异常值当作受损数据&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;huber损失&quot;&gt;Huber损失&lt;/h3&gt;

&lt;p&gt;Huber损失是绝对误差，只是在误差很小时，就变为平方误差。&lt;/p&gt;

&lt;p&gt;当δ&lt;em&gt;很大时，等价为&lt;strong&gt;MSE&lt;/strong&gt;曲线，当&lt;/em&gt;δ很小时，等价为&lt;strong&gt;MAE&lt;/strong&gt;曲线。
\(L_\delta(y,f(x))=\{ {
{1\over2}(y-f(x))^2 \qquad for|y-f(x)|&amp;lt;\delta
\atop 
{\delta|y-f(x)|-{1\over2}\delta^2 \qquad otherwise}
}\)&lt;/p&gt;

&lt;h3 id=&quot;logloss&quot;&gt;LogLoss&lt;/h3&gt;

&lt;p&gt;对数损失(Logarithmic Loss), 即对数似然损失(Log-likelihood Loss), 也称交叉熵损失(cross-entropy Loss)。&lt;/p&gt;

&lt;p&gt;对数损失通过惩罚错误的分类,实现对分类器的准确度(Accuracy)的量化。 最小化对数损失基本等价于最大化分类器的准确度。&lt;/p&gt;

&lt;p&gt;当使用sigmoid作为激活函数的时候，常用&lt;strong&gt;交叉熵损失函数&lt;/strong&gt;而不用&lt;strong&gt;均方误差损失函数&lt;/strong&gt;，因为它可以&lt;strong&gt;完美解决平方损失函数权重更新过慢&lt;/strong&gt;的问题，具有“误差大的时候，权重更新快；误差小的时候，权重更新慢”的良好性质。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;#!/usr/bin/env python
# -*- coding: utf8 -*-
# y_true: list, the true labels of input instances 
# y_pred: list, the probability when the predicted label of input instances equals to 1
def logloss(y_true, y_pred, eps=1e-15):
    import numpy as np

    # Prepare numpy array data
    y_true = np.array(y_true)
    y_pred = np.array(y_pred)
    assert (len(y_true) and len(y_true) == len(y_pred))

    # Clip y_pred between eps and 1-eps
    p = np.clip(y_pred, eps, 1-eps)
    loss = np.sum(- y_true * np.log(p) - (1 - y_true) * np.log(1-p))

    return loss / len(y_true)

def unitest():
    y_true = [0, 0, 1, 1]
    y_pred = [0.1, 0.2, 0.7, 0.99]

    print (&quot;Use self-defined logloss() in binary classification, the result is {}&quot;.format(logloss(y_true, y_pred)))

    from sklearn.metrics import log_loss
    print (&quot;Use log_loss() in scikit-learn, the result is {} &quot;.format(log_loss(y_true, y_pred)))

if __name__ == '__main__':
    unitest()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;exponential-loss&quot;&gt;exponential loss&lt;/h3&gt;

&lt;p&gt;指数损失函数，对离群点、噪声非常敏感。经常用在AdaBoost算法中。&lt;/p&gt;

&lt;h1 id=&quot;评价指标&quot;&gt;评价指标&lt;/h1&gt;

&lt;p&gt;如何评估机器学习算法模型是任何项目中一个非常重要的环节。分类问题一般会选择准确率（Accuracy）或者AUC作为metric，回归问题使用MSE。上述损失函数大部分可以直接作为评价指标来使用。&lt;/p&gt;

&lt;h2 id=&quot;回归问题-1&quot;&gt;回归问题&lt;/h2&gt;

&lt;h3 id=&quot;mse&quot;&gt;MSE&lt;/h3&gt;

&lt;p&gt;均方误差 (Mean Square Error)
\(MSE={1\over n}{\sum^{n}_{i=1}(\hat{y_i} -{y_i})^2}\)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;范围[0,+∞)，当预测值与真实值完全吻合时等于0，即完美模型；误差越大，该值越大。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;rmse&quot;&gt;RMSE&lt;/h3&gt;

&lt;p&gt;均方根误差 (Root Mean Square Error)
\(RMSE=\sqrt {MSE} = \sqrt {\frac{1}{n} \sum_{i=1}^{n} (\hat{y}_i - y_i)^2}\)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;数量级上比较直观，比如RMSE=10，可以认为回归效果相比真实值平均相差10。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;mae&quot;&gt;MAE&lt;/h3&gt;

&lt;p&gt;平均绝对误差(Mean Absolute Error)
\(MAE=\frac{1}{n} \sum_{i=1}^{n} |\hat{y}_i - y_i|\)&lt;/p&gt;

&lt;h3 id=&quot;mape&quot;&gt;MAPE&lt;/h3&gt;

&lt;p&gt;平方绝对百分比误差 (Mean Absolute Percentage Error)
\(MAPE=\frac{100\%}{n}\sum_{i=1}^n |\frac{ \hat{y}_i - y_i }{ y_i }|\)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;当真实值有数据等于0时，存在分母0除问题，该公式不可用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;smape&quot;&gt;SMAPE&lt;/h3&gt;

&lt;p&gt;对称平均绝对百分比误差 (Symmetric Mean Absolute Percentage Error)
\(SMAPE=\frac{100\%}{n}\sum_{i=1}^n \frac{ |\hat{y}_i - y_i| }{ (|\hat{y}_i| + |y_i|)/2 }\)&lt;/p&gt;

&lt;h3 id=&quot;r-squared&quot;&gt;R Squared&lt;/h3&gt;

&lt;p&gt;决定系数 (coefficient of determination)
\(R^2=1-{\frac {\sum _i (\hat y_i-y_i)^2}{\sum _i (\overline y-y_i)^2}}\)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;分母代表baseline（平均值）的误差，分子代表模型的预测结果产生的误差；&lt;/li&gt;
    &lt;li&gt;预测结果越大越好，R为1说明完美拟合， 为0说明和baseline一致；&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;分类问题&quot;&gt;分类问题&lt;/h2&gt;

&lt;h3 id=&quot;confusion-matrix&quot;&gt;Confusion Matrix&lt;/h3&gt;

&lt;p&gt;混淆矩阵，后续多个指标的基础。&lt;/p&gt;

&lt;p&gt;eg. 二类混淆矩阵(训练目的：减少FP、FN)&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;预测正例&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;预测反例&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;真实正例&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;TP 真正例&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;FN 假反例&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;真实反例&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;FP 假反例&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;TN 真反例&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;accuracy&quot;&gt;Accuracy&lt;/h3&gt;

&lt;p&gt;准确率：当样本类别均衡时，Accuracy是一个很好的指标。但在样本不平衡的情况下，产生效果较差。
\(Acc=\frac {TP+TN}{TP+TN+FP+FN}\)&lt;/p&gt;

&lt;h3 id=&quot;precision&quot;&gt;Precision&lt;/h3&gt;

&lt;p&gt;精准率：预测为正例的样本中有多少实际为正。
\(P=\frac {TP}{TP+FP}\)&lt;/p&gt;

&lt;h3 id=&quot;recall&quot;&gt;Recall&lt;/h3&gt;

&lt;p&gt;召回率：实际为正例的样本有多少被预测为正。
\(R=\frac {TP}{TP+FN}\)&lt;/p&gt;

&lt;h3 id=&quot;p-r曲线&quot;&gt;P-R曲线&lt;/h3&gt;

&lt;p&gt;通过选择不同的阈值，得到Recall和Precision，以Recall为横坐标，Precision为纵坐标得到的曲线图。&lt;/p&gt;

&lt;h3 id=&quot;加权调和平均调和平均&quot;&gt;加权调和平均&amp;amp;调和平均&lt;/h3&gt;

&lt;p&gt;beta&amp;gt;1时召回率（Recall）影响更大。&lt;/p&gt;

&lt;p&gt;beta&amp;lt;1时，精确率（Precision）影响更大。
\(F_\beta=\frac{(1+\beta^2)PR}{\beta^2P+R},(\beta=1时)F_1=\frac {2PR}{P+R}\)&lt;/p&gt;

&lt;h3 id=&quot;roc-auc&quot;&gt;ROC-AUC&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Area Under Curve(AUC)&lt;/strong&gt; 是&lt;strong&gt;二分类&lt;/strong&gt;问题中使用非常广泛的一个评价指标。&lt;strong&gt;AUC的本质是，任取一个正样本和负样本，模型输出正样本的值大于负样本值的概率&lt;/strong&gt;。构成AUC的两个基本指标是假正例率和真正例率。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;横轴-假正例率：&lt;/strong&gt; 实际为负的样本多少被预测为正。FPR。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;纵轴-真正例率：&lt;/strong&gt; 实际为正的样本多少被预测为正。TPR。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;TPR和FPR的范围均是[0,1]，通过选择不同的阈值得到TPR和FPR，然后绘制ROC曲线。ROC曲线下的面积为AUC值。&lt;/p&gt;

&lt;h2 id=&quot;代码&quot;&gt;代码&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# coding=utf-8
import numpy as np
from sklearn import metrics
y_true=np.array([1.1,3.3,5.5,7.7])
y_pred=np.array([1.0,3.0,5.0,7.0])

# MSE
def MSE(true, pred):
    return np.sum((true - pred)**2)
mse=metrics.mean_squared_error(y_true,y_pred)
# RMSE
rmse=np.sqrt(mse)
# MAE
def mae(true, pred):
    return np.sum(np.abs(true - pred))
mae=metrics.mean_absolute_error(y_true,y_pred)
# MAPE
mape=np.mean(np.abs(y_pred-y_true)/y_true)*100
#SMPAE
smape=np.mean(2*np.abs(y_pred-y_true)/(np.abs(y_pred)+np.abs(y_true)))*100
# R Squared
RS=metrics.r2_score(y_true,y_pred)
# huber loss
def huber(true, pred, delta):
    loss = np.where(np.abs(true-pred) &amp;lt; delta , 0.5*((true-pred)**2), delta*np.abs(true - pred) - 0.5*(delta**2))
    return np.sum(loss)

y_trues = [1,1,1,1,0,0,1,1,1,0,0]
y_preds = [1,1,1,0,1,1,0,1,1,1,0] 

# ACC准确率
acc=metrics.accuracy_score(y_trues,y_preds)
# Precision精准率
P=metrics.precision_score(y_trues,y_preds)
# Recall召回率
R=metrics.recall_score(y_trues,y_preds)
# F
F=metrics.fbeta_score(y_trues,y_preds,beta=1)
&lt;/code&gt;&lt;/pre&gt;</content><author><name></name></author><category term="ML" /><summary type="html">损失函数</summary></entry><entry><title type="html">Markdown数学公式</title><link href="https://acemyzoe.github.io/_posts/2020-10-18-markdown%E5%85%AC%E5%BC%8F/" rel="alternate" type="text/html" title="Markdown数学公式" /><published>2020-10-18T00:00:00+08:00</published><updated>2020-10-18T00:00:00+08:00</updated><id>https://acemyzoe.github.io/_posts/%20markdown%E5%85%AC%E5%BC%8F</id><content type="html" xml:base="https://acemyzoe.github.io/_posts/2020-10-18-markdown%E5%85%AC%E5%BC%8F/">&lt;h1 id=&quot;markdown数学公式&quot;&gt;Markdown数学公式&lt;/h1&gt;

&lt;h2 id=&quot;上标下标与组合&quot;&gt;上标、下标与组合&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;上标符号，符号：&lt;code&gt;^&lt;/code&gt;，如：$x^4$&lt;/li&gt;
  &lt;li&gt;下标符号，符号：&lt;code&gt;_&lt;/code&gt;，如：$ x_1 $&lt;/li&gt;
  &lt;li&gt;组合符号，符号：&lt;code&gt;{}&lt;/code&gt;，如：${16}&lt;em&gt;{8}O{2+}&lt;/em&gt;{2}$&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;汉字字体与格式&quot;&gt;汉字、字体与格式&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;汉字形式，符号：&lt;code&gt;\mbox{}&lt;/code&gt;，如：$V_{\mbox{初始}}$&lt;/li&gt;
  &lt;li&gt;字体控制，符号：&lt;code&gt;\displaystyle&lt;/code&gt;，如：$\displaystyle \frac{x+y}{y+z}$&lt;/li&gt;
  &lt;li&gt;下划线符号，符号：&lt;code&gt;\underline&lt;/code&gt;，如：$\underline{x+y}$&lt;/li&gt;
  &lt;li&gt;标签，符号&lt;code&gt;\tag{数字}&lt;/code&gt;，如：$\tag{11}$&lt;/li&gt;
  &lt;li&gt;上大括号，符号：&lt;code&gt;\overbrace{算式}&lt;/code&gt;，如：$\overbrace{a+b+c+d}^{2.0}$&lt;/li&gt;
  &lt;li&gt;下大括号，符号：&lt;code&gt;\underbrace{算式}&lt;/code&gt;，如：$a+\underbrace{b+c}_{1.0}+d$&lt;/li&gt;
  &lt;li&gt;上位符号，符号：&lt;code&gt;\stacrel{上位符号}{基位符号}&lt;/code&gt;，如：$\vec{x}\stackrel{\mathrm{def}}{=}{x_1,\dots,x_n}$&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;占位符&quot;&gt;占位符&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;两个quad空格，符号：&lt;code&gt;\qquad&lt;/code&gt;，如：$x \qquad y$&lt;/li&gt;
  &lt;li&gt;quad空格，符号：&lt;code&gt;\quad&lt;/code&gt;，如：$x \quad y$&lt;/li&gt;
  &lt;li&gt;大空格，符号&lt;code&gt;\&lt;/code&gt;，如：$x \  y$&lt;/li&gt;
  &lt;li&gt;中空格，符号&lt;code&gt;\:&lt;/code&gt;，如：$x : y$&lt;/li&gt;
  &lt;li&gt;小空格，符号&lt;code&gt;\,&lt;/code&gt;，如：$x , y$&lt;/li&gt;
  &lt;li&gt;没有空格，符号``，如：$xy$&lt;/li&gt;
  &lt;li&gt;紧贴，符号&lt;code&gt;\!&lt;/code&gt;，如：$x ! y$&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;定界符与组合&quot;&gt;定界符与组合&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;括号，符号：&lt;code&gt;（）\big(\big) \Big(\Big) \bigg(\bigg) \Bigg(\Bigg)&lt;/code&gt;，如：$（）\big(\big) \Big(\Big) \bigg(\bigg) \Bigg(\Bigg)$&lt;/li&gt;
  &lt;li&gt;中括号，符号：&lt;code&gt;[]&lt;/code&gt;，如：$[x+y]$&lt;/li&gt;
  &lt;li&gt;大括号，符号：&lt;code&gt;\{ \}&lt;/code&gt;，如：${x+y}$&lt;/li&gt;
  &lt;li&gt;自适应括号，符号：&lt;code&gt;\left \right&lt;/code&gt;，如：$\left(x\right)$，$\left(x{yz}\right)$&lt;/li&gt;
  &lt;li&gt;组合公式，符号：&lt;code&gt;{上位公式 \choose 下位公式}&lt;/code&gt;，如：${n+1 \choose k}={n \choose k}+{n \choose k-1}$&lt;/li&gt;
  &lt;li&gt;组合公式，符号：&lt;code&gt;{上位公式 \atop 下位公式}&lt;/code&gt;，如：$\sum_{k_0,k_1,\ldots&amp;gt;0 \atop k_0+k_1+\cdots=n}A_{k_0}A_{k_1}\cdots$&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;四则运算&quot;&gt;四则运算&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;加法运算，符号：&lt;code&gt;+&lt;/code&gt;，如：$x+y=z$&lt;/li&gt;
  &lt;li&gt;减法运算，符号：&lt;code&gt;-&lt;/code&gt;，如：$x-y=z$&lt;/li&gt;
  &lt;li&gt;加减运算，符号：&lt;code&gt;\pm&lt;/code&gt;，如：$x \pm y=z$&lt;/li&gt;
  &lt;li&gt;减甲运算，符号：&lt;code&gt;\mp&lt;/code&gt;，如：$x \mp y=z$&lt;/li&gt;
  &lt;li&gt;乘法运算，符号：&lt;code&gt;\times&lt;/code&gt;，如：$x \times y=z$&lt;/li&gt;
  &lt;li&gt;点乘运算，符号：&lt;code&gt;\cdot&lt;/code&gt;，如：$x \cdot y=z$&lt;/li&gt;
  &lt;li&gt;星乘运算，符号：&lt;code&gt;\ast&lt;/code&gt;，如：$x \ast y=z$&lt;/li&gt;
  &lt;li&gt;除法运算，符号：&lt;code&gt;\div&lt;/code&gt;，如：$x \div y=z$&lt;/li&gt;
  &lt;li&gt;斜法运算，符号：&lt;code&gt;/&lt;/code&gt;，如：$x/y=z$&lt;/li&gt;
  &lt;li&gt;分式表示，符号：&lt;code&gt;\frac{分子}{分母}&lt;/code&gt;，如：$\frac{x+y}{y+z}$&lt;/li&gt;
  &lt;li&gt;分式表示，符号：&lt;code&gt;{分子} \voer {分母}&lt;/code&gt;，如：${x+y} \over {y+z}$&lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;绝对值表示，符号：&lt;code&gt;||&lt;/code&gt;，如：$&lt;/td&gt;
          &lt;td&gt;x+y&lt;/td&gt;
          &lt;td&gt;$&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;高级运算&quot;&gt;高级运算&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;平均数运算，符号：&lt;code&gt;\overline{算式}&lt;/code&gt;，如：$\overline{xyz}$&lt;/li&gt;
  &lt;li&gt;开二次方运算，符号：&lt;code&gt;\sqrt&lt;/code&gt;，如：$\sqrt x$&lt;/li&gt;
  &lt;li&gt;开方运算，符号：&lt;code&gt;\sqrt[开方数]{被开方数}&lt;/code&gt;，如：$\sqrt[3]{x+y}$&lt;/li&gt;
  &lt;li&gt;对数运算，符号：&lt;code&gt;\log&lt;/code&gt;，如：$\log(x)$&lt;/li&gt;
  &lt;li&gt;极限运算，符号：&lt;code&gt;\lim&lt;/code&gt;，如：$\lim^{x \to \infty}_{y \to 0}{\frac{x}{y}}$&lt;/li&gt;
  &lt;li&gt;极限运算，符号：&lt;code&gt;\displaystyle \lim&lt;/code&gt;，如：$\displaystyle \lim^{x \to \infty}_{y \to 0}{\frac{x}{y}}$&lt;/li&gt;
  &lt;li&gt;求和运算，符号：&lt;code&gt;\sum&lt;/code&gt;，如：$\sum^{x \to \infty}_{y \to 0}{\frac{x}{y}}$&lt;/li&gt;
  &lt;li&gt;求和运算，符号：&lt;code&gt;\displaystyle \sum&lt;/code&gt;，如：$\displaystyle \sum^{x \to \infty}_{y \to 0}{\frac{x}{y}}$&lt;/li&gt;
  &lt;li&gt;积分运算，符号：&lt;code&gt;\int&lt;/code&gt;，如：$\int^{\infty}_{0}{xdx}$&lt;/li&gt;
  &lt;li&gt;积分运算，符号：&lt;code&gt;\displaystyle \int&lt;/code&gt;，如：$\displaystyle \int^{\infty}_{0}{xdx}$&lt;/li&gt;
  &lt;li&gt;微分运算，符号：&lt;code&gt;\partial&lt;/code&gt;，如：$\frac{\partial x}{\partial y}$&lt;/li&gt;
  &lt;li&gt;矩阵表示，符号：&lt;code&gt;\begin{matrix} \end{matrix}&lt;/code&gt;，如：$\left[ \begin{matrix} 1 &amp;amp;2 &amp;amp;\cdots &amp;amp;4 &amp;amp;5 &amp;amp;6 &amp;amp;\cdots &amp;amp;8\vdots &amp;amp;\vdots &amp;amp;\ddots &amp;amp;\vdots&amp;amp;13 &amp;amp;14 &amp;amp;\cdots &amp;amp;16\end{matrix} \right]$&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;逻辑运算&quot;&gt;逻辑运算&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;等于运算，符号：&lt;code&gt;=&lt;/code&gt;，如：$x+y=z$&lt;/li&gt;
  &lt;li&gt;大于运算，符号：&lt;code&gt;&amp;gt;&lt;/code&gt;，如：$x+y&amp;gt;z$&lt;/li&gt;
  &lt;li&gt;小于运算，符号：&lt;code&gt;&amp;lt;&lt;/code&gt;，如：$x+y&amp;lt;z$&lt;/li&gt;
  &lt;li&gt;大于等于运算，符号：&lt;code&gt;\geq&lt;/code&gt;，如：$x+y \geq z$&lt;/li&gt;
  &lt;li&gt;小于等于运算，符号：&lt;code&gt;\leq&lt;/code&gt;，如：$x+y \leq z$&lt;/li&gt;
  &lt;li&gt;不等于运算，符号：&lt;code&gt;\neq&lt;/code&gt;，如：$x+y \neq z$&lt;/li&gt;
  &lt;li&gt;不大于等于运算，符号：&lt;code&gt;\ngeq&lt;/code&gt;，如：$x+y \ngeq z$&lt;/li&gt;
  &lt;li&gt;不大于等于运算，符号：&lt;code&gt;\not\geq&lt;/code&gt;，如：$x+y \not\geq z$&lt;/li&gt;
  &lt;li&gt;不小于等于运算，符号：&lt;code&gt;\nleq&lt;/code&gt;，如：$x+y \nleq z$&lt;/li&gt;
  &lt;li&gt;不小于等于运算，符号：&lt;code&gt;\not\leq&lt;/code&gt;，如：$x+y \not\leq z$&lt;/li&gt;
  &lt;li&gt;约等于运算，符号：&lt;code&gt;\approx&lt;/code&gt;，如：$x+y \approx z$&lt;/li&gt;
  &lt;li&gt;恒定等于运算，符号：&lt;code&gt;\equiv&lt;/code&gt;，如：$x+y \equiv z$&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;集合运算&quot;&gt;集合运算&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;属于运算，符号：&lt;code&gt;\in&lt;/code&gt;，如：$x \in y$&lt;/li&gt;
  &lt;li&gt;不属于运算，符号：&lt;code&gt;\notin&lt;/code&gt;，如：$x \notin y$&lt;/li&gt;
  &lt;li&gt;不属于运算，符号：&lt;code&gt;\not\in&lt;/code&gt;，如：$x \not\in y$&lt;/li&gt;
  &lt;li&gt;子集运算，符号：&lt;code&gt;\subset&lt;/code&gt;，如：$x \subset y$&lt;/li&gt;
  &lt;li&gt;子集运算，符号：&lt;code&gt;\supset&lt;/code&gt;，如：$x \supset y$&lt;/li&gt;
  &lt;li&gt;真子集运算，符号：&lt;code&gt;\subseteq&lt;/code&gt;，如：$x \subseteq y$&lt;/li&gt;
  &lt;li&gt;非真子集运算，符号：&lt;code&gt;\subsetneq&lt;/code&gt;，如：$x \subsetneq y$&lt;/li&gt;
  &lt;li&gt;真子集运算，符号：&lt;code&gt;\supseteq&lt;/code&gt;，如：$x \supseteq y$&lt;/li&gt;
  &lt;li&gt;非真子集运算，符号：&lt;code&gt;\supsetneq&lt;/code&gt;，如：$x \supsetneq y$&lt;/li&gt;
  &lt;li&gt;非子集运算，符号：&lt;code&gt;\not\subset&lt;/code&gt;，如：$x \not\subset y$&lt;/li&gt;
  &lt;li&gt;非子集运算，符号：&lt;code&gt;\not\supset&lt;/code&gt;，如：$x \not\supset y$&lt;/li&gt;
  &lt;li&gt;并集运算，符号：&lt;code&gt;\cup&lt;/code&gt;，如：$x \cup y$&lt;/li&gt;
  &lt;li&gt;交集运算，符号：&lt;code&gt;\cap&lt;/code&gt;，如：$x \cap y$&lt;/li&gt;
  &lt;li&gt;差集运算，符号：&lt;code&gt;\setminus&lt;/code&gt;，如：$x \setminus y$&lt;/li&gt;
  &lt;li&gt;同或运算，符号：&lt;code&gt;\bigodot&lt;/code&gt;，如：$x \bigodot y$&lt;/li&gt;
  &lt;li&gt;同与运算，符号：&lt;code&gt;\bigotimes&lt;/code&gt;，如：$x \bigotimes y$&lt;/li&gt;
  &lt;li&gt;实数集合，符号：&lt;code&gt;\mathbb{R}&lt;/code&gt;，如：&lt;code&gt;\mathbb{R}&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;自然数集合，符号：&lt;code&gt;\mathbb{Z}&lt;/code&gt;，如：&lt;code&gt;\mathbb{Z}&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;空集，符号：&lt;code&gt;\emptyset&lt;/code&gt;，如：$\emptyset$&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;数学符号&quot;&gt;数学符号&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;无穷，符号：&lt;code&gt;\infty&lt;/code&gt;，如：$\infty$&lt;/li&gt;
  &lt;li&gt;虚数，符号：&lt;code&gt;\imath&lt;/code&gt;，如：$\imath$&lt;/li&gt;
  &lt;li&gt;虚数，符号：&lt;code&gt;\jmath&lt;/code&gt;，如：$\jmath$&lt;/li&gt;
  &lt;li&gt;数学符号，符号&lt;code&gt;\hat{a}&lt;/code&gt;，如：$\hat{a}$&lt;/li&gt;
  &lt;li&gt;数学符号，符号&lt;code&gt;\check{a}&lt;/code&gt;，如：$\check{a}$&lt;/li&gt;
  &lt;li&gt;数学符号，符号&lt;code&gt;\breve{a}&lt;/code&gt;，如：$\breve{a}$&lt;/li&gt;
  &lt;li&gt;数学符号，符号&lt;code&gt;\tilde{a}&lt;/code&gt;，如：$\tilde{a}$&lt;/li&gt;
  &lt;li&gt;数学符号，符号&lt;code&gt;\bar{a}&lt;/code&gt;，如：$\bar{a}$&lt;/li&gt;
  &lt;li&gt;矢量符号，符号&lt;code&gt;\vec{a}&lt;/code&gt;，如：$\vec{a}$&lt;/li&gt;
  &lt;li&gt;数学符号，符号&lt;code&gt;\acute{a}&lt;/code&gt;，如：$\acute{a}$&lt;/li&gt;
  &lt;li&gt;数学符号，符号&lt;code&gt;\grave{a}&lt;/code&gt;，如：$\grave{a}$&lt;/li&gt;
  &lt;li&gt;数学符号，符号&lt;code&gt;\mathring{a}&lt;/code&gt;，如：$\mathring{a}$&lt;/li&gt;
  &lt;li&gt;一阶导数符号，符号&lt;code&gt;\dot{a}&lt;/code&gt;，如：$\dot{a}$&lt;/li&gt;
  &lt;li&gt;二阶导数符号，符号&lt;code&gt;\ddot{a}&lt;/code&gt;，如：$\ddot{a}$&lt;/li&gt;
  &lt;li&gt;上箭头，符号：&lt;code&gt;\uparrow&lt;/code&gt;，如：$\uparrow$&lt;/li&gt;
  &lt;li&gt;上箭头，符号：&lt;code&gt;\Uparrow&lt;/code&gt;，如：$\Uparrow$&lt;/li&gt;
  &lt;li&gt;下箭头，符号：&lt;code&gt;\downarrow&lt;/code&gt;，如：$\downarrow$&lt;/li&gt;
  &lt;li&gt;下箭头，符号：&lt;code&gt;\Downarrow&lt;/code&gt;，如：$\Downarrow$&lt;/li&gt;
  &lt;li&gt;左箭头，符号：&lt;code&gt;\leftarrow&lt;/code&gt;，如：$\leftarrow$&lt;/li&gt;
  &lt;li&gt;左箭头，符号：&lt;code&gt;\Leftarrow&lt;/code&gt;，如：$\Leftarrow$&lt;/li&gt;
  &lt;li&gt;右箭头，符号：&lt;code&gt;\rightarrow&lt;/code&gt;，如：$\rightarrow$&lt;/li&gt;
  &lt;li&gt;右箭头，符号：&lt;code&gt;\Rightarrow&lt;/code&gt;，如：$\Rightarrow$&lt;/li&gt;
  &lt;li&gt;底端对齐的省略号，符号：&lt;code&gt;\ldots&lt;/code&gt;，如：$1,2,\ldots,n$&lt;/li&gt;
  &lt;li&gt;中线对齐的省略号，符号：&lt;code&gt;\cdots&lt;/code&gt;，如：$x_1^2 + x_2^2 + \cdots + x_n^2$&lt;/li&gt;
  &lt;li&gt;竖直对齐的省略号，符号：&lt;code&gt;\vdots&lt;/code&gt;，如：$\vdots$&lt;/li&gt;
  &lt;li&gt;斜对齐的省略号，符号：&lt;code&gt;\ddots&lt;/code&gt;，如：$\ddots$&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;希腊字母&quot;&gt;希腊字母&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;字母&lt;/th&gt;
      &lt;th&gt;实现&lt;/th&gt;
      &lt;th&gt;字母&lt;/th&gt;
      &lt;th&gt;实现&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;A&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;A&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;α&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\alhpa&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;B&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;B&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;β&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\beta&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Γ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\Gamma&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;γ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\gamma&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Δ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\Delta&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;δ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\delta&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;E&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;E&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;ϵ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\epsilon&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Z&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;Z&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;ζ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\zeta&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;H&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;H&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;η&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\eta&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Θ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\Theta&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;θ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\theta&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;I&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;I&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;ι&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\iota&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;K&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;K&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;κ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\kappa&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Λ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\Lambda&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;λ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\lambda&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;M&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;M&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;μ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\mu&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;N&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;N&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;ν&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\nu&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ξ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\Xi&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;ξ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\xi&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;O&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;O&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;ο&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\omicron&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Π&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\Pi&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;π&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\pi&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;P&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;P&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;ρ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\rho&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Σ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\Sigma&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;σ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\sigma&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;T&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;T&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;τ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\tau&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Υ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\Upsilon&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;υ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\upsilon&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Φ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\Phi&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;ϕ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\phi&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;X&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;X&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;χ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\chi&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ψ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\Psi&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;ψ&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\psi&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ω&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\v&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;ω&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;\omega&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name></name></author><category term="wiki" /><summary type="html">Markdown数学公式</summary></entry><entry><title type="html">celery</title><link href="https://acemyzoe.github.io/_posts/2020-08-20-celery/" rel="alternate" type="text/html" title="celery" /><published>2020-08-20T00:00:00+08:00</published><updated>2020-08-20T00:00:00+08:00</updated><id>https://acemyzoe.github.io/_posts/celery</id><content type="html" xml:base="https://acemyzoe.github.io/_posts/2020-08-20-celery/">&lt;h1 id=&quot;celery&quot;&gt;Celery&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://www.celerycn.io/&quot;&gt;Celery 中文手册&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Celery 分布式任务队列，可用于处理实时数据以及任务调度。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;选择并且安装一个消息中间件（Broker）&lt;/li&gt;
  &lt;li&gt;安装 Celery 并且创建第一个任务&lt;/li&gt;
  &lt;li&gt;运行职程（Worker）以及调用任务&lt;/li&gt;
  &lt;li&gt;跟踪任务的情况以及返回值&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用 Redis 作为中间人（Broker）必须要安装 Celery 的依赖库&lt;/p&gt;</content><author><name></name></author><category term="python" /><summary type="html">Celery</summary></entry><entry><title type="html">python-QA</title><link href="https://acemyzoe.github.io/_posts/2020-08-18-python-QA/" rel="alternate" type="text/html" title="python-QA" /><published>2020-08-18T00:00:00+08:00</published><updated>2020-08-18T00:00:00+08:00</updated><id>https://acemyzoe.github.io/_posts/python-QA</id><content type="html" xml:base="https://acemyzoe.github.io/_posts/2020-08-18-python-QA/">&lt;h1 id=&quot;python-interview&quot;&gt;python Interview&lt;/h1&gt;

&lt;p&gt;Python基本功和基本原理，重点考察运算符、装饰器、生成器的原理和实现，垃圾回收机制、各种数据类型，以及线程、进程、协程的概念和应用。&lt;/p&gt;

&lt;p&gt;计算机基础，重点考察数据结构（链表、哈希、堆栈、二叉树）和算法分析（时间复杂度分析）&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;这两个参数是什么意思：*args，**kwargs？我们为什么要使用它们？&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;如果我们不确定往一个函数中传入多少参数，或者我们希望以元组（tuple）或者列表（list）的形式传参数的时候，我们可以使用*args（单星号）。如果我们不知道往函数中传递多少个关键词参数或者想传入字典的值作为关键词参数的时候我们可以使用**kwargs（双星号），args、kwargs两个标识符是约定俗成的用法。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;谈一谈Python的装饰器（decorator）&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;装饰器本质上是一个Python函数，它可以让其它函数在不作任何变动的情况下增加额外功能，装饰器的返回值也是一个函数对象。它经常用于有切面需求的场景。比如：插入日志、性能测试、事务处理、缓存、权限校验等。有了装饰器我们就可以抽离出大量的与函数功能无关的雷同代码进行重用。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;简要描述Python的垃圾回收机制（garbage collection）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Python多线程（multi-threading）。这是个好主意吗？&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;说明&lt;strong&gt;os,sys&lt;/strong&gt;模块不同，并列举常用的模块方法？&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;什么是lambda表达式？它有什么好处？&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Python中pass语句的作用是什么？&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Python是如何进行类型转换的？&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Python里面如何拷贝一个对象？&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;__new__&lt;/code&gt;和&lt;code&gt;__init__&lt;/code&gt;的区别。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Python中单下划线和双下划线分别是什么？&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;说一说Python自省。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如何反序迭代一个序列？&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如何用Python来进行查询和替换一个文本字符串？&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用Python实现单例模式。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;重新实现str.strip()，注意不能使用string.*strip()&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;super&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Python的函数参数传递&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;strong&gt;Python&lt;/strong&gt;中&lt;strong&gt;string、tuple、number&lt;/strong&gt;属于不可更改对象，而&lt;strong&gt;list&lt;/strong&gt;和&lt;strong&gt;dict&lt;/strong&gt;属于可修改对象。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;类变量和实例变量&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Python在函数式编程方面的支持。&lt;strong&gt;lambda&lt;/strong&gt;表达式\内建函数：&lt;strong&gt;filter()、reduce()、map()&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;试图访问一个列表的以超出列表成员数作为开始索引的切片将不会导致&lt;strong&gt;IndexError&lt;/strong&gt;，并且仅仅返回一个空&lt;strong&gt;list&lt;/strong&gt;&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;templist = [1,2,3,4,5]
print(temolist[10:])
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;late binding&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;def testfun():
    temp = [lambda x: i*x for i in range(4)]
    return temp
  
for lb in testfun():
    print(lb(2))
  
def testfun():
    temp = [lambda x,i=i : i*x for i in range(4)]
    return temp
  
for lb in testfun():
    print(lb(2))
      
def testfun():
    return (lambda x: i*x for i in range(4))
  
for lb in testfun():
    print(lb(2))
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;笔试试题“一个芬兰人进了一个房间，房间有一排椅子，椅子上有一些人坐着，还剩一些空位，他要选择一个位子坐下，这个位子要尽可能远离已经坐着的人，请给出算法。请自行定义数据结构和输入输出。”&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;import unittest
# 分析空位情况：1,首位有人；2，尾位有人；3中间占人
# 输入：空位列表 输出：结果位置和最大距离
# 1.输入：list=[1,0,0,0] 输出：[3],3
# 2.输入：list=[0,0,0,1] 输出：[0],3
# 3.输入：list=[1,0,0,0,1,0,1] 输出：[2],2
# 4.输入：list=[1,0,0,1,0] 输出:[1,2,4],1
  
class Testlist(unittest.TestCase):
  
    def test_case1(self):
        list=[1,0,0,0]
        self.assertEqual(solution(list),([3], 3))
      
    def test_case2(self):
        list=[0,0,0,1]
        self.assertEqual(solution(list), ([0], 3))
  
    def test_case3(self):
        list=[1,0,0,0,1,0,1]
        self.assertEqual(solution(list), ([2], 2))
  
    def test_case4(self):
        list=[1,0,0,1,0]
        self.assertEqual(solution(list), ([1,2,4], 1))
  
def solution(seats):
    &quot;&quot;&quot;
    seats: List[int]
    return: ans[int],int
    &quot;&quot;&quot;
    persons = [p for p, seat in enumerate(seats) if seat == 1]
    nullseat = [p for p, seat in enumerate(seats) if seat == 0]
    maxdict = max(persons[0], 
              len(seats)-1-persons[-1], 
              max([(persons[r]-persons[r-1])//2 for r in range(1, len(persons))]+[0]))
    ans=[]
    for i in nullseat:
        if min([abs(i-j) for j in persons])==maxdict:
           ans.append(i) 
    return ans,maxdict
  
if __name__ == '__main__':
    unittest.main()
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="python" /><summary type="html">python Interview</summary></entry><entry><title type="html">苏菲的世界</title><link href="https://acemyzoe.github.io/_posts/2020-08-15-%E8%8B%8F%E8%8F%B2%E7%9A%84%E4%B8%96%E7%95%8C-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" rel="alternate" type="text/html" title="苏菲的世界" /><published>2020-08-15T00:00:00+08:00</published><updated>2020-08-15T00:00:00+08:00</updated><id>https://acemyzoe.github.io/_posts/%E3%80%8A%E8%8B%8F%E8%8F%B2%E7%9A%84%E4%B8%96%E7%95%8C%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0</id><content type="html" xml:base="https://acemyzoe.github.io/_posts/2020-08-15-%E8%8B%8F%E8%8F%B2%E7%9A%84%E4%B8%96%E7%95%8C-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">&lt;h1 id=&quot;伊甸园&quot;&gt;伊甸园&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;我是谁？&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;唯有清晰地意识到有一天她终将死去，她才能体会活在世上是多么美好。&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;blockquote&gt;
      &lt;p&gt;“小小玛丽来到人间，惊鸿一瞥魂归高天。”&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;世界从何而来？&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;在某一时刻，事物必然曾经从无到有。然而，这可能吗？这不就和世界一直存在的看法一样不可思议吗？&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;魔术师的礼帽&quot;&gt;魔术师的礼帽&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;要成为一个优秀的哲学家只有一个条件：要有好奇心……&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;探讨哲学最好的方式就是问一些哲学性的问题，如：这世界是如何创造出来的?其背后是否有某种意志或意义?人死后还有生命吗?我们如何能够解答这些问题呢?最重要的是，我们应该如何生活?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;生命是一种很庞大的、神秘的存在。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;神话&quot;&gt;神话&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;人们总是想为大自然的变迁寻求解释。这就是他们何以在科学还没有产生之前会编造出那些神话故事的原因。&lt;/p&gt;

  &lt;p&gt;从神话的思考模式发展到以经验与理性为基础的思考模式。&lt;/p&gt;

  &lt;p&gt;早期希腊哲学家的目标乃是为大自然的变化寻找自然的——而非超自然的——解释。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;自然派哲学家&quot;&gt;自然派哲学家&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;万事万物是否由一种基本的物质组成？&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;最早的希腊哲学家有时被称为“自然派哲学家”，因为他们关切的主题是大自然与它的循环与变化。&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;blockquote&gt;
      &lt;p&gt;没有任何事物会来自虚无这三位米雷特斯的哲学家都相信，宇宙间有一种基本物质是所有事物的源头。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;帕梅尼德斯：
    &lt;ul&gt;
      &lt;li&gt;“没有任何事物会来自虚无。”没有任何事物会改变。&lt;/li&gt;
      &lt;li&gt;“感官幻象”-“理性主义”&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;赫拉克利特斯：
    &lt;ul&gt;
      &lt;li&gt;“所有事物都是流动的。”因此我们不可能“在同一条河流中涉水两次”。&lt;/li&gt;
      &lt;li&gt;世间的事物是相对的。&lt;/li&gt;
      &lt;li&gt;普遍的理性&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;恩培窦可里斯：
    &lt;ul&gt;
      &lt;li&gt;四种基本元素：土、气、火、水&lt;/li&gt;
      &lt;li&gt;两种力量：爱使事物聚合，而恨则使他们分散。&lt;/li&gt;
      &lt;li&gt;将物质与力量分开。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;安纳塞格拉斯：
    &lt;ul&gt;
      &lt;li&gt;大自然是由无数肉眼看不见的微小粒子所组成，而所有事物都可以被分割成更小的部分。然而，即使是在最小的部分中也有其他每种事物的成分存在。&lt;/li&gt;
      &lt;li&gt;整体存在于每一个微小的部分中。&lt;/li&gt;
      &lt;li&gt;天文学：太阳的本质、月亮的光、日蚀。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;哲学不是一般人能够学到的，但也许我们可以学习如何以哲学的方式思考。&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name></name></author><category term="阅读" /><summary type="html">伊甸园</summary></entry><entry><title type="html">java基础语法</title><link href="https://acemyzoe.github.io/_posts/2020-08-01-java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/" rel="alternate" type="text/html" title="java基础语法" /><published>2020-08-01T00:00:00+08:00</published><updated>2020-08-01T00:00:00+08:00</updated><id>https://acemyzoe.github.io/_posts/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95</id><content type="html" xml:base="https://acemyzoe.github.io/_posts/2020-08-01-java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/">&lt;h1 id=&quot;java语法&quot;&gt;JAVA语法&lt;/h1&gt;

&lt;h2 id=&quot;hello-world&quot;&gt;hello world&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;在 Java 中，所有的代码都必须写在类里面，定义一个 HelloWorld 类。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;/* hello world demo */
public class HelloWorld{
    public static void main(String []args){
        System.out.println(&quot;Hello World!&quot;); // 打印
    }
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;基本数据类型&quot;&gt;基本数据类型&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;整型类型：byte（字节）、short（短整型）、int（整型）、long（长整型）&lt;/li&gt;
  &lt;li&gt;浮点类型：float（单精度浮点）、double（双精度浮点）&lt;/li&gt;
  &lt;li&gt;字符型：char&lt;/li&gt;
  &lt;li&gt;布尔型：boolean&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;封装这些基本数据类型的类&quot;&gt;封装这些基本数据类型的类&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Integer：对应封装了基本类型 int&lt;/li&gt;
  &lt;li&gt;Long：对应封装了基本类型 long&lt;/li&gt;
  &lt;li&gt;Float：对应封装了基本类型 float&lt;/li&gt;
  &lt;li&gt;Double：对应封装了基本类型 double&lt;/li&gt;
  &lt;li&gt;Boolean：对应封装了基本类型 boolean&lt;/li&gt;
  &lt;li&gt;String：对应封装了字符串类型 char[]&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;int a = 6;
Integer oa = new Integer(6);
int a[] = new int[10]; //定义长度为10的int类型数组
a[1] = 3;
System.out.println(a[2])
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;流程控制&quot;&gt;流程控制&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;/* if-else */
int a;
if (a&amp;gt;1){
    //todo
} else if (a=1){
    //todo
} else{
    //todo
}

/* switch-case */
switch (a) {
    case 1:
        //todo
        break;
    case 2:
        //todo
        break;
    default:
        //default
}

/*  for/while */
for (int i = 0; i &amp;lt; 10; ++i) {
    if(i==4){
        continue;//跳出本次循环
    }
    if(i==3){
        break;//提前终止循环
    }
}

while (i&amp;lt;10) {
    //todo
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;类对象&quot;&gt;类、对象&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class Dog {
    private int age;
    private int weight;
    
    public Dog(int age,int weight){//构造函数，命名同类名
        this.age=age;
        this.weight=weight;
    }
    
    public int getAge(){
        return age;
    }
    
    public void run(){
        //todo
    }
}

Dog dog1 = new Dog(2,111); //通过new创建一个Dog对象
int age = dog1.getAge();
dog1.run();
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;权限修饰符&quot;&gt;权限修饰符&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;private 修饰的函数或者成员变量，只能在类内部使用。&lt;/li&gt;
  &lt;li&gt;protected 修饰的函数或者成员变量，可以在类及其子类内使用。&lt;/li&gt;
  &lt;li&gt;public 修饰的函数或者成员变量，可以被任意访问。&lt;/li&gt;
  &lt;li&gt;权限修饰符还可以修饰类&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;继承&quot;&gt;继承&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Java 语言使用 extends 关键字来实现继承&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class Animal {//父类
    protected int age;//protected
    protected int weight;
    
    public Animal(int age,int weight){
        this.age=age;
        this.weight=weight;
    }
    
    public int getAge(){
        return age;
    }
}

public class Dog extends Animal {//子类
    public Dog(int age,int weight){
        super(age,weight);//调用父类的构造函数
    }
    
    public void wang(){
        //...
    }
}

Dog dog1 = new Dog(2,22);
dog1.run();
dog1.wang();
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;接口&quot;&gt;接口&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Java 语言通过 interface 关键字来定义接口。&lt;/p&gt;

  &lt;p&gt;接口中只能声明方法，不能包含实现，也不能定义属性。&lt;/p&gt;

  &lt;p&gt;类通过 implements 关键字来实现接口中定义的方法。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public interface Runable{
    void run();
}

public class Dog implements Runable {
    private int age;
    private int weight;
    
    public Dog(int age,int weight){
        this.age=age;
        this.weight=weight;
    }
    
    public int getAge(){
        return age;
    }
    
    @Override
    public void run(){//实现接口中定义的run方法
        //todo
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;容器&quot;&gt;容器&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;容器可以理解为一些工具类，底层封装了各种数据结构。&lt;/p&gt;

  &lt;p&gt;如 ArrayList 底层就是数组，LinkedList 底层就是链表，HashMap 底层就是散列表等&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class DemoA{
    private ArrayList&amp;lt;User&amp;gt; users;
    public void addUser(User user){
        users.add(user);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;异常处理&quot;&gt;异常处理&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;通过关键字 throw 来抛出一个异常，&lt;/p&gt;

  &lt;p&gt;通过 throws 声明函数抛出异常，&lt;/p&gt;

  &lt;p&gt;通过 try-catch-finally 语句来捕获异常。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class UserNotFoundException extends Exception{//自定义一个异常
    public UserNotFoundException(){
        super();
    }
    public UserNotFoundException(String message){
        super(message);
    }
    public UserNotFoundException(String message,Throwable e){
        super(message,e);
    }
}

public class UserService{
    private UserRepository uerRepo;
    public UserService(UseRepository userRepo){
        this.userRepo = userRepo;
    }
    public User getUserById(long userId) throws UserNotFoundException{
        User user = userRepo.findUserById(userId);
        if (user == null){// throw用来抛出异常
            throw new UserNotFoundException();// 代码从此处返回
        }
    }
}

public class UserController{
    private UserService userService;
    public UserController(UserService userService){
        this.userService = userService;
    }
    public User getUserById(long userId){
        User user = null;
        try{// 捕获异常
            user = userService.getUserById(userId);
        } catch (UserNotFoundException e){
            System.out.println(&quot;User not found: &quot; + userId);
        } finally {// 不管异常会不会发生，finally包裹的语句块总会被执行
            System.out.println(&quot;I am always printed.&quot;);
        }
        return user;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;package包&quot;&gt;package包&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Java 通过 pacakge 关键字来分门别类地组织类，通过 import 关键字来引入类或者package。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;/*class DemoA*/
package com.xzg.cd; // 包名 com.xzg.cd
public class DemoA{
    //...
}
/*class DemoB*/
package com.xzg.alg;
import java.util.HashMap; // Java 工具包JDK中的类
import java.util.Map;
import com.xzg.cd.DemoA;
public class DemoB{
    //...
}
&lt;/code&gt;&lt;/pre&gt;</content><author><name></name></author><category term="java" /><summary type="html">JAVA语法</summary></entry><entry><title type="html">python Interview</title><link href="https://acemyzoe.github.io/_posts/2020-08-01-python-interview/" rel="alternate" type="text/html" title="python Interview" /><published>2020-08-01T00:00:00+08:00</published><updated>2020-08-01T00:00:00+08:00</updated><id>https://acemyzoe.github.io/_posts/python%20interview</id><content type="html" xml:base="https://acemyzoe.github.io/_posts/2020-08-01-python-interview/">&lt;h1 id=&quot;python-interview&quot;&gt;python Interview&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;工作中真正的核心竞争力：写出整洁的代码和架构，面向对象的思维(原则与设计)，模式的使用。以及复杂性解决方法，抽象、分治、领域设计。&lt;/p&gt;

  &lt;p&gt;语言的特性，底层的原理，源码等特定细节的东西可以在使用时再去调研，但解决问题的能力，整洁的代码和架构并不是短期可以突击的。&lt;/p&gt;

  &lt;p&gt;系统：语言Python，Linux基础操作，SQL，消息队列，GIT…木桶理论&lt;/p&gt;

  &lt;p&gt;基础功扎实，新东西学得快，代码写得溜，命令敲得顺，bug解的好&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;基础语法&quot;&gt;基础语法&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;可变与不可变类型&lt;/li&gt;
  &lt;li&gt;浅拷贝与深拷贝的实现方式、区别；deepcopy如果你来设计，如何实现；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;__new__() 与 __init__()&lt;/code&gt;的区别；&lt;/li&gt;
  &lt;li&gt;你知道几种设计模式；&lt;/li&gt;
  &lt;li&gt;编码和解码你了解过么；&lt;/li&gt;
  &lt;li&gt;手写：正则邮箱地址；&lt;/li&gt;
  &lt;li&gt;介绍下垃圾回收：引用计数/分代回收/孤立引用环；&lt;/li&gt;
  &lt;li&gt;多进程与多线程的区别；CPU密集型适合用什么；&lt;/li&gt;
  &lt;li&gt;进程通信的方式有几种；&lt;/li&gt;
  &lt;li&gt;介绍下协程，为何比线程还快；&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;函数参数传递&quot;&gt;函数参数传递&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# Python的函数参数传递
# http://stackoverflow.com/questions/986006/how-do-i-pass-a-variable-by-reference
# 所有的变量都可以理解是内存中一个对象的“引用”

# strings, tuples, 和numbers 不可变对象
a=1
def fun1(a):
    print(id(a),id(1)) # 1798961072 1798961072
    a=2
    print(id(a),id(2)) # 1798961088 1798961088
    print(a) # 2
fun1(a)
print(a) # 1

# list, dict, set 可变对象
b=[]
def fun2(b):
    print(id(b)) # 9174792
    b.append(1)
    print(id(b)) # 9174792
    print(b) #[1]
fun2(b)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;元类&quot;&gt;元类&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 元类 metaclass
# http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python
# 元类是类的类，定义类的行为，常用作类工厂。type是Python用于在幕后创建所有类的元类。
class MyMeta(type):
    '''
        子类将获得一个class属性_order，该属性记录定义类的顺序。
    '''
    counter = 0
    def __init__(cls, name, bases, dic): # name:class名称 bases：父类的元组 dic/attrs：包含属性名称和值的字典
        type.__init__(cls, name, bases, dic)
        cls._order = MyMeta.counter
        MyMeta.counter += 1
class MyType0(metaclass=MyMeta):  
    pass

class MyType1(metaclass=MyMeta):  
    pass

class MyType2(MyMeta):
    pass

print(MyType0._order，MyType1._orderMyType2.counter) # 0 1 2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;类变量和实例变量&quot;&gt;类变量和实例变量&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 类变量和实例变量
class Test(object):  
    num_of_instance = 0  
    name = 'test'
    def __init__(self, name):  
        self.name = name  
        Test.num_of_instance += 1  
  
if __name__ == '__main__':  
    print(Test.name,Test.num_of_instance) # test 0
    t1 = Test('t1')  
    t2 = Test('t2')  
    print(t1.name , t1.num_of_instance) # t1 2
    print(t2.name , t2.num_of_instance) # t2 2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;python自省&quot;&gt;python自省&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 自省
# 运行时能够获得对象的类型.比如type(),dir(),getattr(),hasattr(),isinstance().
a = [1,2,3]
b = {'a':1,'b':2,'c':3}
c = True
print(type(a),type(b),type(c)) # &amp;lt;class 'list'&amp;gt; &amp;lt;class 'dict'&amp;gt; &amp;lt;class 'bool'&amp;gt;
print(isinstance(a,list))  # True
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;推导式&quot;&gt;推导式&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 推导式
# 列表推导式list
li=[i*2 for i in range(10) if i % 2 == 0]
print(li)
# 字典推导式dict
m={&quot;a&quot;:1, &quot;b&quot;:2, &quot;c&quot;:3, &quot;d&quot;:4}
di={v:k for k,v in m.items()}
print(di)
# 集合推导式set
# 集合是一种无重复无序的序列
s={i*2 for i in [1,1,2]}
print(s)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;单下划线和双下划线&quot;&gt;单下划线和双下划线&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 单下划线和双下划线
# http://stackoverflow.com/questions/1301346/the-meaning-of-a-single-and-a-double-underscore-before-an-object-name-in-python
class MyClass():
    def __init__(self):
            self.__superprivate = &quot;Hello&quot;  # 解释器将其替换为对象名._类名__xxx
            self._semiprivate = &quot;, world!&quot; # 用来指定变量私有

my = MyClass()
print(my.__dict__)
print(my._MyClass__superprivate)
print(my._semiprivate)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;迭代器和生成器&quot;&gt;迭代器和生成器&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 迭代器和生成器
# https://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do
# 列表可一一阅读它的项目。逐一读取其项称为迭代,所有值存储在内存。
# 生成器：边循环，边计算的机制—&amp;gt;generator
l = [x*x for x in range(10)] 
g = (x*x for x in range(10))
print(type(l),type(g)) # &amp;lt;class 'list'&amp;gt; &amp;lt;class 'generator'&amp;gt;
# itertools模块包含用于操纵可迭代对象的特殊功能
import itertools
horses=[1,2,3]
races = itertools.permutations(horses)
print(list(races)) # 三匹马比赛的可能到达顺序
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;args-and-kwargs&quot;&gt;*args and **kwargs&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# *args and **kwargs
# https://stackoverflow.com/questions/3394835/use-of-args-and-kwargs
# 用*args传递任意数量的参数
def print_everything(*args):
    for count, thing in enumerate(args):
        print('{0}. {1}'.format(count, thing))
print_everything('1','a')
# **kwargs为函数提供任意关键字参数,并将它们作为字典使用。
def table_things(**kwargs):
    for name, value in kwargs.items():
        print('{0}={1}'.format(name, value))
table_things(apple='fruit', cabbage='vegetable')
# 调用函数时用*和**语法
def print_three_things(a, b, c):
    print('a={0}, b={1}, c={2}'.format(a,b,c))
mylist = ['1', '2', '3']
print_three_things(*mylist)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;面向切面编程aop和装饰器&quot;&gt;面向切面编程AOP和装饰器&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 面向切面编程AOP和装饰器
# 装饰器的作用就是为已经存在的对象添加额外的功能,经常被用于有切面需求的场景
# https://stackoverflow.com/questions/739654/how-to-make-a-chain-of-function-decorators
'''装饰器只是语法糖
@decorator
def func():
    ...
等效于
def func():
    ...
func = decorator(func)
'''
###############################
# The decorator to make it bold
def makebold(fn):
    # The new function the decorator returns
    def wrapper():
        # Insertion of some code before and after
        return &quot;&amp;lt;b&amp;gt;&quot; + fn() + &quot;&amp;lt;/b&amp;gt;&quot;
    return wrapper

# The decorator to make it italic
def makeitalic(fn): 
    return lambda: &quot;&amp;lt;i&amp;gt;&quot; + fn() + &quot;&amp;lt;/i&amp;gt;&quot;

@makebold
@makeitalic
def say():
    return &quot;hello&quot;
print(say())
#################################
# This is the exact equivalent to
def says():
    return &quot;hello&quot;
my = makebold(makeitalic(says))
print(my())

class sty(object):
  def __init__(self, tag):
    self.tag = tag
  def __call__(self, f):
    def newf():
      return &quot;&amp;lt;{tag}&amp;gt;{res}&amp;lt;/{tag}&amp;gt;&quot;.format(res=f(), tag=self.tag)
    return newf

@sty('b')
@sty('i')
def sayhi():
  return 'hi'
print(sayhi())
###################################
# 使用functools.wraps
from functools import wraps
def wrap_in_tag(tag):
    def factory(func):
        @wraps(func)
        def decorator(val):
            return func('&amp;lt;%(tag)s&amp;gt;%(val)s&amp;lt;/%(tag)s&amp;gt;' %
                        {'tag': tag, 'val': val})
        return decorator
    return factory

@wrap_in_tag('b')
@wrap_in_tag('i')
def log(s):
    return s
print(log('hello')) # &amp;lt;b&amp;gt;&amp;lt;i&amp;gt;hello&amp;lt;/i&amp;gt;&amp;lt;/b&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;鸭子类型-duck-typing&quot;&gt;鸭子类型 duck typing&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。&lt;/p&gt;

  &lt;p&gt;一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由”当前方法和属性的集合”决定。&lt;/p&gt;

  &lt;p&gt;鸭子类型是多态性的一种表现，函数可以通过鸭子类型来处理不同类型的对象，函数重载在动态语言中就显得没有意义。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;python不支持函数重载&quot;&gt;Python不支持函数重载&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;函数重载主要是为了解决两个问题。&lt;/p&gt;

  &lt;ol&gt;
    &lt;li&gt;可变参数类型。而 python 可以接受任何类型的参数。&lt;/li&gt;
    &lt;li&gt;可变参数个数。而 python 使用缺省参数。&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;__new__和__init__的区别&quot;&gt;&lt;code&gt;__new__&lt;/code&gt;和&lt;code&gt;__init__&lt;/code&gt;的区别&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;&lt;code&gt;__new__&lt;/code&gt;是一个静态方法,而&lt;code&gt;__init__&lt;/code&gt;是一个实例方法.&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;__new__&lt;/code&gt;方法会返回一个创建的实例,而&lt;code&gt;__init__&lt;/code&gt;什么都不返回.&lt;/li&gt;
    &lt;li&gt;只有在&lt;code&gt;__new__&lt;/code&gt;返回一个cls的实例时后面的&lt;code&gt;__init__&lt;/code&gt;才能被调用.&lt;/li&gt;
    &lt;li&gt;当创建一个新实例时调用&lt;code&gt;__new__&lt;/code&gt;,初始化一个实例时用&lt;code&gt;__init__&lt;/code&gt;.&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;__new__&lt;/code&gt;除非要继承不可变类型（例如str，int，unicode或tuple），否则无需重写&lt;/li&gt;
    &lt;li&gt;可以分别使用&lt;code&gt;__metaclass__&lt;/code&gt;,&lt;code&gt;__new__&lt;/code&gt;和&lt;code&gt;__init__&lt;/code&gt;来分别在类创建,实例创建和实例初始化的时候做一些小手脚.&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;单例模式&quot;&gt;单例模式&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 使用__new__方法
class Singleton(object):
    def __new__(cls, *args, **kw):
        if not hasattr(cls, '_instance'):
            orig = super(Singleton, cls)
            cls._instance = orig.__new__(cls, *args, **kw)
        return cls._instance
class MyClass(Singleton):
    a = 1

# 共享属性:创建实例时把所有实例的__dict__指向同一个字典
class Borg(object):
    _state = {}
    def __new__(cls, *args, **kw):
        ob = super(Borg, cls).__new__(cls, *args, **kw)
        ob.__dict__ = cls._state
        return ob
class MyClass2(Borg):
    a = 1

# 装饰器版本
def singleton(cls):
    instances = {}
    def getinstance(*args, **kw):
        if cls not in instances:
            instances[cls] = cls(*args, **kw)
        return instances[cls]
    return getinstance
@singleton
class MyClass:
    a = 1

# import方法,作为python的模块是天然的单例模式
# mysingleton.py
class My_Singleton(object):
    def foo(self):
        pass
my_singleton = My_Singleton()
# to use
from mysingleton import my_singleton
my_singleton.foo()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;gil线程全局锁global-interpreter-lock&quot;&gt;GIL线程全局锁Global Interpreter Lock&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Python为了保证线程安全而采取的独立线程运行的限制,一个核只能在同一时间运行一个线程。&lt;/p&gt;

  &lt;p&gt;https://www.oschina.net/translate/pythons-hardest-problem&lt;/p&gt;

  &lt;p&gt;对于io密集型任务，python的多线程起到作用，但对于cpu密集型任务，python的多线程几乎占不到任何优势，还有可能因为争夺资源而变慢。&lt;/p&gt;

  &lt;p&gt;解决办法就是多进程和协程。&lt;/p&gt;

  &lt;p&gt;协程是进程和线程的升级版,进程和线程都面临着内核态和用户态的切换问题而耗费许多切换时间,而协程就是用户自己控制切换的时机,不再需要陷入系统的内核态。Python里最常见的yield就是协程的思想&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# yield是与return一样使用的关键字return，不同之处在于该函数将返回生成器。
# 第一次for调用从函数创建的生成器对象时，它将从头开始运行函数中的代码，直到命中yield，然后它将返回循环的第一个值。然后，每个后续调用将运行您在函数中编写的循环的另一个迭代，并返回下一个值。这将一直持续到生成器被认为是空的为止，这在函数运行时没有命中时就会发生yield。
def createGenerator():
    mylist = range(3)
    for i in mylist:
        yield i*i
mygenerator = createGenerator()# 在调用该函数时，在函数主体中编写的代码不会运行。该函数仅返回生成器对象
for i in mygenerator:
    print(i)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;闭包closure&quot;&gt;闭包closure&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 闭包
# https://zhuanlan.zhihu.com/p/22229197
# 在一个内部函数中，对外部作用域的变量进行引用，(并且一般外部函数的返回值为内部函数)
# 闭包作用：函数运行后并不会被撤销，用于保存当前的运行环境
def start(x):
    def increment(y): # 闭包
        return x+y
    return increment
a = start(1)
print(a) # &amp;lt;function start.&amp;lt;locals&amp;gt;.increment at 0x0384CC40&amp;gt;
print(a(1)) # 2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;python函数式编程&quot;&gt;Python函数式编程&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# Python函数式编程
# https://coolshell.cn/articles/10822.html
# lambda匿名函数
a = map(lambda x:x*2,[1,2,3]) # map函数是对一个序列的每个项依次执行函数
print((a))
b = filter(lambda x: x &amp;gt; 5, a) 
# filter函数的功能相当于过滤器。
# 调用一个布尔函数bool_func来迭代遍历每个seq中的元素；返回一个使bool_seq返回值为true的元素的序列
print(list(b))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;python里的拷贝&quot;&gt;Python里的拷贝&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 引用和copy(),deepcopy()的区别
# https://www.geeksforgeeks.org/copy-python-deep-copy-shallow-copy/
import copy
a = [1, 2, 3, 4, ['a', 'b']]  #原始对象

b = a  #赋值，传对象的引用
c = copy.copy(a)  #对象拷贝，浅拷贝
d = copy.deepcopy(a)  #对象拷贝，深拷贝

a.append(5)  #修改对象a
a[4].append('c')  #修改对象a中的['a', 'b']数组对象

print('原始对象a = ',a) # [1, 2, 3, 4, ['a', 'b', 'c'], 5]
print('引用b = ',b) # [1, 2, 3, 4, ['a', 'b', 'c'], 5]
print('浅拷贝c = ',c) # [1, 2, 3, 4, ['a', 'b', 'c']]
print('深拷贝d = ',d) # [1, 2, 3, 4, ['a', 'b']]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;python垃圾回收机制&quot;&gt;Python垃圾回收机制&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# Python垃圾回收机制
# https://sutune.me/2018/10/14/python-GC/
# https://juejin.im/post/6844903629556547598
# http://www.ityouknow.com/python/2020/01/06/python-gc-111.html
# Python GC主要使用引用计数（reference counting）来跟踪和回收垃圾
# 通过“标记-清除”（mark and sweep）解决容器对象可能产生的循环引用问题
# 通过“分代回收”（generation collection）以空间换时间的方法提高垃圾回收效率

# 『引用计数法』的原理是：每个对象维护一个ob_ref字段，用来记录该对象当前被引用的次数，每当新的引用指向该对象时，它的引用计数ob_ref加1，每当该对象的引用失效时计数ob_ref减1，一旦对象的引用计数为0，该对象立即被回收，对象占用的内存空间将被释放。
# 循环引用导致内存泄露。解决方法：gc模块提供一个接口给开发者设置垃圾回收的选项
import sys
import gc
class A():
    def __init__(self):
        '''初始化对象'''
        print('object born id:%s' %str(hex(id(self))))

def func(c):
    print('obejct refcount is: ',sys.getrefcount(c)) #getrefcount()方法用于返回对象的引用计数

def fnrc():
    #生成对象
    a=A()
    func(a)
    #增加引用
    b=a
    func(a)
    #销毁引用对象b
    del b
    func(a)

def fngc():  
    '''垃圾自动回收'''
    gc.isenabled = True  
    print(gc.get_count())
    a=A()
    print(gc.get_count())
    del a
    print(gc.get_count())

if __name__ == '__main__':
    fngc()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;python中list是如何实现的&quot;&gt;Python中list是如何实现的&lt;/h2&gt;

&lt;p&gt;https://www.jianshu.com/p/J4U6rR&lt;/p&gt;

&lt;h2 id=&quot;python的is&quot;&gt;Python的is/==&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# is 与 == 的区别
# https://stackoverflow.com/questions/132988/is-there-a-difference-between-and-is
# https://stackoverflow.com/questions/26595/is-there-any-difference-between-foo-is-none-and-foo-none
a=1000
b=1e3
c=1000.0
print(a is b) # False
print(a is c) # False
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;python2和3的区别&quot;&gt;Python2和3的区别&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/	
from __future__ import division,unicode_literals
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;数据结构算法&quot;&gt;数据结构&amp;amp;算法&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;手写：已知一个长度n的无序列表，元素均是数字，要求把所有间隔为d的组合找出来，你写的解法算法复杂度多少；&lt;/li&gt;
  &lt;li&gt;手写：一个列表A=[A1，A2，…,An]，要求把列表中所有的组合情况打印出来；&lt;/li&gt;
  &lt;li&gt;手写：用一行python写出1+2+3+…+10**8 ；&lt;/li&gt;
  &lt;li&gt;手写python：用递归的方式判断字符串是否为回文；&lt;/li&gt;
  &lt;li&gt;单向链表长度未知，如何判断其中是否有环；&lt;/li&gt;
  &lt;li&gt;单向链表如何使用快速排序算法进行排序；&lt;/li&gt;
  &lt;li&gt;手写：一个长度n的无序数字元素列表，如何求中位数，如何尽快的估算中位数，你的算法复杂度是多少；&lt;/li&gt;
  &lt;li&gt;如何遍历一个内部未知的文件夹（两种树的优先遍历方式）&lt;/li&gt;
  &lt;li&gt;给定一个数组，构建二叉树，并且按层次打印这个二叉树&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;台阶问题斐波那契&quot;&gt;台阶问题/斐波那契&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 方法一
fib = lambda n: n if n&amp;lt;=2 else fib(n-1)+fib(n-2)
# 第二种记忆方法
def memo(func):
    cache = {}
    def wrap(*args):
        if args not in cache:
            cache[args] = func(*args)
        return cache[args]
    return wrap
@memo
def fib(i):
    if i &amp;lt; 2:
        return 1
    return fib(i-1)+fib(i-2)
# 方法三
def fib(n):
    a, b = 0, 1
    for _ in range(n):
        a, b = b, a+b
    return b
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;fib = lambda n: n if n&amp;lt;2 else 2*fib(n-1)
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;用n个&lt;code&gt;2*1&lt;/code&gt;的小矩形无重叠地覆盖一个&lt;code&gt;2*n&lt;/code&gt;的大矩形，总共有多少种方法？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;f = lambda n: 1 if n &amp;lt; 2 else f(n-1) + f(n-2)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;去除列表中的重复元素&quot;&gt;去除列表中的重复元素&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 去除列表中的重复元素
l = [1,1,2,2,3,4]
# 用集合
print(list(set(l)))
# 用字典
print({}.fromkeys(l).keys())
# 列表推导式
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;链表成对调换&quot;&gt;链表成对调换&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4&lt;/code&gt;转换成&lt;code&gt;2-&amp;gt;1-&amp;gt;4-&amp;gt;3&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;合并两个有序列表&quot;&gt;合并两个有序列表&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 尾递归
a = [1,2,3,7]
b = [3,4,5]
def _recursion_merge_sort2(l1, l2, tmp):
    if len(l1) == 0 or len(l2) == 0:
        tmp.extend(l1)
        tmp.extend(l2)
        return tmp
    else:
        if l1[0] &amp;lt; l2[0]:
            tmp.append(l1[0])
            del l1[0]
        else:
            tmp.append(l2[0])
            del l2[0]
        return _recursion_merge_sort2(l1, l2, tmp)
def recursion_merge_sort2(l1, l2):
    return _recursion_merge_sort2(l1, l2, [])
print(recursion_merge_sort2(a,b))

# 循环算法
a = [1,2,3,7]
b = [3,4,5]
def loop_merge_sort(l1, l2):
    tmp = []
    while len(l1) &amp;gt; 0 and len(l2) &amp;gt; 0:
        if l1[0] &amp;lt; l2[0]:
            tmp.append(l1[0])
            del l1[0]
        else:
            tmp.append(l2[0])
            del l2[0]
    tmp.extend(l1)
    tmp.extend(l2)
    return tmp
print(loop_merge_sort(a,b))

# pop弹出
a = [1,2,3,7]
b = [3,4,5]
def merge_sortedlist(a,b):
    c = []
    while a and b:
        if a[0] &amp;gt;= b[0]:
            c.append(b.pop(0))
        else:
            c.append(a.pop(0))
    while a:
        c.append(a.pop(0))
    while b:
        c.append(b.pop(0))
    return c
print(merge_sortedlist(a,b))

# 先合并后排序
a = [1,2,3,7]
b = [3,4,5]
def merge_sort(a,b):
    c=a+b
    c.sort()
    return c
print(merge_sort(a,b))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;python链表&quot;&gt;python链表&lt;/h2&gt;

&lt;p&gt;https://juejin.im/post/6844903672661409800&lt;/p&gt;

&lt;p&gt;https://www.jianshu.com/p/e4000619232b&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 用python中的引用来实现链表
# 节点类
# 功能包括：更新数据，查询数据，更新后继节点和查询后继节点。
class Node(object):
    #初始化，需要传入节点的数据
    def __init__(self, data):
        self.data = data
        self.next = None
    
    #返回节点的数据
    def get_data(self):
        return self.data
    
    #更新节点的数据
    def set_data(self, new_data):
        self.data = new_data
        
    #返回后继节点
    def get_next(self):
        return self.next
    
    #变更后继节点
    def set_next(self, new_next):
        self.next = new_next

# 链表类
# 节点的增加、删除和查询，返回链表的长度，返回链表是否为空等
class Linked_list(object):
    #初始化，头结点为空
    def __init__(self):
        self.head = None
    
    #添加节点，添加的新节点作为新的头结点
    def add(self, data):
        new_node = Node(data)
        new_node.set_next() = self.head
        self.head = new_node
        
    #包含查询，传入值，返回该值在链表中是否存在
    def search(self, data):
        checking = self.head #从头结点开始查询
        while checking != None :
            if checking.get_data() == data: #查找到，返回True
                return True
            checking = checking.get_next() #查询下一个节点
        return False #遍历到最后也未能找到，返回False
        
    #删除节点，将第一个具有传入值的节点从链表中删除
    def remove(self, data):
        checking = self.head #从头结点开始查询
        previous = None #记录前一个节点，头结点的前一个节点为None
        
        while checking != None :
            if checking.get_data() == data: #查找到，跳出查找循环
                break
            previous = checking # 更新前一个节点
            checking = checking.get_next() #查询下一个节点

        if previous == None:# 如果头结点便是查找的节点
            self.head = checking.get_next()
        else: # 查找的节点不在头结点，即，存在前驱节点
            previous.set_next(checking.get_next())       
    
    #判断链表是否为空
    def isEmpty(self):
        return self.head == None
    
    #返回链表长度
    def size(self):
        count = 0
        counting = self.head #从头结点开始计数
        while counting != None :
            count += 1
            counting = counting.get_next()
        return count
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;单链表逆置&quot;&gt;单链表逆置&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Node(object):
    def __init__(self, data=None, next=None):
        self.data = data
        self.next = next

def relink(link):
    pre = link
    cur = link.next
    pre.next = None
    while cur:
        tmp = cur.next
        cur.next = pre
        pre = cur
        cur = tmp
    return pre

link = Node(1, Node(2, Node(3, Node(4))))
root = relink(link)
while root:
    print(root.data)
    root = root.next
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;交叉链表求交点&quot;&gt;交叉链表求交点&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 使用a,b两个list来模拟链表，可以看出交叉点是 7这个节点
a = [1,2,3,7,9,1,5]
b = [4,5,7,9,1,5]
# 从尾开始比较两个链表，如果相交，则从尾开始必然一致，只要从尾开始比较，直至不一致的地方即为交叉点
for i in range(1,min(len(a),len(b))):
    if i==1 and (a[-1] != b[-1]):
        print(&quot;No&quot;)
        break
    else:
        if a[-i] != b[-i]:
            print(&quot;交叉节点：&quot;,a[-i+1])
            break
        else:
            pass

# 构造链表类
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None

def node(l1, l2):
    length1, length2 = 0, 0
    # 求两个链表长度
    while l1.next:
        l1 = l1.next#尾节点
        length1 += 1
    while l2.next:
        l2 = l2.next#尾节点
        length2 += 1

    #如果相交
    if l1.next == l2.next:
        # 长的链表先走
        if length1 &amp;gt; length2:
            for _ in range(length1 - length2):
                l1 = l1.next
            return l1#返回交点
        else:
            for _ in range(length2 - length1):
                l2 = l2.next
            return l2#返回交点
    # 如果不相交
    else:
        return
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;二分查找&quot;&gt;二分查找&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 二分查找
# 给出一个已经排好序的列表,查找指定元素在列表中的位置
def binary_search(list, item):
    low = 0
    high = len(list) - 1
    while low &amp;lt;= high:
        mid = int((high-low)/2+low) # 避免(high+low)/2溢出
        guess = list[mid]
        if guess &amp;gt; item:
            high = mid - 1
        elif guess &amp;lt; item:
            low = mid + 1
        else:
            return mid
    return None
mylist = [1,3,5,7,9]
print(binary_search(mylist, 3))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;排序&quot;&gt;排序&lt;/h2&gt;

&lt;h3 id=&quot;冒泡排序-on2&quot;&gt;冒泡排序 O(n^2)&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 冒泡排序
def bubble_sort(list):
    if len(list)&amp;gt;2:
        for i in range(len(list)):
            flag=False
            for j in range(1,len(list)):
                if list[j] &amp;lt; list[j-1]:
                    list[j],list[j-1]=list[j-1],list[j] 
                    flag=True
            if flag is False: # 优化
                return list             
    return list
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;选择排序-on2&quot;&gt;选择排序 O(n^2)&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 选择排序
# 找到数组中最小的元素，然后往新数组里追加，时间复杂度O(n^2)
def min_index(list):
    min_index = 0
    min_value = list[min_index]
    for index,value in enumerate(list):
        if value&amp;lt;min_value:
            min_value=value
            min_index=index
    return min_index
def select_sort(list):
    new_list = []
    for i in range(len(list)):
        new_list.append(list.pop(min_index(list)))
        '''等效于
        new_list.append(min(list))
        list.remove(min(list))
        '''
    return new_list

# 方法二
def selectSort(list):
    for i in range(len(list)):
        min_index = i
        for j in range(i+1,len(list)):  # 这个循环会找到值比第i个索引所代表值小的索引
            if list[j] &amp;lt; list[min_index]:
                min_index = j
        list[i] ,list[min_index] = list[min_index], list[i]  # 互换两个索引位置
    return list

# 方法三，更加简便，但是注意和冒泡法进行区分
def selectSort(list):
    for i in range(len(list)):
        for j in range(len(list)-i):
            if list[i] &amp;gt; list[i+j]:
                list[i],list[i+j] = list[i+j],list[i]
    return list
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;快速排序-onlogn&quot;&gt;快速排序 O(n*logn)&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 快排 分片的思想+递归的思想，
# 栈高为O(log(n)),栈长O(n),运行时间为栈高x栈长，O(nlog(n))

def quickSort(list):
    if len(list) &amp;lt; 2:
        return list # 基线条件为空或者只包含一个元素的数组是有序的
    else:
        pivot = list[0] # 递归条件
        less = [i for i in list[1:] if i &amp;lt; pivot]
        greater = [j for j in list[1:] if j &amp;gt;= pivot]
        return quickSort(less) + [pivot] + quickSort(greater)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;插入排序-on2&quot;&gt;插入排序 O(n^2)&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 直接插入排序
# 每一步都将一个待排数据按其大小插入到已经排序的数据中的适当位置，直到全部插入完毕。
def insertSort(list):
    len_ = len(list)
    for i in range(1,len_):  
        for j in range(i):
            if list[i] &amp;lt; list[j]:
                list.insert(j,list[i])  # 首先碰到第一个比自己大的数字，赶紧刹车，停在那，所以选择insert
                list.pop(i+1)  # 因为前面的insert操作，所以后面位数+1，这个位置的数已经insert到前面去了，所以pop弹出
                break
    return list
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;希尔排序--onlogn&quot;&gt;希尔排序  O(nlogn)&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 希尔(Shell)排序又称为缩小增量排序，它是一种插入排序。它是直接插入排序算法的一种威力加强版
def shell_sort(list):
    n = len(list)
    gap = n//2  # 初始步长
    while gap &amp;gt; 0:
        for i in range(gap,n): # 插排
            for j in range(i):
                if list[i]&amp;lt;list[j]:
                    list.insert(j,list[i])
                    list.pop(i+1)
                    break       
        gap = gap//2  # 得到新的步长       
    return list
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;归并排序-onlogn&quot;&gt;归并排序 O(nlogn)&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 归并排序
# 使用分割的办法将这个序列分割成一个个已经排好序的子序列。然后再利用归并的方法将一个个的子序列合并成排序好的序列
def merge(left,right): # 合并的过程
    result = []
    while left and right:
        result.append(left.pop(0) if left[0] &amp;lt;= right[0] else right.pop(0))
    while left:
        result.append(left.pop(0))
    while right:
        result.append(right.pop(0))       
    return result

def mergeSort(list):
    if len(list) &amp;lt; 2:
        return list
    mid_index = len(list)//2
    left = mergeSort(list[:mid_index])  # 递归拆解的过程
    right = mergeSort(list[mid_index:])
    return merge(left,right)  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;堆排序-onlogn&quot;&gt;堆排序 O(nlogn)&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 堆排
def MAX_Heapify(heap,HeapSize,root):#在堆中做结构调整使得父节点的值大于子节点
    left = 2*root + 1
    right = left + 1
    larger = root
    if left &amp;lt; HeapSize and heap[larger] &amp;lt; heap[left]:
        larger = left
    if right &amp;lt; HeapSize and heap[larger] &amp;lt; heap[right]:
        larger = right
    if larger != root:#如果做了堆调整则larger的值等于左节点或者右节点的，这个时候做对调值操作
        heap[larger],heap[root] = heap[root],heap[larger]
        MAX_Heapify(heap, HeapSize, larger)

def Build_MAX_Heap(heap):#构造一个堆，将堆中所有数据重新排序
    HeapSize = len(heap)
    for i in range((HeapSize -2)//2,-1,-1):#从后往前出数
        MAX_Heapify(heap,HeapSize,i)

def HeapSort(heap):#将根节点取出与最后一位做对调，对前面len-1个节点继续进行对调整过程。
    Build_MAX_Heap(heap)
    for i in range(len(heap)-1,-1,-1):
        heap[0],heap[i] = heap[i],heap[0]
        MAX_Heapify(heap, i, 0)
    return heap
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;二叉树&quot;&gt;二叉树&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 二叉树节点
class Node(object):
    def __init__(self, value, left=None, right=None):
        self.value = value
        self.left = left
        self.right = right
tree = Node(1,Node(2),Node(3))
tree1 = Node(1, Node(3, Node(7, Node(0)), Node(6)), Node(2, Node(5), Node(4)))

# 深度优先遍历DFS
# 从根节点出发，沿着左子树方向进行纵向遍历，直到找到叶子节点为止。然后回溯到前一个节点，进行右子树节点的遍历，直到遍历完所有可达节点为止。
def dfs(root):
    if not root:
        return
    print(root.value)
    dfs(root.left)
    dfs(root.right)

# 广度优先遍历BFS / 层次遍历
# 从根节点出发，在横向遍历二叉树层段节点的基础上纵向遍历二叉树的层次。
def bfs(root):
    row = [root]
    while row:
        for i in range(len(row)):
            print(row[i].value)
        row = [kid for item in row for kid in (item.left, item.right) if kid]
        

# 中序遍历:遍历左子树,访问当前节点,遍历右子树
def mid_travelsal(root):
    if root.left is not None:
        mid_travelsal(root.left)
    #访问当前节点
    print(root.value)
    if root.right is not None:
        mid_travelsal(root.right)

# 前序遍历:访问当前节点,遍历左子树,遍历右子树
def pre_travelsal(root):
    print (root.value)
    if root.left is not None:
        pre_travelsal(root.left)
    if root.right is not None:
        pre_travelsal(root.right)

# 后序遍历:遍历左子树,遍历右子树,访问当前节点
def post_trvelsal(root):
    if root.left is not None:
        post_trvelsal(root.left)
    if root.right is not None:
        post_trvelsal(root.right)
    print (root.value)

# 最大树深
def maxDepth(root):
        if not root:
            return 0
        return max(maxDepth(root.left), maxDepth(root.right)) + 1

# 判断俩树是否相同
def isSameTree(p, q):
    if p == None and q == None:
        return True
    elif p and q :
        return p.value == q.value and isSameTree(p.left,q.left) and isSameTree(p.right,q.right)
    else :
        return False

# 已知前序中序求后序
def rebuild(pre, center): # 还原二叉树
    if not pre:
        return
    cur = Node(pre[0]) # 前序遍历的第一个值就是根节点
    index = center.index(pre[0]) # 在中序遍历中找到这个值
    cur.left = rebuild(pre[1:index + 1], center[:index]) # 值的左边为左子树部分前序遍历结果
    cur.right = rebuild(pre[index + 1:], center[index + 1:]) # 值的右边为右子树部分前序遍历结果
    return cur
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;判断两个字符串是否是变位词&quot;&gt;判断两个字符串是否是变位词&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Anagram:
    &quot;&quot;&quot;判断两个字符串是否是变位词
    @:param s1: The first string
    @:param s2: The second string
    @:return true or false
    &quot;&quot;&quot;
    def Solution1(s1,s2):
        alist = list(s2)
        pos1 = 0
        stillOK = True
        while pos1 &amp;lt; len(s1) and stillOK:
            pos2 = 0
            found = False
            while pos2 &amp;lt; len(alist) and not found:
                if s1[pos1] == alist[pos2]:
                    found = True
                else:
                    pos2 = pos2 + 1
            if found:
                alist[pos2] = None
            else:
                stillOK = False
            pos1 = pos1 + 1
        return stillOK

    def Solution2(s1,s2):
        alist1 = list(s1)
        alist2 = list(s2)
        alist1.sort()
        alist2.sort()
        pos = 0
        matches = True
        while pos &amp;lt; len(s1) and matches:
            if alist1[pos] == alist2[pos]:
                pos = pos + 1
            else:
                matches = False
        return matches

    def Solution3(s1,s2):
        c1 = [0]*26
        c2 = [0]*26
        for i in range(len(s1)):
            pos = ord(s1[i])-ord('a')
            c1[pos] = c1[pos] + 1
        for i in range(len(s2)):
            pos = ord(s2[i])-ord('a')
            c2[pos] = c2[pos] + 1
        j = 0
        stillOK = True
        while j&amp;lt;26 and stillOK:
            if c1[j] == c2[j]:
                j = j + 1
            else:
                stillOK = False
        return stillOK

print(Anagram.Solution1('abcd','dcba'))
print(Anagram.Solution2('abcde','edcbg'))
print(Anagram.Solution3('apple','pleap'))
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;网络基础&quot;&gt;网络基础&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;TCP/IP分别在模型的哪一层：传输层/网络层&lt;/li&gt;
  &lt;li&gt;socket长连接是什么意思；&lt;/li&gt;
  &lt;li&gt;select和epoll你了解么，区别在哪；&lt;/li&gt;
  &lt;li&gt;TIME_WAIT过多是因为什么；&lt;/li&gt;
  &lt;li&gt;http一次连接的全过程：你来说下从用户发起request——到用户接收到response；&lt;/li&gt;
  &lt;li&gt;http连接方式。get和post的区别，你还了解其他的方式么；&lt;/li&gt;
  &lt;li&gt;状态码你知道多少，比如200/403/404/504等等；&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;三次握手&quot;&gt;三次握手&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;客户端通过向服务器端发送一个SYN来创建一个主动打开，作为三次握手的一部分。客户端把这段连接的序号设定为随机数 A。&lt;/li&gt;
  &lt;li&gt;服务器端应当为一个合法的SYN回送一个SYN/ACK。ACK 的确认码应为 A+1，SYN/ACK 包本身又有一个随机序号 B。&lt;/li&gt;
  &lt;li&gt;最后，客户端再发送一个ACK。当服务端受到这个ACK的时候，就完成了三路握手，并进入了连接创建状态。此时包序号被设定为收到的确认号 A+1，而响应则为 B+1。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;四次挥手&quot;&gt;四次挥手&lt;/h2&gt;

&lt;p&gt;​	&lt;em&gt;以客户端断开连接举例&lt;/em&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;客户端发送一个数据分段, 其中的 FIN 标记设置为1. 客户端进入 FIN-WAIT 状态. 该状态下客户端只接收数据, 不再发送数据.&lt;/li&gt;
  &lt;li&gt;服务器接收到带有 FIN = 1 的数据分段, 发送带有 ACK = 1 的剩余数据分段, 确认收到客户端发来的 FIN 信息.&lt;/li&gt;
  &lt;li&gt;服务器等到所有数据传输结束, 向客户端发送一个带有 FIN = 1 的数据分段, 并进入 CLOSE-WAIT 状态, 等待客户端发来带有 ACK = 1 的确认报文.&lt;/li&gt;
  &lt;li&gt;客户端收到服务器发来带有 FIN = 1 的报文, 返回 ACK = 1 的报文确认, 为了防止服务器端未收到需要重发, 进入 TIME-WAIT 状态. 服务器接收到报文后关闭连接. 客户端等待 2MSL 后未收到回复, 则认为服务器成功关闭, 客户端关闭连接.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;arp协议&quot;&gt;ARP协议&lt;/h2&gt;

&lt;p&gt;地址解析协议(Address Resolution Protocol)，其基本功能为透过目标设备的IP地址，查询目标的MAC地址，以保证通信的顺利进行。它是IPv4网络层必不可少的协议，不过在IPv6中已不再适用，并被邻居发现协议（NDP）所替代。&lt;/p&gt;

&lt;h2 id=&quot;幂等-idempotence&quot;&gt;幂等 Idempotence&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;HTTP方法的幂等性是指一次和多次请求某一个资源应该具有同样的&lt;strong&gt;副作用&lt;/strong&gt;。(注意是副作用)&lt;/p&gt;

  &lt;p&gt;&lt;code&gt;GET http://www.bank.com/account/123456&lt;/code&gt;，不会改变资源的状态，不论调用一次还是N次都没有副作用。请注意，这里强调的是一次和N次具有相同的副作用，而不是每次GET的结果相同。&lt;code&gt;GET http://www.news.com/latest-news&lt;/code&gt;这个HTTP请求可能会每次得到不同的结果，但它本身并没有产生任何副作用，因而是满足幂等性的。&lt;/p&gt;

  &lt;p&gt;DELETE方法用于删除资源，有副作用，但它应该满足幂等性。比如：&lt;code&gt;DELETE http://www.forum.com/article/4231&lt;/code&gt;，调用一次和N次对系统产生的副作用是相同的，即删掉id为4231的帖子；因此，调用者可以多次调用或刷新页面而不必担心引起错误。&lt;/p&gt;

  &lt;p&gt;POST所对应的URI并非创建的资源本身，而是资源的接收者。比如：&lt;code&gt;POST http://www.forum.com/articles&lt;/code&gt;的语义是在&lt;code&gt;http://www.forum.com/articles&lt;/code&gt;下创建一篇帖子，HTTP响应中应包含帖子的创建状态以及帖子的URI。两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI；所以，POST方法不具备幂等性。&lt;/p&gt;

  &lt;p&gt;PUT所对应的URI是要创建或更新的资源本身。比如：&lt;code&gt;PUT http://www.forum/articles/4231&lt;/code&gt;的语义是创建或更新ID为4231的帖子。对同一URI进行多次PUT的副作用和一次PUT是相同的；因此，PUT方法具有幂等性。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;restful架构representational-state-transfer&quot;&gt;RESTful架构(Representational State Transfer)&lt;/h2&gt;

&lt;p&gt;http://www.ruanyifeng.com/blog/2011/09/restful.html&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;每一个URI代表一种资源；&lt;/p&gt;

  &lt;p&gt;客户端和服务器之间，传递这种资源的某种表现层；&lt;/p&gt;

  &lt;p&gt;客户端通过四个HTTP动词 GET、POST、PUT、DELETE，对服务器端资源进行操作，实现”表现层状态转化”。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;RPC -&amp;gt; SOAP -&amp;gt; RESTful&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;数据库&quot;&gt;数据库&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;MySQL锁有几种；死锁是怎么产生的；
    &lt;ul&gt;
      &lt;li&gt;悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作&lt;/li&gt;
      &lt;li&gt;乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;为何，以及如何分区、分表；&lt;/li&gt;
  &lt;li&gt;了解join么，有几种，有何区别，A LEFT JOIN B，查询的结果中，B没有的那部分是如何显示的（NULL）；&lt;/li&gt;
  &lt;li&gt;索引类型有几种，BTree索引和hash索引的区别（我没答上来这俩在磁盘结构上的区别）；&lt;/li&gt;
  &lt;li&gt;手写：如何对查询命令进行优化；&lt;/li&gt;
  &lt;li&gt;NoSQL了解么，和关系数据库的区别；redis有几种常用存储类型；&lt;/li&gt;
  &lt;li&gt;谈谈mysql字符集和排序规则？&lt;/li&gt;
  &lt;li&gt;.varchar与char的区别是什么？大小限制？utf8字符集下varchar最多能存多少个字符&lt;/li&gt;
  &lt;li&gt;外键有什么用，是否该用外键？外键一定需要索引吗？&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;数据库索引&quot;&gt;数据库索引&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.codinglabs.org/articles/theory-of-mysql-index.html&quot;&gt;MySQL索引背后的数据结构及算法原理&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;linux&quot;&gt;Linux&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;讲一下你常用的Linux/git命令和作用；&lt;/li&gt;
  &lt;li&gt;查看当前进程是用什么命令，除了文件相关的操作外，你平时还有什么操作命令；&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;项目&quot;&gt;项目&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;简单的介绍下你在公司的项目，不管是不是后端相关的，主要是要体现出你干了什么；&lt;/li&gt;
  &lt;li&gt;你在项目中遇到最难的部分是什么，你是怎么解决的；&lt;/li&gt;
  &lt;li&gt;你看过django的admin源码么；看过flask的源码么；你如何理解开源；&lt;/li&gt;
  &lt;li&gt;MVC / MTV；&lt;/li&gt;
  &lt;li&gt;缓存怎么用；&lt;/li&gt;
  &lt;li&gt;中间件是干嘛的；&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="python" /><summary type="html">python Interview</summary></entry><entry><title type="html">设计模式</title><link href="https://acemyzoe.github.io/_posts/2020-08-01-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="alternate" type="text/html" title="设计模式" /><published>2020-08-01T00:00:00+08:00</published><updated>2020-08-01T00:00:00+08:00</updated><id>https://acemyzoe.github.io/_posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F</id><content type="html" xml:base="https://acemyzoe.github.io/_posts/2020-08-01-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">&lt;blockquote&gt;
  &lt;p&gt;奥卡姆剃刀 ： 如无必要，勿增实体&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;目的：告别写被人吐槽的烂代码，提高复杂代码的设计开发能力，让读源码学框架事半功倍。&lt;/p&gt;

&lt;h1 id=&quot;如何评价代码质量高低&quot;&gt;如何评价代码质量高低？&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;可维护性 maintainability&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;主观、侧面： bug是否容易修复，修改、添加功能是否能够轻松完成。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;可读性 readability&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;代码是否符合编码规范、命名是否达意、注释是否详尽、函数是否长短合适、模块划分是否清晰、是否符合高内聚低耦合等等。&lt;/p&gt;

  &lt;p&gt;code review 测验代码可读性&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;可拓展性 extensibility&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;代码预留了一些功能扩展点，可以把新功能代码直接插到扩展点上。&lt;/p&gt;

  &lt;p&gt;“对修改关闭，对扩展开放”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;灵活性 flexibility&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;代码易扩展、易复用或者易用&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;简洁性 simplicity&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;KISS&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;可复用性 reusability&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;DRY (Don’t Repeat Yourself)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;可测试性 testability&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;思考：函数是较小的可复用单位，面向对象把可复用单位提升到类层次，设计模式把可复用对提升到框架层次。&lt;/p&gt;

&lt;h1 id=&quot;面向对象&quot;&gt;面向对象&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;面向对象中的继承、多态能让我们写出可复用的代码&lt;/p&gt;

  &lt;p&gt;面向对象编程是一种编程范式或编程风格。它以&lt;strong&gt;类或对象&lt;/strong&gt;作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石 。&lt;/p&gt;

  &lt;p&gt;面向对象软件开发：OOA&amp;gt;OOD&amp;gt;OOP (分析&amp;gt;设计&amp;gt;编程)&lt;/p&gt;

  &lt;p&gt;UML(Unified Model Language) 统一建模语言&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;封装抽象继承多态&quot;&gt;封装、抽象、继承、多态&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;封装：隐藏信息、保护数据&lt;/li&gt;
  &lt;li&gt;抽象 : 隐藏方法的具体实现&lt;/li&gt;
  &lt;li&gt;继承：Java 使用extends 关键字，C++ 使用冒号（class B : public A），Python 使用()，Ruby 使用 &amp;lt;。&lt;/li&gt;
  &lt;li&gt;多态：子类可以替换父类。用接口类来实现多态特性；duck-typing(只要两个类具有相同的方法，就可以实现多态)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;面向对象编程-vs-面向过程编程&quot;&gt;面向对象编程 VS 面向过程编程&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;面向过程风格的代码被组织成了一组方法集合及其数据结构，方法和数据结构的定义是分开的。&lt;/li&gt;
  &lt;li&gt;面向对象风格的代码被组织成一组类，方法和数据结构被绑定一起，定义在类中。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;接口-vs-抽象类&quot;&gt;接口 VS 抽象类&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;接口：协议/约定，实现面向对象的抽象多态和基于接口而非实现的设计原则，为了代码复用。
    &lt;ul&gt;
      &lt;li&gt;接口不能包含属性（也就是成员变量）&lt;/li&gt;
      &lt;li&gt;接口只能声明方法，方法不能包含代码实现。&lt;/li&gt;
      &lt;li&gt;类实现接口的时候，必须实现接口中声明的所有方法。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;抽象类：实现面向对象的继承和模板设计模式,侧重于解耦。
    &lt;ul&gt;
      &lt;li&gt;抽象类不允许实例化，只能被继承&lt;/li&gt;
      &lt;li&gt;抽象类可以包含属性和方法&lt;/li&gt;
      &lt;li&gt;子类继承抽象类，必须实现抽象类中的所有抽象方法&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;C++ 只支持抽象类，不支持接口；Python &lt;a href=&quot;https://docs.python.org/zh-cn/3/library/abc.html#module-abc&quot;&gt;&lt;code&gt;abc&lt;/code&gt;&lt;/a&gt; 抽象基类&lt;a href=&quot;https://docs.python.org/zh-cn/3/library/abc.html#module-abc&quot;&gt;¶&lt;/a&gt;(可用普通类/duck-typing来模拟)。&lt;/li&gt;
  &lt;li&gt;表示is-a的关系，为解决代码复用的问题，用抽象类。(先有子类的代码重复，然后再抽象成上层的父类。)&lt;/li&gt;
  &lt;li&gt;表示has-a / behaves like的关系，为解决抽象的问题，用接口。(先设计接口，再去考虑具体的实现。)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;基于接口而非实现编程--基于抽象而非实现编程&quot;&gt;基于接口而非实现编程 / 基于抽象而非实现编程&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;函数的命名不能暴露任何实现细节&lt;/li&gt;
  &lt;li&gt;封装具体的实现细节&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;为实现类定义抽象的接口&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;多用组合少用继承
    &lt;ul&gt;
      &lt;li&gt;继承主要有三个作用：表示 is-a 关系，支持多态特性，代码复用。&lt;/li&gt;
      &lt;li&gt;这三个作用可以通过组合、接口、委托三个技术手段来达成。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;面向过程的贫血模型和面向对象的充血模型&quot;&gt;面向过程的贫血模型和面向对象的充血模型&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;基于贫血模型的 MVC 三层架构开发模式&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Model/View/Controller 展示层、逻辑层、数据层
        &lt;ul&gt;
          &lt;li&gt;后端项目分为 Repository 数据访问、Service业务逻辑 、Controller暴露接口&lt;/li&gt;
          &lt;li&gt;贫血模型的Service层将数据与操作分离&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;blockquote&gt;
      &lt;p&gt;大部分都是SQL 驱动（SQL-Driven）的开发模式。一个后端接口的开发，看接口需要的数据对应到数据库中，需要哪张表或者哪几张表，然后编写 SQL 语句来获取数据。之后就是定义类，然后模板式地往对应的 Repository、Service、Controller 类中添加代码。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;基于充血模型的 DDD (领域驱动设计)开发模式&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;更适合业务复杂的系统开发，比如金融系统&lt;/li&gt;
      &lt;li&gt;DDD ：用来指导如何解耦业务系统，划分业务模块，定义业务领域模型及其交互&lt;/li&gt;
      &lt;li&gt;微服务加速了领域驱动设计的盛行。关键在于对业务的熟悉程度。&lt;/li&gt;
      &lt;li&gt;充血模型的Service层分service和domain，包含数据和业务逻辑&lt;/li&gt;
    &lt;/ul&gt;

    &lt;blockquote&gt;
      &lt;p&gt;应用基于充血模型的 DDD 的开发模式，需要事先理清楚所有的业务，定义领域模型所包含的属性和
方法。领域模型相当于可复用的业务中间层。新功能需求的开发，都基于之前定义好的这些领域模型来完成。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;设计原则&quot;&gt;设计原则&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;设计原则中的单一职责、DRY、基于接口而非实现、里式替换原则等，可以让我们写出可复用、灵活、可性好、易扩展、易维护的代码；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;solid-原则--srp&quot;&gt;SOLID 原则 -SRP&lt;/h2&gt;

&lt;p&gt;单一职责原则 Single Responsibility Principle&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A class or module should have a single responsibility.&lt;/li&gt;
  &lt;li&gt;持续重构：粗粒度的类 &amp;gt; 细粒度的类
    &lt;ul&gt;
      &lt;li&gt;类中的代码行数、函数或属性过多，会影响代码的可读性和可维护性，考虑对类拆分。&lt;/li&gt;
      &lt;li&gt;类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想，考虑拆分。&lt;/li&gt;
      &lt;li&gt;私有方法过多，能否将私有方法独立到新的类中，设置为 public 方法，供更多的类使用。&lt;/li&gt;
      &lt;li&gt;比较难给类起一个合适名字或用业务名词概括，说明类的职责定义不够清晰。&lt;/li&gt;
      &lt;li&gt;类中大量的方法都是集中操作类中的某几个属性，将这几个属性和对应的方法拆分出来。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;solid-原则--ocp&quot;&gt;SOLID 原则 -OCP&lt;/h2&gt;

&lt;p&gt;开闭原则 Open Closed Principle&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;software entities (modules, classes, functions, etc.) should be open for extension ,but closed for modification.&lt;/li&gt;
  &lt;li&gt;在写代码的时候后，思考一下这段代码未来可能有哪些需求变更、如何设计代码结构，预留扩展点。在识别出代码可变部分和不可变部分之后，我们要将可变部分封装起来，隔离变化，提供抽象化的不可变接口，给上层系统使用。&lt;/li&gt;
  &lt;li&gt;利用多态、依赖注入、抽象意识、基于接口而非实现编程，来实现“对扩展开放、对修改关闭”。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;solid-原则--lsp&quot;&gt;SOLID 原则 -LSP&lt;/h2&gt;

&lt;p&gt;里式替换原则 Liskov Substitution Principle&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;If S is a subtype of T, then objects of type T may be replaced with objects of type S, without breaking the program.&lt;/li&gt;
  &lt;li&gt;子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏原有程序的正确性。&lt;/li&gt;
  &lt;li&gt;Design By Contract 子类在设计的时候，要遵守父类的行为约定/协议，在保证兼容的前提条件下做扩展和调整，相当于细粒度的开闭原则。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;solid-原则--isp&quot;&gt;SOLID 原则 -ISP&lt;/h2&gt;

&lt;p&gt;接口隔离原则 Interface Segregation Principle&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Clients should not be forced to depend upon interfaces that they do not use.&lt;/li&gt;
  &lt;li&gt;接口调用者不应该强迫依赖它不需要的接口。&lt;/li&gt;
  &lt;li&gt;接口调用者只使用部分接口或者接口部分功能，则接口设计NO SRP&lt;/li&gt;
  &lt;li&gt;多个特定客户端接口要好于一个宽泛用途的接口.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;solid-原则--dip&quot;&gt;SOLID 原则 -DIP&lt;/h2&gt;

&lt;p&gt;依赖反转原则 Dependency Inversion Principle&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;High-level modules shouldn’t depend on low-level modules. Both modules should depend on abstractions. In addition, abstractions shouldn’t depend on details. Details depend on abstractions.
用来指导框架层面的设计：高层模块不依赖低层模块，它们共同依赖同一个抽象。抽象不要依赖具体实现细
节，具体实现细节依赖抽象。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;控制反转 IOC Inversion Of Control&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程可以通过框架来控制。流程的控制权从程序员“反转”到了框架。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;依赖注入 DI Dependency Injection&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;不通过 new() 的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;more&quot;&gt;More&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;KISS 原则 Keep It Simple and Stupid.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;不要使用同事可能不懂的技术来实现代码&lt;/li&gt;
      &lt;li&gt;不要重复造轮子，要善于使用已经有的工具类库&lt;/li&gt;
      &lt;li&gt;不要过度优化&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;YAGNI 原则 You Ain’t Gonna Need It&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DRY 原则 Don’t Repeat Yourself&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;实现逻辑重复、功能语义重复、代码执行重复&lt;/li&gt;
      &lt;li&gt;代码复用意识：。在设计每个模块、类、函数的时候，要像设计一个外部 API 一样去思考它的复用性。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;LOD 原则 Law of Demeter&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;高内聚、松耦合 ： 对于类，“高内聚”用来指导类本身的设计，相近的功能往往会被同时修改，放到同一个类中，修改会比较集中，代码容易维护。“松耦合”用来指导类与类之间依赖关系的设计。&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;又称：最小知识原则 The Least Knowledge Principle&lt;/li&gt;
    &lt;/ul&gt;

    &lt;blockquote&gt;
      &lt;p&gt;Each unit should have only limited knowledge about other units: only units “closely” related to the current unit. Or: Each unit should only talk to its friends; Don’t talk to strangers.&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;不该有直接依赖关系的类之间，不要有依赖&lt;/li&gt;
      &lt;li&gt;有依赖关系的类之间，尽量只依赖必要的接口&lt;/li&gt;
      &lt;li&gt;迪米特法则是希望减少类之间的耦合，让类越独立越好。每个类都应该少了解系统的其他部分。一旦发生变化，需要了解这一变化的类就会比较少。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;业务系统开发&quot;&gt;业务系统开发&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;端到端（end to end）开发一个完整的系统，工作包括：前期的需求沟通分析、中期的代码设计实现、后期的系统上线维护等。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;需求分析&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;爱因斯坦说过，“创造的一大秘诀是要懂得如何隐藏你的来源”&lt;/p&gt;

  &lt;p&gt;产品设计文档（PRD）、线框图、、用户用例（user case）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;系统设计&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;聚焦架构层面，针对模块。&lt;/p&gt;

  &lt;ol&gt;
    &lt;li&gt;合理地将功能划分到不同模块。为了避免业务知识的耦合，让下层系统更加通用，下层系统（也就是被调用的系统）不应该包含太多上层系统（也就是调用系统）的业务信息。&lt;/li&gt;
    &lt;li&gt;设计模块与模块之间的交互关系。常见交互方式一种是同步接口调用，另一种是利用消息中间件异步调用。&lt;/li&gt;
    &lt;li&gt;设计模块的接口、数据库、业务模型&lt;/li&gt;
    &lt;li&gt;业务模型/业务逻辑：Controller 层负责接口暴露，Repository 层负责数据读写，Service 层负责核心业务逻辑。
      &lt;ol&gt;
        &lt;li&gt;分层的作用：代码复用、隔离变化、提高代码可测试性。&lt;/li&gt;
        &lt;li&gt;应对复杂系统：水平方向基于业务拆分-模块化；垂直方向基于流程拆分-分层。&lt;/li&gt;
      &lt;/ol&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;设计模式&quot;&gt;设计模式&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;设计模式可以让我们写出易扩展的代码&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;创建型
    &lt;ul&gt;
      &lt;li&gt;常用：单例模式、工厂模式、建造者模式&lt;/li&gt;
      &lt;li&gt;不常用：原型模式&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;结构型
    &lt;ul&gt;
      &lt;li&gt;常用：代理模式、桥接模式、装饰者模式、适配器模式&lt;/li&gt;
      &lt;li&gt;不常用：门面模式、组合模式、享元模式&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;行为型
    &lt;ul&gt;
      &lt;li&gt;常用：观察者模式、模板模式、策略模式、职责链模式、迭代器模式、状态模式&lt;/li&gt;
      &lt;li&gt;不常用：访问者模式、备忘录模式、命令模式、解释器模式、中介模式&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;创建型模式&quot;&gt;创建型模式&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;创建型模式主要解决对象的创建问题，封装复杂的创建过程，解耦对象的创建代码和使用代码。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;单例模式用来创建全局唯一的对象。&lt;/li&gt;
  &lt;li&gt;工厂模式用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。&lt;/li&gt;
  &lt;li&gt;建造者模式是用来创建复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象。&lt;/li&gt;
  &lt;li&gt;原型模式针对创建成本比较大的对象，利用对已有对象进行复制的方式进行创建，以达到节省创建时间的目的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;单例模式&quot;&gt;单例模式&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Singleton Design Pattern 一个类只允许创建一个对象（或者实例）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;实例：处理资源访问冲突、表示全局唯一类&lt;/p&gt;

  &lt;p&gt;实现方式：饿汉式、懒汉式、双重检测、静态内部类、枚举。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;工厂模式&quot;&gt;工厂模式&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Factory Design Pattern&lt;/p&gt;

  &lt;p&gt;当创建逻辑比较复杂时考虑使用工厂模式，封装对象的创建过程，将对象的创建和使用相分离。&lt;/p&gt;

  &lt;p&gt;实例：规则配置解析，代码中存在 if-else 分支判断，动态地根据不同的类型创建不同的对象&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;简单工厂/静态工厂方法&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;一个类只负责对象的创建，类一般以“Factory”结尾，创建对象的方法一般以create 开头&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;工厂方法&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;将复杂的创建逻辑拆分到多个工厂类&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;抽象工厂&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;建造者模式&quot;&gt;建造者模式&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;builder模式/生成器模式&lt;/p&gt;

  &lt;p&gt;让建造者类来负责对象的创建工作，用来创建一种类型的复杂对象，通过设置不同的可选参数，“定制化”地创建不同的对象。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;顾客走进一家餐馆点餐，我们利用工厂模式，根据用户不同的选择，来制作不同的食物，比如披萨、汉堡、沙拉。对于披萨来说，用户又有各种配料可以定制，比如奶酪、西红柿、起司，我们通过建造者模式根据用户选择的不同配料来制作披萨。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;原型模式&quot;&gt;原型模式&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;对象的创建成本比较大时，利用对已有对象（原型）进行复制（或者叫拷贝）的方式来创建新对象。&lt;/p&gt;

  &lt;p&gt;对象的创建成本比较大：对象中的数据需要经过复杂的计算才能得到（比如排序、计算哈希值），或者需要从 RPC、网络、数据库、文件系统等非常慢速的 IO 中读取。&lt;/p&gt;

  &lt;p&gt;实现方式：深拷贝、浅拷贝&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;结构型模式&quot;&gt;结构型模式&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;结构型设计模式主要解决“类或对象的组合或组装”问题，即将不同功能代码解耦。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;代理模式：代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同。&lt;/li&gt;
  &lt;li&gt;桥接模式：桥接模式的目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变。&lt;/li&gt;
  &lt;li&gt;装饰器模式：装饰者模式在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用。&lt;/li&gt;
  &lt;li&gt;适配器模式：适配器模式是一种事后的补救策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;代理模式&quot;&gt;代理模式&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Proxy Design Pattern ：在不改变原始类（或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能。一般情况下，我们让代理类和原始类实现同样的接口，或者让代理类继承原始类的方法。&lt;/p&gt;

  &lt;p&gt;动态代理（Dynamic Proxy），就是不事先为每个原始类编写代理类，而是在运行的时候，动态地创建原始类对应的代理类。&lt;/p&gt;

  &lt;p&gt;应用场景：业务系统的非功能性需求开发比如：监控、统计、鉴权、限流、事务、幂等、日志。&lt;/p&gt;

  &lt;p&gt;​					在 RPC(远程代理)、缓存中的应用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;桥接模式&quot;&gt;桥接模式&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Bridge Design Pattern ：Decouple an abstraction from its implementation so that the two can vary independently.  将抽象和实现解耦，让它们可以独立变化。&lt;/p&gt;

  &lt;p&gt;组合优于继承。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;装饰器模式&quot;&gt;装饰器模式&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;解决继承关系过于复杂的问题，通过组合来替代继承。主要作用是给原始类添加增强功能。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;适配器模式&quot;&gt;适配器模式&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Adapter Design Pattern 让原本由于接口不兼容而不能一起工作的类可以一起工作&lt;/p&gt;

  &lt;p&gt;两种实现方式：类适配器 (使用继承实现) 和对象适配器 (使用组合实现)&lt;/p&gt;

  &lt;p&gt;使用场景(事后补救)：封装有缺陷的接口设计、统一多个类的接口设计、替换依赖的外部系统、兼容老版本接口、适配不同格式的数据&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;行为型模式&quot;&gt;行为型模式&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;行为型设计模式主要解决的就是“类或对象之间的交互”问题，即将不同的行为代码解耦。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;观察者模式&quot;&gt;观察者模式&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Observer Design Pattern 或称发布订阅模式（Publish-Subscribe Design Pattern）。&lt;/p&gt;

  &lt;p&gt;Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically. 在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。&lt;/p&gt;

  &lt;p&gt;Subject-Observer、Publisher-Subscriber、Producer-Consumer、Event Emitter-Event Listener、Dispatcher-Listener。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;模板模式&quot;&gt;模板模式&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Template Method Design Pattern&lt;/p&gt;

  &lt;p&gt;Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure. 模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。&lt;/p&gt;

  &lt;p&gt;模板模式的两大作用：复用和扩展。复用指所有的子类可以复用父类中提供的模板方法的代码。扩展指框架通过模板模式提供功能扩展点，让框架用户可以在不修改框架源码的情况下，基于扩展点定制化框架的功能。回调具有同样功能。&lt;/p&gt;

  &lt;p&gt;应用场景上看，同步回调看起来更像模板模式，异步回调看起来更像观察者模式。&lt;/p&gt;

  &lt;p&gt;代码实现上看，回调基于组合，把一个对象传递给另一个对象。模板模式基于继承，子类重写父类的抽
象方法。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;策略模式&quot;&gt;策略模式&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Strategy Design Pattern&lt;/p&gt;

  &lt;p&gt;Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it. 定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。策略模式可以使算法的变化独立于使用它们的客户端（这里的客户端代指使用算法的代码）。&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;策略类的定义，包含一个策略接口和一组实现这个接口的策略类&lt;/li&gt;
    &lt;li&gt;策略的创建，一般会通过类型（type）来判断创建哪个策略来使用&lt;/li&gt;
    &lt;li&gt;策略的使用，运行时动态确定使用哪种策略&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;应用场景：利用它来避免冗长的 if-else 或 switch 分支判断。&lt;/p&gt;

  &lt;p&gt;​					本质上点讲，是借助“查表法”，根据 type 查表替代根据 type 分支判断。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;职责链模式&quot;&gt;职责链模式&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Chain Of Responsibility Design Pattern&lt;/p&gt;

  &lt;p&gt;Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it. 将请求的发送和接收解耦，让多个接收对象都有机会处理这个请求。将这些接收对象串成一条链，并沿着这条链传递这个请求，直到链上的某个接收对象能够处理它为止。&lt;/p&gt;

  &lt;p&gt;应用场景：常用来开发框架的过滤器和拦截器，让框架的使用者在不需要修改框架源码的情况下，添加新的过滤拦截功能。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;状态模式&quot;&gt;状态模式&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;状态机/有限状态机 FSM ，Finite State Machine&lt;/p&gt;

  &lt;p&gt;状态机有3 个组成部分：状态（State）、事件（Event）、动作（Action）&lt;/p&gt;

  &lt;p&gt;实现方式：分支逻辑法、查表法、状态模式&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;迭代器模式&quot;&gt;迭代器模式&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Iterator Design Pattern&lt;/p&gt;

  &lt;p&gt;用来遍历集合对象/容器，如数组、链表、树、图。&lt;/p&gt;

  &lt;p&gt;一个完整的迭代器模式，一般会涉及容器和容器迭代器两部分内容。&lt;/p&gt;

  &lt;p&gt;为了达到基于接口而非实现编程的目的，容器又包含容器接口、容器实现类，迭代器又包含迭代器接口、迭代器实现类。&lt;/p&gt;

  &lt;p&gt;容器中需要定义 iterator() 方法，用来创建迭代器。迭代器接口中需要定义hasNext()、currentItem()、next() 三个最基本的方法。容器对象通过依赖注入传递到迭代器类中。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;编程规范&quot;&gt;编程规范&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;编码规范能让我们写出可读性好的代码&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;代码重构&quot;&gt;代码重构&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;持续重构可以时刻保持代码的可维护性&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;重构的目的（why）、对象（what）、时机（when）、方法（how）&lt;/li&gt;
  &lt;li&gt;保证重构不出错的技术手段：单元测试 (代码的可测试性)
    &lt;ul&gt;
      &lt;li&gt;单元测试的测试对象是类或者函数，用来测试一个类和函数是否都按照预期的逻辑执行。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;两种不同规模的重构：大重构（大规模高层次）和小重构（小规模低层次、编程规范）。
    &lt;ul&gt;
      &lt;li&gt;大型重构：系统、模块、代码结构、类与类之间的关系等的重构
        &lt;ul&gt;
          &lt;li&gt;重构的手段有：分层、模块化、解耦、抽象可复用组件&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;小型重构：对类、函数、变量等代码级别的重构
        &lt;ul&gt;
          &lt;li&gt;编码规范：规范命名、规范注释、消除超大类或函数、提取重复代码&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="Software" /><summary type="html">奥卡姆剃刀 ： 如无必要，勿增实体</summary></entry><entry><title type="html">软件开发流程</title><link href="https://acemyzoe.github.io/_posts/2020-07-30-%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/" rel="alternate" type="text/html" title="软件开发流程" /><published>2020-07-30T00:00:00+08:00</published><updated>2020-07-30T00:00:00+08:00</updated><id>https://acemyzoe.github.io/_posts/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B</id><content type="html" xml:base="https://acemyzoe.github.io/_posts/2020-07-30-%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/">&lt;h1 id=&quot;software-development-process&quot;&gt;Software development &lt;a href=&quot;https://en.wikipedia.org/wiki/Software_development_process&quot;&gt;process&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;软件开发生命周期&lt;/strong&gt; software development life cycle（SDLC）&lt;/p&gt;

&lt;h2 id=&quot;方法&quot;&gt;方法&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Agile_software_development&quot;&gt;敏捷开发&lt;/a&gt;：迭代开发+增量开发
    &lt;ul&gt;
      &lt;li&gt;开发原则：
        &lt;ol&gt;
          &lt;li&gt;通过尽早并持续交付有价值的软件来使客户满意。&lt;/li&gt;
          &lt;li&gt;即使在后期开发中，也欢迎不断变化的需求。&lt;/li&gt;
          &lt;li&gt;频繁交付工作软件（数周而不是数月）&lt;/li&gt;
          &lt;li&gt;商界人士与开发人员之间的紧密日常合作&lt;/li&gt;
          &lt;li&gt;项目是围绕积极进取的个人建立的，应该值得信任&lt;/li&gt;
          &lt;li&gt;面对面的对话是最好的交流方式（同一地点）&lt;/li&gt;
          &lt;li&gt;工作软件是进度的主要衡量标准&lt;/li&gt;
          &lt;li&gt;可持续发展，能够保持稳定的步伐&lt;/li&gt;
          &lt;li&gt;持续关注技术卓越和良好的设计&lt;/li&gt;
          &lt;li&gt;简洁性（最大化未完成工作量的艺术）至关重要&lt;/li&gt;
          &lt;li&gt;自组织团队会提供最佳的架构，需求和设计&lt;/li&gt;
          &lt;li&gt;团队定期思考如何提高效率，并做出相应调整&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;敏捷软件开发框架
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Rapid_application_development&quot;&gt;快速应用程序开发&lt;/a&gt;（RAD）
            &lt;ul&gt;
              &lt;li&gt;主要通过迭代原型设计（在开发的任何阶段），积极的用户参与以及计算机化的开发工具来快速生产高质量的系统。这些工具可能包括&lt;a href=&quot;https://en.wikipedia.org/wiki/Graphical_User_Interface&quot;&gt;图形用户界面&lt;/a&gt;（GUI）生成器，&lt;a href=&quot;https://en.wikipedia.org/wiki/Computer_Aided_Software_Engineering&quot;&gt;计算机辅助软件工程&lt;/a&gt;（CASE）工具，&lt;a href=&quot;https://en.wikipedia.org/wiki/Database_Management_System&quot;&gt;数据库管理系统&lt;/a&gt;（DBMS），&lt;a href=&quot;https://en.wikipedia.org/wiki/Fourth-generation_programming_language&quot;&gt;第四代编程语言&lt;/a&gt;，代码生成器和面向对象的技术。&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;敏捷软件开发实践
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Test-driven_development&quot;&gt;测试驱动开发&lt;/a&gt;（TDD）：开发人员&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Acceptance_test-driven_development&quot;&gt;验收测试驱动开发&lt;/a&gt;（ATDD）：客户&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Behavior-driven_development&quot;&gt;行为驱动开发&lt;/a&gt;（BDD）：结合TDD&amp;amp;ATDD&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_integration&quot;&gt;持续集成&lt;/a&gt;（CI）&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;迭代开发
    &lt;ol&gt;
      &lt;li&gt;需求分析（requirements analysis）&lt;/li&gt;
      &lt;li&gt;设计（design）&lt;/li&gt;
      &lt;li&gt;编码（coding）&lt;/li&gt;
      &lt;li&gt;测试（testing）&lt;/li&gt;
      &lt;li&gt;部署和评估（deployment / evaluation）&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;实践&quot;&gt;实践&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;测试驱动开发  &lt;strong&gt;Test-driven development&lt;/strong&gt; (&lt;strong&gt;TDD&lt;/strong&gt;)
    &lt;ul&gt;
      &lt;li&gt;将需求转换为非常具体的测试用例，然后对代码进行改进以使测试通过&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;CI/CD&lt;/strong&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_integration&quot;&gt;持续集成&lt;/a&gt;以及&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_delivery&quot;&gt;持续交付&lt;/a&gt;或&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_deployment&quot;&gt;持续部署&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;持续集成CI是每天将所有开发人员的工作副本合并到共享主线中的一种做法。&lt;/li&gt;
      &lt;li&gt;工作流程
        &lt;ol&gt;
          &lt;li&gt;在本地进行测试&lt;/li&gt;
          &lt;li&gt;用CI编译代码&lt;/li&gt;
          &lt;li&gt;在CI中运行测试&lt;/li&gt;
          &lt;li&gt;从CI部署工件&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;CI / CD生态系统的关键组件是测试环境，它通过在软件交付的早期阶段自动发现最严重的错误来减少测试时间。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;saas&quot;&gt;SaaS&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;软件即服务&lt;/strong&gt; Software as a Service&lt;/p&gt;

&lt;p&gt;在这种交付模式中，软件仅需通过网络，不须经过传统的安装步骤即可使用，软件及其相关的数据集中托管于云端服务。&lt;/p&gt;

&lt;h1 id=&quot;rest&quot;&gt;Rest&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Representational State Transfer&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;web服务实现方案：Rest、&lt;a href=&quot;https://zh.wikipedia.org/wiki/SOAP&quot;&gt;SOAP&lt;/a&gt;和&lt;a href=&quot;https://zh.wikipedia.org/wiki/XML-RPC&quot;&gt;XML-RPC&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;基于&lt;a href=&quot;https://zh.wikipedia.org/wiki/HTTP&quot;&gt;HTTP&lt;/a&gt;、&lt;a href=&quot;https://zh.wikipedia.org/wiki/URI&quot;&gt;URI&lt;/a&gt;、&lt;a href=&quot;https://zh.wikipedia.org/wiki/XML&quot;&gt;XML&lt;/a&gt;以及&lt;a href=&quot;https://zh.wikipedia.org/wiki/HTML&quot;&gt;HTML&lt;/a&gt;现有的广泛流行的协议和标准。&lt;/li&gt;
  &lt;li&gt;资源是由URI来指定。&lt;/li&gt;
  &lt;li&gt;对资源的操作包括获取、创建、修改和删除，这些操作正好对应HTTP协议提供的GET、POST、PUT和DELETE方法。&lt;/li&gt;
  &lt;li&gt;通过操作资源的表现形式来操作资源。&lt;/li&gt;
  &lt;li&gt;资源的表现形式则是XML或者HTML，取决于读者是机器还是人、是消费Web服务的客户软件还是Web浏览器。当然也可以是任何其他的格式，例如JSON。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;restful-api&quot;&gt;&lt;strong&gt;RESTful API&lt;/strong&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;直观简短的资源地址：URI，比如：&lt;code&gt;http://example.com/resources&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;传输的资源：Web服务接受与返回的互联网媒体类型，比如：&lt;a href=&quot;https://zh.wikipedia.org/wiki/JSON&quot;&gt;JSON&lt;/a&gt;，&lt;a href=&quot;https://zh.wikipedia.org/wiki/XML&quot;&gt;XML&lt;/a&gt;，&lt;a href=&quot;https://zh.wikipedia.org/wiki/YAML&quot;&gt;YAML&lt;/a&gt;等。&lt;/li&gt;
  &lt;li&gt;对资源的操作：Web服务在该资源上所支持的一系列&lt;a href=&quot;https://zh.wikipedia.org/wiki/超文本传输协议#请求方法&quot;&gt;请求方法&lt;/a&gt;（比如：POST，GET，PUT或DELETE）。&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;资源&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;GET&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;PUT&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;POST&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;DELETE&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;一组资源的URI，比如&lt;code&gt;https://example.com/resources&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;列出&lt;/strong&gt;URI，以及该资源组中每个资源的详细信息（后者可选）。&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;使用给定的一组资源&lt;strong&gt;替换&lt;/strong&gt;当前整组资源。&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;在本组资源中&lt;strong&gt;创建/追加&lt;/strong&gt;一个新的资源。该操作往往返回新资源的URL。&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;删除&lt;/strong&gt;整组资源。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;单个资源的URI，比如&lt;code&gt;https://example.com/resources/142&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;获取&lt;/strong&gt;指定的资源的详细信息，格式可以自选一个合适的网络媒体类型（比如：XML、JSON等）&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;替换/创建&lt;/strong&gt;指定的资源。并将其追加到相应的资源组中。&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;把指定的资源当做一个资源组，并在其下&lt;strong&gt;创建/追加&lt;/strong&gt;一个新的元素，使其隶属于当前资源。&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;删除&lt;/strong&gt;指定的元素。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name></name></author><category term="Software" /><summary type="html">Software development process</summary></entry><entry><title type="html">ROS-function</title><link href="https://acemyzoe.github.io/_posts/2020-07-25-ROS%E5%8A%9F%E8%83%BD%E5%8C%85/" rel="alternate" type="text/html" title="ROS-function" /><published>2020-07-25T00:00:00+08:00</published><updated>2020-07-25T00:00:00+08:00</updated><id>https://acemyzoe.github.io/_posts/ROS%E5%8A%9F%E8%83%BD%E5%8C%85</id><content type="html" xml:base="https://acemyzoe.github.io/_posts/2020-07-25-ROS%E5%8A%9F%E8%83%BD%E5%8C%85/">&lt;h1 id=&quot;launch&quot;&gt;Launch&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;http://wiki.ros.org/roslaunch&quot;&gt;roslaunch&lt;/a&gt;可通过SSH 轻松地在本地和远程启动多个ROS &lt;a href=&quot;http://ros.org/wiki/Nodes&quot;&gt;节点&lt;/a&gt;，以及在&lt;a href=&quot;http://ros.org/wiki/Parameter Server&quot;&gt;Parameter Server&lt;/a&gt;上设置参数。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;​	&lt;a href=&quot;http://wiki.ros.org/roslaunch/CommandlineTools&quot;&gt;roslaunch命令行用法&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;roslaunch package_name file.launch
roslaunch -p 1234 package filename.launch # 远程端口
roslaunch my_file.launch arg:=value # 参数传递
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;​	&lt;a href=&quot;http://wiki.ros.org/roslaunch/XML&quot;&gt;roslaunch .launch / XML格式&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;launch&amp;gt;
  &amp;lt;!-- local machine already has a definition by default.
       This tag overrides the default definition with
       specific ROS_ROOT and ROS_PACKAGE_PATH values --&amp;gt;
  &amp;lt;machine name=&quot;local_alt&quot; address=&quot;localhost&quot; default=&quot;true&quot; ros-root=&quot;/u/user/ros/ros/&quot; ros-package-path=&quot;/u/user/ros/ros-pkg&quot; /&amp;gt;
  &amp;lt;!-- a basic listener node --&amp;gt;
  &amp;lt;node name=&quot;listener-1&quot; pkg=&quot;rospy_tutorials&quot; type=&quot;listener&quot; /&amp;gt;
  &amp;lt;!-- pass args to the listener node --&amp;gt;
  &amp;lt;node name=&quot;listener-2&quot; pkg=&quot;rospy_tutorials&quot; type=&quot;listener&quot; args=&quot;-foo arg2&quot; /&amp;gt;
  &amp;lt;!-- a respawn-able listener node --&amp;gt;
  &amp;lt;node name=&quot;listener-3&quot; pkg=&quot;rospy_tutorials&quot; type=&quot;listener&quot; respawn=&quot;true&quot; /&amp;gt;
  &amp;lt;!-- start listener node in the 'wg1' namespace --&amp;gt;
  &amp;lt;node ns=&quot;wg1&quot; name=&quot;listener-wg1&quot; pkg=&quot;rospy_tutorials&quot; type=&quot;listener&quot; respawn=&quot;true&quot; /&amp;gt;
  &amp;lt;!-- start a group of nodes in the 'wg2' namespace --&amp;gt;
  &amp;lt;group ns=&quot;wg2&quot;&amp;gt;
    &amp;lt;!-- remap applies to all future statements in this scope. --&amp;gt;
    &amp;lt;remap from=&quot;chatter&quot; to=&quot;hello&quot;/&amp;gt;
    &amp;lt;node pkg=&quot;rospy_tutorials&quot; type=&quot;listener&quot; name=&quot;listener&quot; args=&quot;--test&quot; respawn=&quot;true&quot; /&amp;gt;
    &amp;lt;node pkg=&quot;rospy_tutorials&quot; type=&quot;talker&quot; name=&quot;talker&quot;&amp;gt;
      &amp;lt;!-- set a private parameter for the node --&amp;gt;
      &amp;lt;param name=&quot;talker_1_param&quot; value=&quot;a value&quot; /&amp;gt;
      &amp;lt;!-- nodes can have their own remap args --&amp;gt;
      &amp;lt;remap from=&quot;chatter&quot; to=&quot;hello-1&quot;/&amp;gt;
      &amp;lt;!-- you can set environment variables for a node --&amp;gt;
      &amp;lt;env name=&quot;ENV_EXAMPLE&quot; value=&quot;some value&quot; /&amp;gt;
    &amp;lt;/node&amp;gt;
  &amp;lt;/group&amp;gt;
&amp;lt;/launch&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;http://wiki.ros.org/roslaunch/APIUsage&quot;&gt;roslaunch / PYTHON API&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 从软件包rqt_gui启动和停止rqt_gui的实例
import roslaunch
package = 'rqt_gui'
executable = 'rqt_gui'
node = roslaunch.core.Node(package, executable)

launch = roslaunch.scriptapi.ROSLaunch()
launch.start()

process = launch.launch(node)
print process.is_alive()
process.stop()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 具有参数列表的多个启动文件
import roslaunch
uuid = roslaunch.rlutil.get_or_generate_uuid(None, False)
roslaunch.configure_logging(uuid)

cli_args1 = ['pkg1', 'file1.launch', 'arg1:=arg1', 'arg2:=arg2']
cli_args2 = ['pkg2', 'file2.launch', 'arg1:=arg1', 'arg2:=arg2']
cli_args3 = ['pkg3', 'file3.launch']
roslaunch_file1 = roslaunch.rlutil.resolve_launch_arguments(cli_args1)
roslaunch_args1 = cli_args1[2:]

roslaunch_file2 = roslaunch.rlutil.resolve_launch_arguments(cli_args2)
roslaunch_args2 = cli_args2[2:]

roslaunch_file3 = roslaunch.rlutil.resolve_launch_arguments(cli_args3)

launch_files = [(roslaunch_file1, roslaunch_args1), (roslaunch_file2, roslaunch_args2), roslaunch_file3]
parent = roslaunch.parent.ROSLaunchParent(uuid, launch_files)
parent.start()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 从base启动文件“继承”
import roslaunch
roslaunch.configure_logging(uuid)
launch = roslaunch.scriptapi.ROSLaunch()
launch.parent = roslaunch.parent.ROSLaunchParent(uuid, &quot;path/to/base.launch&quot;)
launch.start()
# Start another node
node = roslaunch.core.Node(package, executable)
launch.launch(node)
try:
  launch.spin()
finally:
  # After Ctrl+C, stop all nodes from running
  launch.shutdown()
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;tf2&quot;&gt;&lt;a href=&quot;http://wiki.ros.org/tf2&quot;&gt;TF2&lt;/a&gt;&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;TF是一个让用户随时间跟踪多个坐标系的功能包，它使用树型数据结构，根据时间缓冲并维护多个坐标系之间的坐标变换关系，可以帮助开发者在任意时间，在坐标系间完成点、向量等坐标的变换。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;# 工作区
source /opt/ros/noetic/setup.bash
mkdir -p ~/tutorial_ws/src
cd ~/tutorial_ws
catkin_init_workspace src
catkin_make
source devel/setup.bash
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# run demo
# 该demo使用tf2库创建三个坐标系：世界框架，turtle1框架和turtle2框架。
# 使用tf2广播器(broadcaster)发布乌龟坐标帧，并使用tf2侦听器(listener)计算乌龟帧中的差异并移动一只乌龟跟随另一只乌龟。
sudo apt-get install ros-noetic-turtle-tf2 ros-noetic-tf2-tools ros-noetic-tf
roslaunch turtle_tf2 turtle_tf2_demo.launch
rosrun tf2_tools view_frames.py # 通过ROS广播的帧
evince frames.pdf # 绘制帧连接方式的树
rosrun tf tf_echo turtle1 turtle2 # 通过ROS广播的任何两个帧之间的转换
rosrun rviz rviz -d `rospack find turtle_tf2`/rviz/turtle_rviz.rviz # 可视化tf2帧
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;tf2-broadcaster-python&quot;&gt;tf2 broadcaster (Python)&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;如何将坐标系广播到tf2 : 广播海龟移动时不断变化的坐标系。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;# 名为learning_tf2的catkin包将继承tf2，tf2_ros,roscpp,rospy和turtlesim.
catkin_create_pkg learning_tf2 tf2 tf2_ros roscpp rospy turtlesim
roscd learning_tf2
mkdirs nodes
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# nodes / turtle_tf2_broadcaster.py
#!/usr/bin/env python  
import rospy
import tf_conversions # Because of transformations
import tf2_ros
import geometry_msgs.msg
import turtlesim.msg
def handle_turtle_pose(msg, turtlename):
    br = tf2_ros.TransformBroadcaster()
    t = geometry_msgs.msg.TransformStamped()

    t.header.stamp = rospy.Time.now() # 时间戳
    t.header.frame_id = &quot;world&quot; # 设置要创建的链接的父框架的名称
    t.child_frame_id = turtlename # 设置要创建的链接的子节点的名称
    # 从框架“world”到框架“turtle”的转换
    t.transform.translation.x = msg.x
    t.transform.translation.y = msg.y
    t.transform.translation.z = 0.0
    q = tf_conversions.transformations.quaternion_from_euler(0, 0, msg.theta)
    t.transform.rotation.x = q[0]
    t.transform.rotation.y = q[1]
    t.transform.rotation.z = q[2]
    t.transform.rotation.w = q[3]

    br.sendTransform(t)

if __name__ == '__main__':
    rospy.init_node('tf2_turtle_broadcaster')
    turtlename = rospy.get_param('turtle1') # 该节点采用一个参数
    rospy.Subscriber('/%s/pose' % turtlename, # 订阅turtle/pose主题
                     turtlesim.msg.Pose,
                     handle_turtle_pose,
                     turtlename)
    rospy.spin()
# chmod +x nodes/turtle_tf2_broadcaster.py
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!--start_demo.launch--&amp;gt;
&amp;lt;launch&amp;gt;
    &amp;lt;node pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node&quot; name=&quot;sim&quot;/&amp;gt;
    &amp;lt;node pkg=&quot;turtlesim&quot; type=&quot;turtle_teleop_key&quot; name=&quot;teleop&quot; output=&quot;screen&quot;/&amp;gt;

    &amp;lt;node name=&quot;turtle1_tf2_broadcaster&quot; pkg=&quot;learning_tf2&quot; type=&quot;turtle_tf2_broadcaster.py&quot; respawn=&quot;false&quot; output=&quot;screen&quot; &amp;gt;
    &amp;lt;param name=&quot;turtle&quot; type=&quot;string&quot; value=&quot;turtle1&quot; /&amp;gt;
    &amp;lt;/node&amp;gt;
    
    &amp;lt;node name=&quot;turtle2_tf2_broadcaster&quot; pkg=&quot;learning_tf2&quot; type=&quot;turtle_tf2_broadcaster.py&quot; respawn=&quot;false&quot; output=&quot;screen&quot; &amp;gt;
    &amp;lt;param name=&quot;turtle&quot; type=&quot;string&quot; value=&quot;turtle2&quot; /&amp;gt; 
    &amp;lt;/node&amp;gt;
    
    &amp;lt;!--tf2 listener--&amp;gt;
	&amp;lt;node pkg=&quot;learning_tf2&quot; type=&quot;turtle_tf2_listener.py&quot; name=&quot;listener&quot; output=&quot;screen&quot;/&amp;gt;
&amp;lt;/launch&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;roslaunch learning_tf2 start_demo.launch
rosrun tf tf_echo /world/turtle1
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;tf2-listener-python&quot;&gt;tf2 listener (Python)&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# nodes/turtle_tf2_listener.py
#!/usr/bin/env python  
import rospy

import math
import tf2_ros # tf2_ros包提供了tf2_ros.TransformListener的实现
import geometry_msgs.msg
import turtlesim.srv

if __name__ == '__main__':
    rospy.init_node('tf2_turtle_listener')

    tfBuffer = tf2_ros.Buffer()
    listener = tf2_ros.TransformListener(tfBuffer) # 创建侦听器

    rospy.wait_for_service('spawn')
    spawner = rospy.ServiceProxy('spawn', turtlesim.srv.Spawn)
    turtle_name = rospy.get_param('turtle', 'turtle2')
    spawner(4, 2, 0, turtle_name)

    turtle_vel = rospy.Publisher('%s/cmd_vel' % turtle_name, geometry_msgs.msg.Twist, queue_size=1)

    rate = rospy.Rate(10.0)
    while not rospy.is_shutdown():
        try:
            trans = tfBuffer.lookup_transform(turtle_name, 'turtle1', rospy.Time())
        except (tf2_ros.LookupException, tf2_ros.ConnectivityException, tf2_ros.ExtrapolationException):
            rate.sleep()
            continue

        msg = geometry_msgs.msg.Twist()

        msg.angular.z = 4 * math.atan2(trans.transform.translation.y, trans.transform.translation.x)
        msg.linear.x = 0.5 * math.sqrt(trans.transform.translation.x ** 2 + trans.transform.translation.y ** 2)

        turtle_vel.publish(msg)

        rate.sleep()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;四元数&quot;&gt;四元数&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;四元数具有4个分量（&lt;code&gt;x&lt;/code&gt;，&lt;code&gt;y&lt;/code&gt;，&lt;code&gt;z&lt;/code&gt;，&lt;code&gt;w&lt;/code&gt;），不绕x / y / z轴旋转的常用单位四元数为（0,0,0,1）。&lt;/p&gt;

  &lt;p&gt;ROS使用两种四元数数据类型：msg和’tf’&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;from geometry_msgs.msg import Quaternion
# Create a list of floats, which is compatible with tf
# quaternion methods
quat_tf = [0, 1, 0, 0]
quat_msg = Quaternion(quat_tf[0], quat_tf[1], quat_tf[2], quat_tf[3])

#（绕X轴滚动）/（绕Y轴俯仰）/（绕Z轴偏航），然后转换为四元数
# tf.transformations alternative is not yet available in tf2
from tf.transformations import quaternion_from_euler  
# RPY to convert: 90deg, 0, -90deg
q = quaternion_from_euler(1.5707, 0, -1.5707)
print(&quot;The quaternion representation is %s %s %s %s.&quot; % (q[0], q[1], q[2], q[3]))
print(q[0], q[1], q[2], -q[3]) # 反转四元数的一种简单方法是对w分量求反
# 在同一帧中从q1到q2的相对旋转qr
# q2=qr*q1,故相对旋转qr=q2*q1_inverse

# 将一个四元数的旋转应用于姿势，只需将姿势的前一个四元数乘以表示所需旋转的四元数即可
q_orig = quaternion_from_euler(0, 0, 0)
q_rot = quaternion_from_euler(pi, 0, 0)
q_new = quaternion_multiply(q_rot, q_orig)
print(q_new)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 四元数&amp;amp;欧拉角
import sys
import math

def quart2rpy(w,x,y,z):
    angles = {'roll': 0.0, 'pitch': 0.0, 'yaw': 0.0}
    r = math.atan2(2*(w*x+y*z),1-2*(x*x+y*y))
    p = math.asin(2*(w*y-z*x))
    y = math.atan2(2*(w*z+x*y),1-2*(z*z+y*y))
    angles['roll'] = r*180/math.pi
    angles['pitch'] = p*180/math.pi
    angles['yaw'] = y*180/math.pi
    print(angles)
    return [r,p,y]

def rpy2quart(roll,pitch,yaw):
    qx = math.sin(roll/2) * math.cos(pitch/2) * math.cos(yaw/2) - math.cos(roll/2) * math.sin(pitch/2) * math.sin(yaw/2)
    qy = math.cos(roll/2) * math.sin(pitch/2) * math.cos(yaw/2) + math.sin(roll/2) * math.cos(pitch/2) * math.sin(yaw/2)
    qz = math.cos(roll/2) * math.cos(pitch/2) * math.sin(yaw/2) - math.sin(roll/2) * math.sin(pitch/2) * math.cos(yaw/2)
    qw = math.cos(roll/2) * math.cos(pitch/2) * math.cos(yaw/2) + math.sin(roll/2) * math.sin(pitch/2) * math.sin(yaw/2)
    print([qw,qx,qy,qz])
    return [qw,qx,qy,qz]

if __name__ == &quot;__main__&quot;:
    rpy2quart(1,0,0)
    q=quart2rpy(0.8775825618903728, 0.479425538604203, 0.0, 0.0)
    rpy2quart(q[0],q[1],q[2])
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;rviz&quot;&gt;&lt;a href=&quot;https://wiki.ros.org/rviz&quot;&gt;Rviz&lt;/a&gt;&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;机器人通过ROS发布数据，rviz订阅消息接收数据，然后3D可视化。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;markers&quot;&gt;&lt;a href=&quot;https://wiki.ros.org/rviz/Tutorials/Markers%3A Basic Shapes&quot;&gt;Markers&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;rosrun rviz rviz --help
# 发送四个基本形状（框，球体，圆柱体和箭头）
catkin_create_pkg using_markers roscpp visualization_msgs
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt;//// src/basic_shapes.cpp
#include &amp;lt;ros/ros.h&amp;gt;
#include &amp;lt;visualization_msgs/Marker.h&amp;gt;
//原始对象是通过visualization_msgs/Marker消息发送到显示器的。

int main( int argc, char** argv )
{
  ros::init(argc, argv, &quot;basic_shapes&quot;);
  ros::NodeHandle n;
  ros::Rate r(1);
  ros::Publisher marker_pub = n.advertise&amp;lt;visualization_msgs::Marker&amp;gt;(&quot;visualization_marker&quot;, 1);

  // Set our initial shape type to be a cube,创建一个整数来跟踪要发布的形状
  uint32_t shape = visualization_msgs::Marker::CUBE;

  while (ros::ok())
  {
    visualization_msgs::Marker marker;
    // Set the frame ID and timestamp.  See the TF tutorials for information on these.
    marker.header.frame_id = &quot;/my_frame&quot;;
    marker.header.stamp = ros::Time::now();

    // Set the namespace and id for this marker.  This serves to create a unique ID
    // Any marker sent with the same namespace and id will overwrite the old one
    // 名称空间（ns）和id用于为此标记创建唯一的名称
    marker.ns = &quot;basic_shapes&quot;;
    marker.id = 0;

    // Set the marker type.  Initially this is CUBE, and cycles between that and SPHERE, ARROW, and CYLINDER
    marker.type = shape;

    // Set the marker action.  Options are ADD, DELETE, and new in ROS Indigo: 3 (DELETEALL)
    marker.action = visualization_msgs::Marker::ADD;

    // Set the pose of the marker.  This is a full 6DOF pose relative to the frame/time specified in the header
    // xyz位置 &amp;amp; xyzw方向
    marker.pose.position.x = 0;
    marker.pose.position.y = 0;
    marker.pose.position.z = 0;
    marker.pose.orientation.x = 0.0;
    marker.pose.orientation.y = 0.0;
    marker.pose.orientation.z = 0.0;
    marker.pose.orientation.w = 1.0;

    // Set the scale of the marker -- 1x1x1 here means 1m on a side
    // 比例 1：1m
    marker.scale.x = 1.0;
    marker.scale.y = 1.0;
    marker.scale.z = 1.0;

    // Set the color -- be sure to set alpha to something non-zero!
    marker.color.r = 0.0f;
    marker.color.g = 1.0f;
    marker.color.b = 0.0f;
    marker.color.a = 1.0; //alpha（a）值0表示完全透明（不可见），而1则完全不透明。

    marker.lifetime = ros::Duration(); //标记的持续时间/生命周期

    // Publish the marker
    while (marker_pub.getNumSubscribers() &amp;lt; 1)
    {
      if (!ros::ok())
      {
        return 0;
      }
      ROS_WARN_ONCE(&quot;Please create a subscriber to the marker&quot;);
      sleep(1);
    }
    marker_pub.publish(marker);

    // Cycle between different shapes
    // CUBE立方体 SPHERE球 ARROW箭头 CYLINDER圆柱
    switch (shape)
    {
    case visualization_msgs::Marker::CUBE:
      shape = visualization_msgs::Marker::SPHERE;
      break;
    case visualization_msgs::Marker::SPHERE:
      shape = visualization_msgs::Marker::ARROW;
      break;
    case visualization_msgs::Marker::ARROW:
      shape = visualization_msgs::Marker::CYLINDER;
      break;
    case visualization_msgs::Marker::CYLINDER:
      shape = visualization_msgs::Marker::CUBE;
      break;
    }

    r.sleep();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-cmake&quot;&gt;add_executable(basic_shapes src/basic_shapes.cpp)
target_link_libraries(basic_shapes ${catkin_LIBRARIES})
# catkin_make
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;rosmake rviz
rosrun using_markers basic_shapes
rosrun rviz rviz
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt;//产生一个旋转的螺旋线
#include &amp;lt;ros/ros.h&amp;gt;
#include &amp;lt;visualization_msgs/Marker.h&amp;gt;

#include &amp;lt;cmath&amp;gt;

int main( int argc, char** argv )
{
  ros::init(argc, argv, &quot;points_and_lines&quot;);
  ros::NodeHandle n;
  ros::Publisher marker_pub = n.advertise&amp;lt;visualization_msgs::Marker&amp;gt;(&quot;visualization_marker&quot;, 10);
  ros::Rate r(30);

  float f = 0.0;
  while (ros::ok())
  {

    visualization_msgs::Marker points, line_strip, line_list;
    points.header.frame_id = line_strip.header.frame_id = line_list.header.frame_id = &quot;/my_frame&quot;;
    points.header.stamp = line_strip.header.stamp = line_list.header.stamp = ros::Time::now();
    points.ns = line_strip.ns = line_list.ns = &quot;points_and_lines&quot;;
    points.action = line_strip.action = line_list.action = visualization_msgs::Marker::ADD;
    points.pose.orientation.w = line_strip.pose.orientation.w = line_list.pose.orientation.w = 1.0;

    points.id = 0;
    line_strip.id = 1;
    line_list.id = 2;

    points.type = visualization_msgs::Marker::POINTS;
    line_strip.type = visualization_msgs::Marker::LINE_STRIP;
    line_list.type = visualization_msgs::Marker::LINE_LIST;

    // POINTS markers use x and y scale for width/height respectively
    points.scale.x = 0.2;
    points.scale.y = 0.2;

    // LINE_STRIP/LINE_LIST markers use only the x component of scale, for the line width
    line_strip.scale.x = 0.1;
    line_list.scale.x = 0.1;

    // Points are green
    points.color.g = 1.0f;
    points.color.a = 1.0;

    // Line strip is blue
    line_strip.color.b = 1.0;
    line_strip.color.a = 1.0;

    // Line list is red
    line_list.color.r = 1.0;
    line_list.color.a = 1.0

    // Create the vertices for the points and lines
    for (uint32_t i = 0; i &amp;lt; 100; ++i)
    {
      float y = 5 * sin(f + i / 100.0f * 2 * M_PI);
      float z = 5 * cos(f + i / 100.0f * 2 * M_PI);

      geometry_msgs::Point p;
      p.x = (int32_t)i - 50;
      p.y = y;
      p.z = z;

      points.points.push_back(p);
      line_strip.points.push_back(p);

      // The line list needs two points for each line
      line_list.points.push_back(p);
      p.z += 1.0;
      line_list.points.push_back(p);
    }

    marker_pub.publish(points);
    marker_pub.publish(line_strip);
    marker_pub.publish(line_list);

    r.sleep();
    f += 0.04;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;interactive-markers&quot;&gt;&lt;a href=&quot;https://wiki.ros.org/rviz/Tutorials/InteractiveMarkers%3AGettingStarted&quot;&gt;Interactive Markers&lt;/a&gt;&lt;/h3&gt;

&lt;h1 id=&quot;urdf&quot;&gt;&lt;a href=&quot;https://wiki.ros.org/urdf&quot;&gt;urdf&lt;/a&gt;&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;URDF（Unified Robot Description Format，统一机器人描述格式）是ROS中一个非常重要的机器人模型描述格式。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;apt-get install urdf_tutorial
roslaunch urdf_tutorial display.launch model:=urdf/01-myfirst.urdf
roslaunch urdf_tutorial display.launch model:='$(find urdf_tutorial)/urdf/01-myfirst.urdf'
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;gazebo&quot;&gt;&lt;a href=&quot;http://gazebosim.org/tutorials&quot;&gt;gazebo&lt;/a&gt;&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;gazebo是一款功能强大的三维物理仿真平台，其中的机器人模型与rviz使用的模型相同，但是需要在模型中加入机器人和周围环境的物理属性，例如质量、摩擦系数、弹性系数等。机器人的传感器信息也可以通过插件的形式加入仿真环境，以可视化的方式进行显示。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;gazebo
gazebo worlds/pioneer2dx.world
# gzserver可执行文件运行物理更新循环和传感器数据生成。这是gazebo的核心，可以独立于图形界面使用。
gzserver
# gzclient可执行文件运行QT基于用户界面。
gzclient
&lt;/code&gt;&lt;/pre&gt;</content><author><name></name></author><category term="ros" /><summary type="html">Launch</summary></entry></feed>