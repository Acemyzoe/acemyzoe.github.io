<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="https://acemyzoe.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://acemyzoe.github.io/" rel="alternate" type="text/html" /><updated>2020-08-15T20:23:24+08:00</updated><id>https://acemyzoe.github.io/feed.xml</id><title type="html">Acemyzoe</title><subtitle>人类世界&lt;br/&gt;
真是&lt;br/&gt;
太有趣了&lt;br/&gt;
QAQ&lt;br/&gt;
&lt;a href=&quot;mailto:acemyzoe@outlook.com&quot;&gt;
  &lt;i class=&quot;fas fa-envelope&quot;&gt;&lt;/i&gt;
&lt;/a&gt;
&lt;a href=&quot;https://github.com/acemyzoe&quot;&gt;
  &lt;i class=&quot;fab fa-github&quot;&gt;&lt;/i&gt;
&lt;/a&gt;
&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=100% height=52 src=&quot;//music.163.com/outchain/player?type=2&amp;id=486806&amp;auto=1&amp;height=32&quot;&gt;&lt;/iframe&gt;
</subtitle><entry><title type="html">java基础语法</title><link href="https://acemyzoe.github.io/_posts/2020-08-01-java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/" rel="alternate" type="text/html" title="java基础语法" /><published>2020-08-01T00:00:00+08:00</published><updated>2020-08-01T00:00:00+08:00</updated><id>https://acemyzoe.github.io/_posts/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95</id><content type="html" xml:base="https://acemyzoe.github.io/_posts/2020-08-01-java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/">&lt;h1 id=&quot;java语法&quot;&gt;JAVA语法&lt;/h1&gt;

&lt;h2 id=&quot;hello-world&quot;&gt;hello world&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;在 Java 中，所有的代码都必须写在类里面，定义一个 HelloWorld 类。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;/* hello world demo */
public class HelloWorld{
    public static void main(String []args){
        System.out.println(&quot;Hello World!&quot;); // 打印
    }
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;基本数据类型&quot;&gt;基本数据类型&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;整型类型：byte（字节）、short（短整型）、int（整型）、long（长整型）&lt;/li&gt;
  &lt;li&gt;浮点类型：float（单精度浮点）、double（双精度浮点）&lt;/li&gt;
  &lt;li&gt;字符型：char&lt;/li&gt;
  &lt;li&gt;布尔型：boolean&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;封装这些基本数据类型的类&quot;&gt;封装这些基本数据类型的类&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Integer：对应封装了基本类型 int&lt;/li&gt;
  &lt;li&gt;Long：对应封装了基本类型 long&lt;/li&gt;
  &lt;li&gt;Float：对应封装了基本类型 float&lt;/li&gt;
  &lt;li&gt;Double：对应封装了基本类型 double&lt;/li&gt;
  &lt;li&gt;Boolean：对应封装了基本类型 boolean&lt;/li&gt;
  &lt;li&gt;String：对应封装了字符串类型 char[]&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;int a = 6;
Integer oa = new Integer(6);
int a[] = new int[10]; //定义长度为10的int类型数组
a[1] = 3;
System.out.println(a[2])
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;流程控制&quot;&gt;流程控制&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;/* if-else */
int a;
if (a&amp;gt;1){
    //todo
} else if (a=1){
    //todo
} else{
    //todo
}

/* switch-case */
switch (a) {
    case 1:
        //todo
        break;
    case 2:
        //todo
        break;
    default:
        //default
}

/*  for/while */
for (int i = 0; i &amp;lt; 10; ++i) {
    if(i==4){
        continue;//跳出本次循环
    }
    if(i==3){
        break;//提前终止循环
    }
}

while (i&amp;lt;10) {
    //todo
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;类对象&quot;&gt;类、对象&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class Dog {
    private int age;
    private int weight;
    
    public Dog(int age,int weight){//构造函数，命名同类名
        this.age=age;
        this.weight=weight;
    }
    
    public int getAge(){
        return age;
    }
    
    public void run(){
        //todo
    }
}

Dog dog1 = new Dog(2,111); //通过new创建一个Dog对象
int age = dog1.getAge();
dog1.run();
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;权限修饰符&quot;&gt;权限修饰符&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;private 修饰的函数或者成员变量，只能在类内部使用。&lt;/li&gt;
  &lt;li&gt;protected 修饰的函数或者成员变量，可以在类及其子类内使用。&lt;/li&gt;
  &lt;li&gt;public 修饰的函数或者成员变量，可以被任意访问。&lt;/li&gt;
  &lt;li&gt;权限修饰符还可以修饰类&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;继承&quot;&gt;继承&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Java 语言使用 extends 关键字来实现继承&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class Animal {//父类
    protected int age;//protected
    protected int weight;
    
    public Animal(int age,int weight){
        this.age=age;
        this.weight=weight;
    }
    
    public int getAge(){
        return age;
    }
}

public class Dog extends Animal {//子类
    public Dog(int age,int weight){
        super(age,weight);//调用父类的构造函数
    }
    
    public void wang(){
        //...
    }
}

Dog dog1 = new Dog(2,22);
dog1.run();
dog1.wang();
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;接口&quot;&gt;接口&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Java 语言通过 interface 关键字来定义接口。&lt;/p&gt;

  &lt;p&gt;接口中只能声明方法，不能包含实现，也不能定义属性。&lt;/p&gt;

  &lt;p&gt;类通过 implements 关键字来实现接口中定义的方法。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public interface Runable{
    void run();
}

public class Dog implements Runable {
    private int age;
    private int weight;
    
    public Dog(int age,int weight){
        this.age=age;
        this.weight=weight;
    }
    
    public int getAge(){
        return age;
    }
    
    @Override
    public void run(){//实现接口中定义的run方法
        //todo
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;容器&quot;&gt;容器&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;容器可以理解为一些工具类，底层封装了各种数据结构。&lt;/p&gt;

  &lt;p&gt;如 ArrayList 底层就是数组，LinkedList 底层就是链表，HashMap 底层就是散列表等&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class DemoA{
    private ArrayList&amp;lt;User&amp;gt; users;
    public void addUser(User user){
        users.add(user);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;异常处理&quot;&gt;异常处理&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;通过关键字 throw 来抛出一个异常，&lt;/p&gt;

  &lt;p&gt;通过 throws 声明函数抛出异常，&lt;/p&gt;

  &lt;p&gt;通过 try-catch-finally 语句来捕获异常。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class UserNotFoundException extends Exception{//自定义一个异常
    public UserNotFoundException(){
        super();
    }
    public UserNotFoundException(String message){
        super(message);
    }
    public UserNotFoundException(String message,Throwable e){
        super(message,e);
    }
}

public class UserService{
    private UserRepository uerRepo;
    public UserService(UseRepository userRepo){
        this.userRepo = userRepo;
    }
    public User getUserById(long userId) throws UserNotFoundException{
        User user = userRepo.findUserById(userId);
        if (user == null){// throw用来抛出异常
            throw new UserNotFoundException();// 代码从此处返回
        }
    }
}

public class UserController{
    private UserService userService;
    public UserController(UserService userService){
        this.userService = userService;
    }
    public User getUserById(long userId){
        User user = null;
        try{// 捕获异常
            user = userService.getUserById(userId);
        } catch (UserNotFoundException e){
            System.out.println(&quot;User not found: &quot; + userId);
        } finally {// 不管异常会不会发生，finally包裹的语句块总会被执行
            System.out.println(&quot;I am always printed.&quot;);
        }
        return user;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;package包&quot;&gt;package包&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Java 通过 pacakge 关键字来分门别类地组织类，通过 import 关键字来引入类或者package。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;/*class DemoA*/
package com.xzg.cd; // 包名 com.xzg.cd
public class DemoA{
    //...
}
/*class DemoB*/
package com.xzg.alg;
import java.util.HashMap; // Java 工具包JDK中的类
import java.util.Map;
import com.xzg.cd.DemoA;
public class DemoB{
    //...
}
&lt;/code&gt;&lt;/pre&gt;</content><author><name></name></author><category term="java" /><summary type="html">JAVA语法</summary></entry><entry><title type="html">python Interview</title><link href="https://acemyzoe.github.io/_posts/2020-08-01-python-interview/" rel="alternate" type="text/html" title="python Interview" /><published>2020-08-01T00:00:00+08:00</published><updated>2020-08-01T00:00:00+08:00</updated><id>https://acemyzoe.github.io/_posts/python%20interview</id><content type="html" xml:base="https://acemyzoe.github.io/_posts/2020-08-01-python-interview/">&lt;h1 id=&quot;python-interview&quot;&gt;python Interview&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;工作中真正的核心竞争力：写出整洁的代码和架构，面向对象的思维(原则与设计)，模式的使用。以及复杂性解决方法，抽象、分治、领域设计。&lt;/p&gt;

  &lt;p&gt;语言的特性，底层的原理，源码等特定细节的东西可以在使用时再去调研，但解决问题的能力，整洁的代码和架构并不是短期可以突击的。&lt;/p&gt;

  &lt;p&gt;系统：语言Python，Linux基础操作，SQL，消息队列，GIT…木桶理论&lt;/p&gt;

  &lt;p&gt;基础功扎实，新东西学得快，代码写得溜，命令敲得顺，bug解的好&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;基础语法&quot;&gt;基础语法&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;可变与不可变类型&lt;/li&gt;
  &lt;li&gt;浅拷贝与深拷贝的实现方式、区别；deepcopy如果你来设计，如何实现；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;__new__() 与 __init__()&lt;/code&gt;的区别；&lt;/li&gt;
  &lt;li&gt;你知道几种设计模式；&lt;/li&gt;
  &lt;li&gt;编码和解码你了解过么；&lt;/li&gt;
  &lt;li&gt;手写：正则邮箱地址；&lt;/li&gt;
  &lt;li&gt;介绍下垃圾回收：引用计数/分代回收/孤立引用环；&lt;/li&gt;
  &lt;li&gt;多进程与多线程的区别；CPU密集型适合用什么；&lt;/li&gt;
  &lt;li&gt;进程通信的方式有几种；&lt;/li&gt;
  &lt;li&gt;介绍下协程，为何比线程还快；&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;函数参数传递&quot;&gt;函数参数传递&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# Python的函数参数传递
# http://stackoverflow.com/questions/986006/how-do-i-pass-a-variable-by-reference
# 所有的变量都可以理解是内存中一个对象的“引用”

# strings, tuples, 和numbers 不可变对象
a=1
def fun1(a):
    print(id(a),id(1)) # 1798961072 1798961072
    a=2
    print(id(a),id(2)) # 1798961088 1798961088
    print(a) # 2
fun1(a)
print(a) # 1

# list, dict, set 可变对象
b=[]
def fun2(b):
    print(id(b)) # 9174792
    b.append(1)
    print(id(b)) # 9174792
    print(b) #[1]
fun2(b)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;元类&quot;&gt;元类&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 元类 metaclass
# http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python
# 元类是类的类，定义类的行为，常用作类工厂。type是Python用于在幕后创建所有类的元类。
class MyMeta(type):
    '''
        子类将获得一个class属性_order，该属性记录定义类的顺序。
    '''
    counter = 0
    def __init__(cls, name, bases, dic): # name:class名称 bases：父类的元组 dic/attrs：包含属性名称和值的字典
        type.__init__(cls, name, bases, dic)
        cls._order = MyMeta.counter
        MyMeta.counter += 1
class MyType0(metaclass=MyMeta):  
    pass

class MyType1(metaclass=MyMeta):  
    pass

class MyType2(MyMeta):
    pass

print(MyType0._order，MyType1._orderMyType2.counter) # 0 1 2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;类变量和实例变量&quot;&gt;类变量和实例变量&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 类变量和实例变量
class Test(object):  
    num_of_instance = 0  
    name = 'test'
    def __init__(self, name):  
        self.name = name  
        Test.num_of_instance += 1  
  
if __name__ == '__main__':  
    print(Test.name,Test.num_of_instance) # test 0
    t1 = Test('t1')  
    t2 = Test('t2')  
    print(t1.name , t1.num_of_instance) # t1 2
    print(t2.name , t2.num_of_instance) # t2 2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;python自省&quot;&gt;python自省&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 自省
# 运行时能够获得对象的类型.比如type(),dir(),getattr(),hasattr(),isinstance().
a = [1,2,3]
b = {'a':1,'b':2,'c':3}
c = True
print(type(a),type(b),type(c)) # &amp;lt;class 'list'&amp;gt; &amp;lt;class 'dict'&amp;gt; &amp;lt;class 'bool'&amp;gt;
print(isinstance(a,list))  # True
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;推导式&quot;&gt;推导式&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 推导式
# 列表推导式list
li=[i*2 for i in range(10) if i % 2 == 0]
print(li)
# 字典推导式dict
m={&quot;a&quot;:1, &quot;b&quot;:2, &quot;c&quot;:3, &quot;d&quot;:4}
di={v:k for k,v in m.items()}
print(di)
# 集合推导式set
# 集合是一种无重复无序的序列
s={i*2 for i in [1,1,2]}
print(s)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;单下划线和双下划线&quot;&gt;单下划线和双下划线&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 单下划线和双下划线
# http://stackoverflow.com/questions/1301346/the-meaning-of-a-single-and-a-double-underscore-before-an-object-name-in-python
class MyClass():
    def __init__(self):
            self.__superprivate = &quot;Hello&quot;  # 解释器将其替换为对象名._类名__xxx
            self._semiprivate = &quot;, world!&quot; # 用来指定变量私有

my = MyClass()
print(my.__dict__)
print(my._MyClass__superprivate)
print(my._semiprivate)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;迭代器和生成器&quot;&gt;迭代器和生成器&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 迭代器和生成器
# https://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do
# 列表可一一阅读它的项目。逐一读取其项称为迭代,所有值存储在内存。
# 生成器：边循环，边计算的机制—&amp;gt;generator
l = [x*x for x in range(10)] 
g = (x*x for x in range(10))
print(type(l),type(g)) # &amp;lt;class 'list'&amp;gt; &amp;lt;class 'generator'&amp;gt;
# itertools模块包含用于操纵可迭代对象的特殊功能
import itertools
horses=[1,2,3]
races = itertools.permutations(horses)
print(list(races)) # 三匹马比赛的可能到达顺序
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;args-and-kwargs&quot;&gt;*args and **kwargs&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# *args and **kwargs
# https://stackoverflow.com/questions/3394835/use-of-args-and-kwargs
# 用*args传递任意数量的参数
def print_everything(*args):
    for count, thing in enumerate(args):
        print('{0}. {1}'.format(count, thing))
print_everything('1','a')
# **kwargs为函数提供任意关键字参数,并将它们作为字典使用。
def table_things(**kwargs):
    for name, value in kwargs.items():
        print('{0}={1}'.format(name, value))
table_things(apple='fruit', cabbage='vegetable')
# 调用函数时用*和**语法
def print_three_things(a, b, c):
    print('a={0}, b={1}, c={2}'.format(a,b,c))
mylist = ['1', '2', '3']
print_three_things(*mylist)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;面向切面编程aop和装饰器&quot;&gt;面向切面编程AOP和装饰器&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 面向切面编程AOP和装饰器
# 装饰器的作用就是为已经存在的对象添加额外的功能,经常被用于有切面需求的场景
# https://stackoverflow.com/questions/739654/how-to-make-a-chain-of-function-decorators
'''装饰器只是语法糖
@decorator
def func():
    ...
等效于
def func():
    ...
func = decorator(func)
'''
###############################
# The decorator to make it bold
def makebold(fn):
    # The new function the decorator returns
    def wrapper():
        # Insertion of some code before and after
        return &quot;&amp;lt;b&amp;gt;&quot; + fn() + &quot;&amp;lt;/b&amp;gt;&quot;
    return wrapper

# The decorator to make it italic
def makeitalic(fn): 
    return lambda: &quot;&amp;lt;i&amp;gt;&quot; + fn() + &quot;&amp;lt;/i&amp;gt;&quot;

@makebold
@makeitalic
def say():
    return &quot;hello&quot;
print(say())
#################################
# This is the exact equivalent to
def says():
    return &quot;hello&quot;
my = makebold(makeitalic(says))
print(my())

class sty(object):
  def __init__(self, tag):
    self.tag = tag
  def __call__(self, f):
    def newf():
      return &quot;&amp;lt;{tag}&amp;gt;{res}&amp;lt;/{tag}&amp;gt;&quot;.format(res=f(), tag=self.tag)
    return newf

@sty('b')
@sty('i')
def sayhi():
  return 'hi'
print(sayhi())
###################################
# 使用functools.wraps
from functools import wraps
def wrap_in_tag(tag):
    def factory(func):
        @wraps(func)
        def decorator(val):
            return func('&amp;lt;%(tag)s&amp;gt;%(val)s&amp;lt;/%(tag)s&amp;gt;' %
                        {'tag': tag, 'val': val})
        return decorator
    return factory

@wrap_in_tag('b')
@wrap_in_tag('i')
def log(s):
    return s
print(log('hello')) # &amp;lt;b&amp;gt;&amp;lt;i&amp;gt;hello&amp;lt;/i&amp;gt;&amp;lt;/b&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;鸭子类型-duck-typing&quot;&gt;鸭子类型 duck typing&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。&lt;/p&gt;

  &lt;p&gt;一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由”当前方法和属性的集合”决定。&lt;/p&gt;

  &lt;p&gt;鸭子类型是多态性的一种表现，函数可以通过鸭子类型来处理不同类型的对象，函数重载在动态语言中就显得没有意义。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;python不支持函数重载&quot;&gt;Python不支持函数重载&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;函数重载主要是为了解决两个问题。&lt;/p&gt;

  &lt;ol&gt;
    &lt;li&gt;可变参数类型。而 python 可以接受任何类型的参数。&lt;/li&gt;
    &lt;li&gt;可变参数个数。而 python 使用缺省参数。&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;__new__和__init__的区别&quot;&gt;&lt;code&gt;__new__&lt;/code&gt;和&lt;code&gt;__init__&lt;/code&gt;的区别&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;&lt;code&gt;__new__&lt;/code&gt;是一个静态方法,而&lt;code&gt;__init__&lt;/code&gt;是一个实例方法.&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;__new__&lt;/code&gt;方法会返回一个创建的实例,而&lt;code&gt;__init__&lt;/code&gt;什么都不返回.&lt;/li&gt;
    &lt;li&gt;只有在&lt;code&gt;__new__&lt;/code&gt;返回一个cls的实例时后面的&lt;code&gt;__init__&lt;/code&gt;才能被调用.&lt;/li&gt;
    &lt;li&gt;当创建一个新实例时调用&lt;code&gt;__new__&lt;/code&gt;,初始化一个实例时用&lt;code&gt;__init__&lt;/code&gt;.&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;__new__&lt;/code&gt;除非要继承不可变类型（例如str，int，unicode或tuple），否则无需重写&lt;/li&gt;
    &lt;li&gt;可以分别使用&lt;code&gt;__metaclass__&lt;/code&gt;,&lt;code&gt;__new__&lt;/code&gt;和&lt;code&gt;__init__&lt;/code&gt;来分别在类创建,实例创建和实例初始化的时候做一些小手脚.&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;单例模式&quot;&gt;单例模式&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 使用__new__方法
class Singleton(object):
    def __new__(cls, *args, **kw):
        if not hasattr(cls, '_instance'):
            orig = super(Singleton, cls)
            cls._instance = orig.__new__(cls, *args, **kw)
        return cls._instance
class MyClass(Singleton):
    a = 1

# 共享属性:创建实例时把所有实例的__dict__指向同一个字典
class Borg(object):
    _state = {}
    def __new__(cls, *args, **kw):
        ob = super(Borg, cls).__new__(cls, *args, **kw)
        ob.__dict__ = cls._state
        return ob
class MyClass2(Borg):
    a = 1

# 装饰器版本
def singleton(cls):
    instances = {}
    def getinstance(*args, **kw):
        if cls not in instances:
            instances[cls] = cls(*args, **kw)
        return instances[cls]
    return getinstance
@singleton
class MyClass:
    a = 1

# import方法,作为python的模块是天然的单例模式
# mysingleton.py
class My_Singleton(object):
    def foo(self):
        pass
my_singleton = My_Singleton()
# to use
from mysingleton import my_singleton
my_singleton.foo()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;gil线程全局锁global-interpreter-lock&quot;&gt;GIL线程全局锁Global Interpreter Lock&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Python为了保证线程安全而采取的独立线程运行的限制,一个核只能在同一时间运行一个线程。&lt;/p&gt;

  &lt;p&gt;https://www.oschina.net/translate/pythons-hardest-problem&lt;/p&gt;

  &lt;p&gt;对于io密集型任务，python的多线程起到作用，但对于cpu密集型任务，python的多线程几乎占不到任何优势，还有可能因为争夺资源而变慢。&lt;/p&gt;

  &lt;p&gt;解决办法就是多进程和协程。&lt;/p&gt;

  &lt;p&gt;协程是进程和线程的升级版,进程和线程都面临着内核态和用户态的切换问题而耗费许多切换时间,而协程就是用户自己控制切换的时机,不再需要陷入系统的内核态。Python里最常见的yield就是协程的思想&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# yield是与return一样使用的关键字return，不同之处在于该函数将返回生成器。
# 第一次for调用从函数创建的生成器对象时，它将从头开始运行函数中的代码，直到命中yield，然后它将返回循环的第一个值。然后，每个后续调用将运行您在函数中编写的循环的另一个迭代，并返回下一个值。这将一直持续到生成器被认为是空的为止，这在函数运行时没有命中时就会发生yield。
def createGenerator():
    mylist = range(3)
    for i in mylist:
        yield i*i
mygenerator = createGenerator()# 在调用该函数时，在函数主体中编写的代码不会运行。该函数仅返回生成器对象
for i in mygenerator:
    print(i)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;闭包closure&quot;&gt;闭包closure&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 闭包
# https://zhuanlan.zhihu.com/p/22229197
# 在一个内部函数中，对外部作用域的变量进行引用，(并且一般外部函数的返回值为内部函数)
# 闭包作用：函数运行后并不会被撤销，用于保存当前的运行环境
def start(x):
    def increment(y): # 闭包
        return x+y
    return increment
a = start(1)
print(a) # &amp;lt;function start.&amp;lt;locals&amp;gt;.increment at 0x0384CC40&amp;gt;
print(a(1)) # 2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;python函数式编程&quot;&gt;Python函数式编程&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# Python函数式编程
# https://coolshell.cn/articles/10822.html
# lambda匿名函数
a = map(lambda x:x*2,[1,2,3]) # map函数是对一个序列的每个项依次执行函数
print((a))
b = filter(lambda x: x &amp;gt; 5, a) 
# filter函数的功能相当于过滤器。
# 调用一个布尔函数bool_func来迭代遍历每个seq中的元素；返回一个使bool_seq返回值为true的元素的序列
print(list(b))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;python里的拷贝&quot;&gt;Python里的拷贝&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 引用和copy(),deepcopy()的区别
# https://www.geeksforgeeks.org/copy-python-deep-copy-shallow-copy/
import copy
a = [1, 2, 3, 4, ['a', 'b']]  #原始对象

b = a  #赋值，传对象的引用
c = copy.copy(a)  #对象拷贝，浅拷贝
d = copy.deepcopy(a)  #对象拷贝，深拷贝

a.append(5)  #修改对象a
a[4].append('c')  #修改对象a中的['a', 'b']数组对象

print('原始对象a = ',a) # [1, 2, 3, 4, ['a', 'b', 'c'], 5]
print('引用b = ',b) # [1, 2, 3, 4, ['a', 'b', 'c'], 5]
print('浅拷贝c = ',c) # [1, 2, 3, 4, ['a', 'b', 'c']]
print('深拷贝d = ',d) # [1, 2, 3, 4, ['a', 'b']]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;python垃圾回收机制&quot;&gt;Python垃圾回收机制&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# Python垃圾回收机制
# https://sutune.me/2018/10/14/python-GC/
# https://juejin.im/post/6844903629556547598
# http://www.ityouknow.com/python/2020/01/06/python-gc-111.html
# Python GC主要使用引用计数（reference counting）来跟踪和回收垃圾
# 通过“标记-清除”（mark and sweep）解决容器对象可能产生的循环引用问题
# 通过“分代回收”（generation collection）以空间换时间的方法提高垃圾回收效率

# 『引用计数法』的原理是：每个对象维护一个ob_ref字段，用来记录该对象当前被引用的次数，每当新的引用指向该对象时，它的引用计数ob_ref加1，每当该对象的引用失效时计数ob_ref减1，一旦对象的引用计数为0，该对象立即被回收，对象占用的内存空间将被释放。
# 循环引用导致内存泄露。解决方法：gc模块提供一个接口给开发者设置垃圾回收的选项
import sys
import gc
class A():
    def __init__(self):
        '''初始化对象'''
        print('object born id:%s' %str(hex(id(self))))

def func(c):
    print('obejct refcount is: ',sys.getrefcount(c)) #getrefcount()方法用于返回对象的引用计数

def fnrc():
    #生成对象
    a=A()
    func(a)
    #增加引用
    b=a
    func(a)
    #销毁引用对象b
    del b
    func(a)

def fngc():  
    '''垃圾自动回收'''
    gc.isenabled = True  
    print(gc.get_count())
    a=A()
    print(gc.get_count())
    del a
    print(gc.get_count())

if __name__ == '__main__':
    fngc()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;python中list是如何实现的&quot;&gt;Python中list是如何实现的&lt;/h2&gt;

&lt;p&gt;https://www.jianshu.com/p/J4U6rR&lt;/p&gt;

&lt;h2 id=&quot;python的is&quot;&gt;Python的is/==&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# is 与 == 的区别
# https://stackoverflow.com/questions/132988/is-there-a-difference-between-and-is
# https://stackoverflow.com/questions/26595/is-there-any-difference-between-foo-is-none-and-foo-none
a=1000
b=1e3
c=1000.0
print(a is b) # False
print(a is c) # False
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;python2和3的区别&quot;&gt;Python2和3的区别&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/	
from __future__ import division,unicode_literals
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;数据结构算法&quot;&gt;数据结构&amp;amp;算法&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;手写：已知一个长度n的无序列表，元素均是数字，要求把所有间隔为d的组合找出来，你写的解法算法复杂度多少；&lt;/li&gt;
  &lt;li&gt;手写：一个列表A=[A1，A2，…,An]，要求把列表中所有的组合情况打印出来；&lt;/li&gt;
  &lt;li&gt;手写：用一行python写出1+2+3+…+10**8 ；&lt;/li&gt;
  &lt;li&gt;手写python：用递归的方式判断字符串是否为回文；&lt;/li&gt;
  &lt;li&gt;单向链表长度未知，如何判断其中是否有环；&lt;/li&gt;
  &lt;li&gt;单向链表如何使用快速排序算法进行排序；&lt;/li&gt;
  &lt;li&gt;手写：一个长度n的无序数字元素列表，如何求中位数，如何尽快的估算中位数，你的算法复杂度是多少；&lt;/li&gt;
  &lt;li&gt;如何遍历一个内部未知的文件夹（两种树的优先遍历方式）&lt;/li&gt;
  &lt;li&gt;给定一个数组，构建二叉树，并且按层次打印这个二叉树&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;台阶问题斐波那契&quot;&gt;台阶问题/斐波那契&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 方法一
fib = lambda n: n if n&amp;lt;=2 else fib(n-1)+fib(n-2)
# 第二种记忆方法
def memo(func):
    cache = {}
    def wrap(*args):
        if args not in cache:
            cache[args] = func(*args)
        return cache[args]
    return wrap
@memo
def fib(i):
    if i &amp;lt; 2:
        return 1
    return fib(i-1)+fib(i-2)
# 方法三
def fib(n):
    a, b = 0, 1
    for _ in range(n):
        a, b = b, a+b
    return b
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;fib = lambda n: n if n&amp;lt;2 else 2*fib(n-1)
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;用n个&lt;code&gt;2*1&lt;/code&gt;的小矩形无重叠地覆盖一个&lt;code&gt;2*n&lt;/code&gt;的大矩形，总共有多少种方法？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;f = lambda n: 1 if n &amp;lt; 2 else f(n-1) + f(n-2)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;去除列表中的重复元素&quot;&gt;去除列表中的重复元素&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 去除列表中的重复元素
l = [1,1,2,2,3,4]
# 用集合
print(list(set(l)))
# 用字典
print({}.fromkeys(l).keys())
# 列表推导式
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;链表成对调换&quot;&gt;链表成对调换&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4&lt;/code&gt;转换成&lt;code&gt;2-&amp;gt;1-&amp;gt;4-&amp;gt;3&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;合并两个有序列表&quot;&gt;合并两个有序列表&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 尾递归
a = [1,2,3,7]
b = [3,4,5]
def _recursion_merge_sort2(l1, l2, tmp):
    if len(l1) == 0 or len(l2) == 0:
        tmp.extend(l1)
        tmp.extend(l2)
        return tmp
    else:
        if l1[0] &amp;lt; l2[0]:
            tmp.append(l1[0])
            del l1[0]
        else:
            tmp.append(l2[0])
            del l2[0]
        return _recursion_merge_sort2(l1, l2, tmp)
def recursion_merge_sort2(l1, l2):
    return _recursion_merge_sort2(l1, l2, [])
print(recursion_merge_sort2(a,b))

# 循环算法
a = [1,2,3,7]
b = [3,4,5]
def loop_merge_sort(l1, l2):
    tmp = []
    while len(l1) &amp;gt; 0 and len(l2) &amp;gt; 0:
        if l1[0] &amp;lt; l2[0]:
            tmp.append(l1[0])
            del l1[0]
        else:
            tmp.append(l2[0])
            del l2[0]
    tmp.extend(l1)
    tmp.extend(l2)
    return tmp
print(loop_merge_sort(a,b))

# pop弹出
a = [1,2,3,7]
b = [3,4,5]
def merge_sortedlist(a,b):
    c = []
    while a and b:
        if a[0] &amp;gt;= b[0]:
            c.append(b.pop(0))
        else:
            c.append(a.pop(0))
    while a:
        c.append(a.pop(0))
    while b:
        c.append(b.pop(0))
    return c
print(merge_sortedlist(a,b))

# 先合并后排序
a = [1,2,3,7]
b = [3,4,5]
def merge_sort(a,b):
    c=a+b
    c.sort()
    return c
print(merge_sort(a,b))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;python链表&quot;&gt;python链表&lt;/h2&gt;

&lt;p&gt;https://juejin.im/post/6844903672661409800&lt;/p&gt;

&lt;p&gt;https://www.jianshu.com/p/e4000619232b&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 用python中的引用来实现链表
# 节点类
# 功能包括：更新数据，查询数据，更新后继节点和查询后继节点。
class Node(object):
    #初始化，需要传入节点的数据
    def __init__(self, data):
        self.data = data
        self.next = None
    
    #返回节点的数据
    def get_data(self):
        return self.data
    
    #更新节点的数据
    def set_data(self, new_data):
        self.data = new_data
        
    #返回后继节点
    def get_next(self):
        return self.next
    
    #变更后继节点
    def set_next(self, new_next):
        self.next = new_next

# 链表类
# 节点的增加、删除和查询，返回链表的长度，返回链表是否为空等
class Linked_list(object):
    #初始化，头结点为空
    def __init__(self):
        self.head = None
    
    #添加节点，添加的新节点作为新的头结点
    def add(self, data):
        new_node = Node(data)
        new_node.set_next() = self.head
        self.head = new_node
        
    #包含查询，传入值，返回该值在链表中是否存在
    def search(self, data):
        checking = self.head #从头结点开始查询
        while checking != None :
            if checking.get_data() == data: #查找到，返回True
                return True
            checking = checking.get_next() #查询下一个节点
        return False #遍历到最后也未能找到，返回False
        
    #删除节点，将第一个具有传入值的节点从链表中删除
    def remove(self, data):
        checking = self.head #从头结点开始查询
        previous = None #记录前一个节点，头结点的前一个节点为None
        
        while checking != None :
            if checking.get_data() == data: #查找到，跳出查找循环
                break
            previous = checking # 更新前一个节点
            checking = checking.get_next() #查询下一个节点

        if previous == None:# 如果头结点便是查找的节点
            self.head = checking.get_next()
        else: # 查找的节点不在头结点，即，存在前驱节点
            previous.set_next(checking.get_next())       
    
    #判断链表是否为空
    def isEmpty(self):
        return self.head == None
    
    #返回链表长度
    def size(self):
        count = 0
        counting = self.head #从头结点开始计数
        while counting != None :
            count += 1
            counting = counting.get_next()
        return count
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;单链表逆置&quot;&gt;单链表逆置&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Node(object):
    def __init__(self, data=None, next=None):
        self.data = data
        self.next = next

def relink(link):
    pre = link
    cur = link.next
    pre.next = None
    while cur:
        tmp = cur.next
        cur.next = pre
        pre = cur
        cur = tmp
    return pre

link = Node(1, Node(2, Node(3, Node(4))))
root = relink(link)
while root:
    print(root.data)
    root = root.next
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;交叉链表求交点&quot;&gt;交叉链表求交点&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 使用a,b两个list来模拟链表，可以看出交叉点是 7这个节点
a = [1,2,3,7,9,1,5]
b = [4,5,7,9,1,5]
# 从尾开始比较两个链表，如果相交，则从尾开始必然一致，只要从尾开始比较，直至不一致的地方即为交叉点
for i in range(1,min(len(a),len(b))):
    if i==1 and (a[-1] != b[-1]):
        print(&quot;No&quot;)
        break
    else:
        if a[-i] != b[-i]:
            print(&quot;交叉节点：&quot;,a[-i+1])
            break
        else:
            pass

# 构造链表类
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None

def node(l1, l2):
    length1, length2 = 0, 0
    # 求两个链表长度
    while l1.next:
        l1 = l1.next#尾节点
        length1 += 1
    while l2.next:
        l2 = l2.next#尾节点
        length2 += 1

    #如果相交
    if l1.next == l2.next:
        # 长的链表先走
        if length1 &amp;gt; length2:
            for _ in range(length1 - length2):
                l1 = l1.next
            return l1#返回交点
        else:
            for _ in range(length2 - length1):
                l2 = l2.next
            return l2#返回交点
    # 如果不相交
    else:
        return
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;二分查找&quot;&gt;二分查找&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 二分查找
# 给出一个已经排好序的列表,查找指定元素在列表中的位置
def binary_search(list, item):
    low = 0
    high = len(list) - 1
    while low &amp;lt;= high:
        mid = int((high-low)/2+low) # 避免(high+low)/2溢出
        guess = list[mid]
        if guess &amp;gt; item:
            high = mid - 1
        elif guess &amp;lt; item:
            low = mid + 1
        else:
            return mid
    return None
mylist = [1,3,5,7,9]
print(binary_search(mylist, 3))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;排序&quot;&gt;排序&lt;/h2&gt;

&lt;h3 id=&quot;冒泡排序-on2&quot;&gt;冒泡排序 O(n^2)&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 冒泡排序
def bubble_sort(list):
    if len(list)&amp;gt;2:
        for i in range(len(list)):
            flag=False
            for j in range(1,len(list)):
                if list[j] &amp;lt; list[j-1]:
                    list[j],list[j-1]=list[j-1],list[j] 
                    flag=True
            if flag is False: # 优化
                return list             
    return list
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;选择排序-on2&quot;&gt;选择排序 O(n^2)&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 选择排序
# 找到数组中最小的元素，然后往新数组里追加，时间复杂度O(n^2)
def min_index(list):
    min_index = 0
    min_value = list[min_index]
    for index,value in enumerate(list):
        if value&amp;lt;min_value:
            min_value=value
            min_index=index
    return min_index
def select_sort(list):
    new_list = []
    for i in range(len(list)):
        new_list.append(list.pop(min_index(list)))
        '''等效于
        new_list.append(min(list))
        list.remove(min(list))
        '''
    return new_list

# 方法二
def selectSort(list):
    for i in range(len(list)):
        min_index = i
        for j in range(i+1,len(list)):  # 这个循环会找到值比第i个索引所代表值小的索引
            if list[j] &amp;lt; list[min_index]:
                min_index = j
        list[i] ,list[min_index] = list[min_index], list[i]  # 互换两个索引位置
    return list

# 方法三，更加简便，但是注意和冒泡法进行区分
def selectSort(list):
    for i in range(len(list)):
        for j in range(len(list)-i):
            if list[i] &amp;gt; list[i+j]:
                list[i],list[i+j] = list[i+j],list[i]
    return list
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;快速排序-onlogn&quot;&gt;快速排序 O(n*logn)&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 快排 分片的思想+递归的思想，
# 栈高为O(log(n)),栈长O(n),运行时间为栈高x栈长，O(nlog(n))

def quickSort(list):
    if len(list) &amp;lt; 2:
        return list # 基线条件为空或者只包含一个元素的数组是有序的
    else:
        pivot = list[0] # 递归条件
        less = [i for i in list[1:] if i &amp;lt; pivot]
        greater = [j for j in list[1:] if j &amp;gt;= pivot]
        return quickSort(less) + [pivot] + quickSort(greater)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;插入排序-on2&quot;&gt;插入排序 O(n^2)&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 直接插入排序
# 每一步都将一个待排数据按其大小插入到已经排序的数据中的适当位置，直到全部插入完毕。
def insertSort(list):
    len_ = len(list)
    for i in range(1,len_):  
        for j in range(i):
            if list[i] &amp;lt; list[j]:
                list.insert(j,list[i])  # 首先碰到第一个比自己大的数字，赶紧刹车，停在那，所以选择insert
                list.pop(i+1)  # 因为前面的insert操作，所以后面位数+1，这个位置的数已经insert到前面去了，所以pop弹出
                break
    return list
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;希尔排序--onlogn&quot;&gt;希尔排序  O(nlogn)&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 希尔(Shell)排序又称为缩小增量排序，它是一种插入排序。它是直接插入排序算法的一种威力加强版
def shell_sort(list):
    n = len(list)
    gap = n//2  # 初始步长
    while gap &amp;gt; 0:
        for i in range(gap,n): # 插排
            for j in range(i):
                if list[i]&amp;lt;list[j]:
                    list.insert(j,list[i])
                    list.pop(i+1)
                    break       
        gap = gap//2  # 得到新的步长       
    return list
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;归并排序-onlogn&quot;&gt;归并排序 O(nlogn)&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 归并排序
# 使用分割的办法将这个序列分割成一个个已经排好序的子序列。然后再利用归并的方法将一个个的子序列合并成排序好的序列
def merge(left,right): # 合并的过程
    result = []
    while left and right:
        result.append(left.pop(0) if left[0] &amp;lt;= right[0] else right.pop(0))
    while left:
        result.append(left.pop(0))
    while right:
        result.append(right.pop(0))       
    return result

def mergeSort(list):
    if len(list) &amp;lt; 2:
        return list
    mid_index = len(list)//2
    left = mergeSort(list[:mid_index])  # 递归拆解的过程
    right = mergeSort(list[mid_index:])
    return merge(left,right)  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;堆排序-onlogn&quot;&gt;堆排序 O(nlogn)&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 堆排
def MAX_Heapify(heap,HeapSize,root):#在堆中做结构调整使得父节点的值大于子节点
    left = 2*root + 1
    right = left + 1
    larger = root
    if left &amp;lt; HeapSize and heap[larger] &amp;lt; heap[left]:
        larger = left
    if right &amp;lt; HeapSize and heap[larger] &amp;lt; heap[right]:
        larger = right
    if larger != root:#如果做了堆调整则larger的值等于左节点或者右节点的，这个时候做对调值操作
        heap[larger],heap[root] = heap[root],heap[larger]
        MAX_Heapify(heap, HeapSize, larger)

def Build_MAX_Heap(heap):#构造一个堆，将堆中所有数据重新排序
    HeapSize = len(heap)
    for i in range((HeapSize -2)//2,-1,-1):#从后往前出数
        MAX_Heapify(heap,HeapSize,i)

def HeapSort(heap):#将根节点取出与最后一位做对调，对前面len-1个节点继续进行对调整过程。
    Build_MAX_Heap(heap)
    for i in range(len(heap)-1,-1,-1):
        heap[0],heap[i] = heap[i],heap[0]
        MAX_Heapify(heap, i, 0)
    return heap
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;二叉树&quot;&gt;二叉树&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 二叉树节点
class Node(object):
    def __init__(self, value, left=None, right=None):
        self.value = value
        self.left = left
        self.right = right
tree = Node(1,Node(2),Node(3))
tree1 = Node(1, Node(3, Node(7, Node(0)), Node(6)), Node(2, Node(5), Node(4)))

# 深度优先遍历DFS
# 从根节点出发，沿着左子树方向进行纵向遍历，直到找到叶子节点为止。然后回溯到前一个节点，进行右子树节点的遍历，直到遍历完所有可达节点为止。
def dfs(root):
    if not root:
        return
    print(root.value)
    dfs(root.left)
    dfs(root.right)

# 广度优先遍历BFS / 层次遍历
# 从根节点出发，在横向遍历二叉树层段节点的基础上纵向遍历二叉树的层次。
def bfs(root):
    row = [root]
    while row:
        for i in range(len(row)):
            print(row[i].value)
        row = [kid for item in row for kid in (item.left, item.right) if kid]
        

# 中序遍历:遍历左子树,访问当前节点,遍历右子树
def mid_travelsal(root):
    if root.left is not None:
        mid_travelsal(root.left)
    #访问当前节点
    print(root.value)
    if root.right is not None:
        mid_travelsal(root.right)

# 前序遍历:访问当前节点,遍历左子树,遍历右子树
def pre_travelsal(root):
    print (root.value)
    if root.left is not None:
        pre_travelsal(root.left)
    if root.right is not None:
        pre_travelsal(root.right)

# 后序遍历:遍历左子树,遍历右子树,访问当前节点
def post_trvelsal(root):
    if root.left is not None:
        post_trvelsal(root.left)
    if root.right is not None:
        post_trvelsal(root.right)
    print (root.value)

# 最大树深
def maxDepth(root):
        if not root:
            return 0
        return max(maxDepth(root.left), maxDepth(root.right)) + 1

# 判断俩树是否相同
def isSameTree(p, q):
    if p == None and q == None:
        return True
    elif p and q :
        return p.value == q.value and isSameTree(p.left,q.left) and isSameTree(p.right,q.right)
    else :
        return False

# 已知前序中序求后序
def rebuild(pre, center): # 还原二叉树
    if not pre:
        return
    cur = Node(pre[0]) # 前序遍历的第一个值就是根节点
    index = center.index(pre[0]) # 在中序遍历中找到这个值
    cur.left = rebuild(pre[1:index + 1], center[:index]) # 值的左边为左子树部分前序遍历结果
    cur.right = rebuild(pre[index + 1:], center[index + 1:]) # 值的右边为右子树部分前序遍历结果
    return cur
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;判断两个字符串是否是变位词&quot;&gt;判断两个字符串是否是变位词&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Anagram:
    &quot;&quot;&quot;判断两个字符串是否是变位词
    @:param s1: The first string
    @:param s2: The second string
    @:return true or false
    &quot;&quot;&quot;
    def Solution1(s1,s2):
        alist = list(s2)
        pos1 = 0
        stillOK = True
        while pos1 &amp;lt; len(s1) and stillOK:
            pos2 = 0
            found = False
            while pos2 &amp;lt; len(alist) and not found:
                if s1[pos1] == alist[pos2]:
                    found = True
                else:
                    pos2 = pos2 + 1
            if found:
                alist[pos2] = None
            else:
                stillOK = False
            pos1 = pos1 + 1
        return stillOK

    def Solution2(s1,s2):
        alist1 = list(s1)
        alist2 = list(s2)
        alist1.sort()
        alist2.sort()
        pos = 0
        matches = True
        while pos &amp;lt; len(s1) and matches:
            if alist1[pos] == alist2[pos]:
                pos = pos + 1
            else:
                matches = False
        return matches

    def Solution3(s1,s2):
        c1 = [0]*26
        c2 = [0]*26
        for i in range(len(s1)):
            pos = ord(s1[i])-ord('a')
            c1[pos] = c1[pos] + 1
        for i in range(len(s2)):
            pos = ord(s2[i])-ord('a')
            c2[pos] = c2[pos] + 1
        j = 0
        stillOK = True
        while j&amp;lt;26 and stillOK:
            if c1[j] == c2[j]:
                j = j + 1
            else:
                stillOK = False
        return stillOK

print(Anagram.Solution1('abcd','dcba'))
print(Anagram.Solution2('abcde','edcbg'))
print(Anagram.Solution3('apple','pleap'))
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;网络基础&quot;&gt;网络基础&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;TCP/IP分别在模型的哪一层：传输层/网络层&lt;/li&gt;
  &lt;li&gt;socket长连接是什么意思；&lt;/li&gt;
  &lt;li&gt;select和epoll你了解么，区别在哪；&lt;/li&gt;
  &lt;li&gt;TIME_WAIT过多是因为什么；&lt;/li&gt;
  &lt;li&gt;http一次连接的全过程：你来说下从用户发起request——到用户接收到response；&lt;/li&gt;
  &lt;li&gt;http连接方式。get和post的区别，你还了解其他的方式么；&lt;/li&gt;
  &lt;li&gt;状态码你知道多少，比如200/403/404/504等等；&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;三次握手&quot;&gt;三次握手&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;客户端通过向服务器端发送一个SYN来创建一个主动打开，作为三次握手的一部分。客户端把这段连接的序号设定为随机数 A。&lt;/li&gt;
  &lt;li&gt;服务器端应当为一个合法的SYN回送一个SYN/ACK。ACK 的确认码应为 A+1，SYN/ACK 包本身又有一个随机序号 B。&lt;/li&gt;
  &lt;li&gt;最后，客户端再发送一个ACK。当服务端受到这个ACK的时候，就完成了三路握手，并进入了连接创建状态。此时包序号被设定为收到的确认号 A+1，而响应则为 B+1。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;四次挥手&quot;&gt;四次挥手&lt;/h2&gt;

&lt;p&gt;​	&lt;em&gt;以客户端断开连接举例&lt;/em&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;客户端发送一个数据分段, 其中的 FIN 标记设置为1. 客户端进入 FIN-WAIT 状态. 该状态下客户端只接收数据, 不再发送数据.&lt;/li&gt;
  &lt;li&gt;服务器接收到带有 FIN = 1 的数据分段, 发送带有 ACK = 1 的剩余数据分段, 确认收到客户端发来的 FIN 信息.&lt;/li&gt;
  &lt;li&gt;服务器等到所有数据传输结束, 向客户端发送一个带有 FIN = 1 的数据分段, 并进入 CLOSE-WAIT 状态, 等待客户端发来带有 ACK = 1 的确认报文.&lt;/li&gt;
  &lt;li&gt;客户端收到服务器发来带有 FIN = 1 的报文, 返回 ACK = 1 的报文确认, 为了防止服务器端未收到需要重发, 进入 TIME-WAIT 状态. 服务器接收到报文后关闭连接. 客户端等待 2MSL 后未收到回复, 则认为服务器成功关闭, 客户端关闭连接.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;arp协议&quot;&gt;ARP协议&lt;/h2&gt;

&lt;p&gt;地址解析协议(Address Resolution Protocol)，其基本功能为透过目标设备的IP地址，查询目标的MAC地址，以保证通信的顺利进行。它是IPv4网络层必不可少的协议，不过在IPv6中已不再适用，并被邻居发现协议（NDP）所替代。&lt;/p&gt;

&lt;h2 id=&quot;幂等-idempotence&quot;&gt;幂等 Idempotence&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;HTTP方法的幂等性是指一次和多次请求某一个资源应该具有同样的&lt;strong&gt;副作用&lt;/strong&gt;。(注意是副作用)&lt;/p&gt;

  &lt;p&gt;&lt;code&gt;GET http://www.bank.com/account/123456&lt;/code&gt;，不会改变资源的状态，不论调用一次还是N次都没有副作用。请注意，这里强调的是一次和N次具有相同的副作用，而不是每次GET的结果相同。&lt;code&gt;GET http://www.news.com/latest-news&lt;/code&gt;这个HTTP请求可能会每次得到不同的结果，但它本身并没有产生任何副作用，因而是满足幂等性的。&lt;/p&gt;

  &lt;p&gt;DELETE方法用于删除资源，有副作用，但它应该满足幂等性。比如：&lt;code&gt;DELETE http://www.forum.com/article/4231&lt;/code&gt;，调用一次和N次对系统产生的副作用是相同的，即删掉id为4231的帖子；因此，调用者可以多次调用或刷新页面而不必担心引起错误。&lt;/p&gt;

  &lt;p&gt;POST所对应的URI并非创建的资源本身，而是资源的接收者。比如：&lt;code&gt;POST http://www.forum.com/articles&lt;/code&gt;的语义是在&lt;code&gt;http://www.forum.com/articles&lt;/code&gt;下创建一篇帖子，HTTP响应中应包含帖子的创建状态以及帖子的URI。两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI；所以，POST方法不具备幂等性。&lt;/p&gt;

  &lt;p&gt;PUT所对应的URI是要创建或更新的资源本身。比如：&lt;code&gt;PUT http://www.forum/articles/4231&lt;/code&gt;的语义是创建或更新ID为4231的帖子。对同一URI进行多次PUT的副作用和一次PUT是相同的；因此，PUT方法具有幂等性。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;restful架构representational-state-transfer&quot;&gt;RESTful架构(Representational State Transfer)&lt;/h2&gt;

&lt;p&gt;http://www.ruanyifeng.com/blog/2011/09/restful.html&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;每一个URI代表一种资源；&lt;/p&gt;

  &lt;p&gt;客户端和服务器之间，传递这种资源的某种表现层；&lt;/p&gt;

  &lt;p&gt;客户端通过四个HTTP动词 GET、POST、PUT、DELETE，对服务器端资源进行操作，实现”表现层状态转化”。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;RPC -&amp;gt; SOAP -&amp;gt; RESTful&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;数据库&quot;&gt;数据库&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;MySQL锁有几种；死锁是怎么产生的；
    &lt;ul&gt;
      &lt;li&gt;悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作&lt;/li&gt;
      &lt;li&gt;乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;为何，以及如何分区、分表；&lt;/li&gt;
  &lt;li&gt;了解join么，有几种，有何区别，A LEFT JOIN B，查询的结果中，B没有的那部分是如何显示的（NULL）；&lt;/li&gt;
  &lt;li&gt;索引类型有几种，BTree索引和hash索引的区别（我没答上来这俩在磁盘结构上的区别）；&lt;/li&gt;
  &lt;li&gt;手写：如何对查询命令进行优化；&lt;/li&gt;
  &lt;li&gt;NoSQL了解么，和关系数据库的区别；redis有几种常用存储类型；&lt;/li&gt;
  &lt;li&gt;谈谈mysql字符集和排序规则？&lt;/li&gt;
  &lt;li&gt;.varchar与char的区别是什么？大小限制？utf8字符集下varchar最多能存多少个字符&lt;/li&gt;
  &lt;li&gt;外键有什么用，是否该用外键？外键一定需要索引吗？&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;数据库索引&quot;&gt;数据库索引&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.codinglabs.org/articles/theory-of-mysql-index.html&quot;&gt;MySQL索引背后的数据结构及算法原理&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;linux&quot;&gt;Linux&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;讲一下你常用的Linux/git命令和作用；&lt;/li&gt;
  &lt;li&gt;查看当前进程是用什么命令，除了文件相关的操作外，你平时还有什么操作命令；&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;项目&quot;&gt;项目&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;简单的介绍下你在公司的项目，不管是不是后端相关的，主要是要体现出你干了什么；&lt;/li&gt;
  &lt;li&gt;你在项目中遇到最难的部分是什么，你是怎么解决的；&lt;/li&gt;
  &lt;li&gt;你看过django的admin源码么；看过flask的源码么；你如何理解开源；&lt;/li&gt;
  &lt;li&gt;MVC / MTV；&lt;/li&gt;
  &lt;li&gt;缓存怎么用；&lt;/li&gt;
  &lt;li&gt;中间件是干嘛的；&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="python" /><summary type="html">python Interview</summary></entry><entry><title type="html">设计模式</title><link href="https://acemyzoe.github.io/_posts/2020-08-01-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="alternate" type="text/html" title="设计模式" /><published>2020-08-01T00:00:00+08:00</published><updated>2020-08-01T00:00:00+08:00</updated><id>https://acemyzoe.github.io/_posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F</id><content type="html" xml:base="https://acemyzoe.github.io/_posts/2020-08-01-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">&lt;blockquote&gt;
  &lt;p&gt;奥卡姆剃刀 ： 如无必要，勿增实体&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;目的：告别写被人吐槽的烂代码，提高复杂代码的设计开发能力，让读源码学框架事半功倍。&lt;/p&gt;

&lt;h1 id=&quot;如何评价代码质量高低&quot;&gt;如何评价代码质量高低？&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;可维护性 maintainability&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;主观、侧面： bug是否容易修复，修改、添加功能是否能够轻松完成。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;可读性 readability&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;代码是否符合编码规范、命名是否达意、注释是否详尽、函数是否长短合适、模块划分是否清晰、是否符合高内聚低耦合等等。&lt;/p&gt;

  &lt;p&gt;code review 测验代码可读性&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;可拓展性 extensibility&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;代码预留了一些功能扩展点，可以把新功能代码直接插到扩展点上。&lt;/p&gt;

  &lt;p&gt;“对修改关闭，对扩展开放”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;灵活性 flexibility&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;代码易扩展、易复用或者易用&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;简洁性 simplicity&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;KISS&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;可复用性 reusability&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;DRY (Don’t Repeat Yourself)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;可测试性 testability&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;思考：函数是较小的可复用单位，面向对象把可复用单位提升到类层次，设计模式把可复用对提升到框架层次。&lt;/p&gt;

&lt;h1 id=&quot;面向对象&quot;&gt;面向对象&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;面向对象中的继承、多态能让我们写出可复用的代码&lt;/p&gt;

  &lt;p&gt;面向对象编程是一种编程范式或编程风格。它以&lt;strong&gt;类或对象&lt;/strong&gt;作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石 。&lt;/p&gt;

  &lt;p&gt;面向对象软件开发：OOA&amp;gt;OOD&amp;gt;OOP (分析&amp;gt;设计&amp;gt;编程)&lt;/p&gt;

  &lt;p&gt;UML(Unified Model Language) 统一建模语言&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;封装抽象继承多态&quot;&gt;封装、抽象、继承、多态&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;封装：隐藏信息、保护数据&lt;/li&gt;
  &lt;li&gt;抽象 : 隐藏方法的具体实现&lt;/li&gt;
  &lt;li&gt;继承：Java 使用extends 关键字，C++ 使用冒号（class B : public A），Python 使用()，Ruby 使用 &amp;lt;。&lt;/li&gt;
  &lt;li&gt;多态：子类可以替换父类。用接口类来实现多态特性；duck-typing(只要两个类具有相同的方法，就可以实现多态)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;面向对象编程-vs-面向过程编程&quot;&gt;面向对象编程 VS 面向过程编程&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;面向过程风格的代码被组织成了一组方法集合及其数据结构，方法和数据结构的定义是分开的。&lt;/li&gt;
  &lt;li&gt;面向对象风格的代码被组织成一组类，方法和数据结构被绑定一起，定义在类中。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;接口-vs-抽象类&quot;&gt;接口 VS 抽象类&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;接口：协议/约定，实现面向对象的抽象多态和基于接口而非实现的设计原则，为了代码复用。
    &lt;ul&gt;
      &lt;li&gt;接口不能包含属性（也就是成员变量）&lt;/li&gt;
      &lt;li&gt;接口只能声明方法，方法不能包含代码实现。&lt;/li&gt;
      &lt;li&gt;类实现接口的时候，必须实现接口中声明的所有方法。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;抽象类：实现面向对象的继承和模板设计模式,侧重于解耦。
    &lt;ul&gt;
      &lt;li&gt;抽象类不允许实例化，只能被继承&lt;/li&gt;
      &lt;li&gt;抽象类可以包含属性和方法&lt;/li&gt;
      &lt;li&gt;子类继承抽象类，必须实现抽象类中的所有抽象方法&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;C++ 只支持抽象类，不支持接口；Python &lt;a href=&quot;https://docs.python.org/zh-cn/3/library/abc.html#module-abc&quot;&gt;&lt;code&gt;abc&lt;/code&gt;&lt;/a&gt; 抽象基类&lt;a href=&quot;https://docs.python.org/zh-cn/3/library/abc.html#module-abc&quot;&gt;¶&lt;/a&gt;(可用普通类/duck-typing来模拟)。&lt;/li&gt;
  &lt;li&gt;表示is-a的关系，为解决代码复用的问题，用抽象类。(先有子类的代码重复，然后再抽象成上层的父类。)&lt;/li&gt;
  &lt;li&gt;表示has-a / behaves like的关系，为解决抽象的问题，用接口。(先设计接口，再去考虑具体的实现。)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;基于接口而非实现编程--基于抽象而非实现编程&quot;&gt;基于接口而非实现编程 / 基于抽象而非实现编程&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;函数的命名不能暴露任何实现细节&lt;/li&gt;
  &lt;li&gt;封装具体的实现细节&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;为实现类定义抽象的接口&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;多用组合少用继承
    &lt;ul&gt;
      &lt;li&gt;继承主要有三个作用：表示 is-a 关系，支持多态特性，代码复用。&lt;/li&gt;
      &lt;li&gt;这三个作用可以通过组合、接口、委托三个技术手段来达成。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;面向过程的贫血模型和面向对象的充血模型&quot;&gt;面向过程的贫血模型和面向对象的充血模型&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;基于贫血模型的 MVC 三层架构开发模式&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Model/View/Controller 展示层、逻辑层、数据层
        &lt;ul&gt;
          &lt;li&gt;后端项目分为 Repository 数据访问、Service业务逻辑 、Controller暴露接口&lt;/li&gt;
          &lt;li&gt;贫血模型的Service层将数据与操作分离&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;blockquote&gt;
      &lt;p&gt;大部分都是SQL 驱动（SQL-Driven）的开发模式。一个后端接口的开发，看接口需要的数据对应到数据库中，需要哪张表或者哪几张表，然后编写 SQL 语句来获取数据。之后就是定义类，然后模板式地往对应的 Repository、Service、Controller 类中添加代码。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;基于充血模型的 DDD (领域驱动设计)开发模式&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;更适合业务复杂的系统开发，比如金融系统&lt;/li&gt;
      &lt;li&gt;DDD ：用来指导如何解耦业务系统，划分业务模块，定义业务领域模型及其交互&lt;/li&gt;
      &lt;li&gt;微服务加速了领域驱动设计的盛行。关键在于对业务的熟悉程度。&lt;/li&gt;
      &lt;li&gt;充血模型的Service层分service和domain，包含数据和业务逻辑&lt;/li&gt;
    &lt;/ul&gt;

    &lt;blockquote&gt;
      &lt;p&gt;应用基于充血模型的 DDD 的开发模式，需要事先理清楚所有的业务，定义领域模型所包含的属性和
方法。领域模型相当于可复用的业务中间层。新功能需求的开发，都基于之前定义好的这些领域模型来完成。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;设计原则&quot;&gt;设计原则&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;设计原则中的单一职责、DRY、基于接口而非实现、里式替换原则等，可以让我们写出可复用、灵活、可性好、易扩展、易维护的代码；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;solid-原则--srp&quot;&gt;SOLID 原则 -SRP&lt;/h2&gt;

&lt;p&gt;单一职责原则 Single Responsibility Principle&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A class or module should have a single responsibility.&lt;/li&gt;
  &lt;li&gt;持续重构：粗粒度的类 &amp;gt; 细粒度的类
    &lt;ul&gt;
      &lt;li&gt;类中的代码行数、函数或属性过多，会影响代码的可读性和可维护性，考虑对类拆分。&lt;/li&gt;
      &lt;li&gt;类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想，考虑拆分。&lt;/li&gt;
      &lt;li&gt;私有方法过多，能否将私有方法独立到新的类中，设置为 public 方法，供更多的类使用。&lt;/li&gt;
      &lt;li&gt;比较难给类起一个合适名字或用业务名词概括，说明类的职责定义不够清晰。&lt;/li&gt;
      &lt;li&gt;类中大量的方法都是集中操作类中的某几个属性，将这几个属性和对应的方法拆分出来。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;solid-原则--ocp&quot;&gt;SOLID 原则 -OCP&lt;/h2&gt;

&lt;p&gt;开闭原则 Open Closed Principle&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;software entities (modules, classes, functions, etc.) should be open for extension ,but closed for modification.&lt;/li&gt;
  &lt;li&gt;在写代码的时候后，思考一下这段代码未来可能有哪些需求变更、如何设计代码结构，预留扩展点。在识别出代码可变部分和不可变部分之后，我们要将可变部分封装起来，隔离变化，提供抽象化的不可变接口，给上层系统使用。&lt;/li&gt;
  &lt;li&gt;利用多态、依赖注入、抽象意识、基于接口而非实现编程，来实现“对扩展开放、对修改关闭”。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;solid-原则--lsp&quot;&gt;SOLID 原则 -LSP&lt;/h2&gt;

&lt;p&gt;里式替换原则 Liskov Substitution Principle&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;If S is a subtype of T, then objects of type T may be replaced with objects of type S, without breaking the program.&lt;/li&gt;
  &lt;li&gt;子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏原有程序的正确性。&lt;/li&gt;
  &lt;li&gt;Design By Contract 子类在设计的时候，要遵守父类的行为约定/协议，在保证兼容的前提条件下做扩展和调整，相当于细粒度的开闭原则。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;solid-原则--isp&quot;&gt;SOLID 原则 -ISP&lt;/h2&gt;

&lt;p&gt;接口隔离原则 Interface Segregation Principle&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Clients should not be forced to depend upon interfaces that they do not use.&lt;/li&gt;
  &lt;li&gt;接口调用者不应该强迫依赖它不需要的接口。&lt;/li&gt;
  &lt;li&gt;接口调用者只使用部分接口或者接口部分功能，则接口设计NO SRP&lt;/li&gt;
  &lt;li&gt;多个特定客户端接口要好于一个宽泛用途的接口.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;solid-原则--dip&quot;&gt;SOLID 原则 -DIP&lt;/h2&gt;

&lt;p&gt;依赖反转原则 Dependency Inversion Principle&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;High-level modules shouldn’t depend on low-level modules. Both modules should depend on abstractions. In addition, abstractions shouldn’t depend on details. Details depend on abstractions.
用来指导框架层面的设计：高层模块不依赖低层模块，它们共同依赖同一个抽象。抽象不要依赖具体实现细
节，具体实现细节依赖抽象。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;控制反转 IOC Inversion Of Control&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程可以通过框架来控制。流程的控制权从程序员“反转”到了框架。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;依赖注入 DI Dependency Injection&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;不通过 new() 的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;more&quot;&gt;More&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;KISS 原则 Keep It Simple and Stupid.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;不要使用同事可能不懂的技术来实现代码&lt;/li&gt;
      &lt;li&gt;不要重复造轮子，要善于使用已经有的工具类库&lt;/li&gt;
      &lt;li&gt;不要过度优化&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;YAGNI 原则 You Ain’t Gonna Need It&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DRY 原则 Don’t Repeat Yourself&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;实现逻辑重复、功能语义重复、代码执行重复&lt;/li&gt;
      &lt;li&gt;代码复用意识：。在设计每个模块、类、函数的时候，要像设计一个外部 API 一样去思考它的复用性。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;LOD 原则 Law of Demeter&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;高内聚、松耦合 ： 对于类，“高内聚”用来指导类本身的设计，相近的功能往往会被同时修改，放到同一个类中，修改会比较集中，代码容易维护。“松耦合”用来指导类与类之间依赖关系的设计。&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;又称：最小知识原则 The Least Knowledge Principle&lt;/li&gt;
    &lt;/ul&gt;

    &lt;blockquote&gt;
      &lt;p&gt;Each unit should have only limited knowledge about other units: only units “closely” related to the current unit. Or: Each unit should only talk to its friends; Don’t talk to strangers.&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;不该有直接依赖关系的类之间，不要有依赖&lt;/li&gt;
      &lt;li&gt;有依赖关系的类之间，尽量只依赖必要的接口&lt;/li&gt;
      &lt;li&gt;迪米特法则是希望减少类之间的耦合，让类越独立越好。每个类都应该少了解系统的其他部分。一旦发生变化，需要了解这一变化的类就会比较少。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;业务系统开发&quot;&gt;业务系统开发&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;端到端（end to end）开发一个完整的系统，工作包括：前期的需求沟通分析、中期的代码设计实现、后期的系统上线维护等。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;需求分析&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;爱因斯坦说过，“创造的一大秘诀是要懂得如何隐藏你的来源”&lt;/p&gt;

  &lt;p&gt;产品设计文档（PRD）、线框图、、用户用例（user case）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;系统设计&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;聚焦架构层面，针对模块。&lt;/p&gt;

  &lt;ol&gt;
    &lt;li&gt;合理地将功能划分到不同模块。为了避免业务知识的耦合，让下层系统更加通用，下层系统（也就是被调用的系统）不应该包含太多上层系统（也就是调用系统）的业务信息。&lt;/li&gt;
    &lt;li&gt;设计模块与模块之间的交互关系。常见交互方式一种是同步接口调用，另一种是利用消息中间件异步调用。&lt;/li&gt;
    &lt;li&gt;设计模块的接口、数据库、业务模型&lt;/li&gt;
    &lt;li&gt;业务模型/业务逻辑：Controller 层负责接口暴露，Repository 层负责数据读写，Service 层负责核心业务逻辑。
      &lt;ol&gt;
        &lt;li&gt;分层的作用：代码复用、隔离变化、提高代码可测试性。&lt;/li&gt;
        &lt;li&gt;应对复杂系统：水平方向基于业务拆分-模块化；垂直方向基于流程拆分-分层。&lt;/li&gt;
      &lt;/ol&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;设计模式&quot;&gt;设计模式&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;设计模式可以让我们写出易扩展的代码&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;创建型
    &lt;ul&gt;
      &lt;li&gt;常用：单例模式、工厂模式、建造者模式&lt;/li&gt;
      &lt;li&gt;不常用：原型模式&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;结构型
    &lt;ul&gt;
      &lt;li&gt;常用：代理模式、桥接模式、装饰者模式、适配器模式&lt;/li&gt;
      &lt;li&gt;不常用：门面模式、组合模式、享元模式&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;行为型
    &lt;ul&gt;
      &lt;li&gt;常用：观察者模式、模板模式、策略模式、职责链模式、迭代器模式、状态模式&lt;/li&gt;
      &lt;li&gt;不常用：访问者模式、备忘录模式、命令模式、解释器模式、中介模式&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;创建型模式&quot;&gt;创建型模式&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;创建型模式主要解决对象的创建问题，封装复杂的创建过程，解耦对象的创建代码和使用代码。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;单例模式用来创建全局唯一的对象。&lt;/li&gt;
  &lt;li&gt;工厂模式用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。&lt;/li&gt;
  &lt;li&gt;建造者模式是用来创建复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象。&lt;/li&gt;
  &lt;li&gt;原型模式针对创建成本比较大的对象，利用对已有对象进行复制的方式进行创建，以达到节省创建时间的目的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;单例模式&quot;&gt;单例模式&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Singleton Design Pattern 一个类只允许创建一个对象（或者实例）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;实例：处理资源访问冲突、表示全局唯一类&lt;/p&gt;

  &lt;p&gt;实现方式：饿汉式、懒汉式、双重检测、静态内部类、枚举。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;工厂模式&quot;&gt;工厂模式&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Factory Design Pattern&lt;/p&gt;

  &lt;p&gt;当创建逻辑比较复杂时考虑使用工厂模式，封装对象的创建过程，将对象的创建和使用相分离。&lt;/p&gt;

  &lt;p&gt;实例：规则配置解析，代码中存在 if-else 分支判断，动态地根据不同的类型创建不同的对象&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;简单工厂/静态工厂方法&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;一个类只负责对象的创建，类一般以“Factory”结尾，创建对象的方法一般以create 开头&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;工厂方法&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;将复杂的创建逻辑拆分到多个工厂类&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;抽象工厂&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;建造者模式&quot;&gt;建造者模式&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;builder模式/生成器模式&lt;/p&gt;

  &lt;p&gt;让建造者类来负责对象的创建工作，用来创建一种类型的复杂对象，通过设置不同的可选参数，“定制化”地创建不同的对象。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;顾客走进一家餐馆点餐，我们利用工厂模式，根据用户不同的选择，来制作不同的食物，比如披萨、汉堡、沙拉。对于披萨来说，用户又有各种配料可以定制，比如奶酪、西红柿、起司，我们通过建造者模式根据用户选择的不同配料来制作披萨。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;原型模式&quot;&gt;原型模式&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;对象的创建成本比较大时，利用对已有对象（原型）进行复制（或者叫拷贝）的方式来创建新对象。&lt;/p&gt;

  &lt;p&gt;对象的创建成本比较大：对象中的数据需要经过复杂的计算才能得到（比如排序、计算哈希值），或者需要从 RPC、网络、数据库、文件系统等非常慢速的 IO 中读取。&lt;/p&gt;

  &lt;p&gt;实现方式：深拷贝、浅拷贝&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;结构型模式&quot;&gt;结构型模式&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;结构型设计模式主要解决“类或对象的组合或组装”问题，即将不同功能代码解耦。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;代理模式：代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同。&lt;/li&gt;
  &lt;li&gt;桥接模式：桥接模式的目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变。&lt;/li&gt;
  &lt;li&gt;装饰器模式：装饰者模式在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用。&lt;/li&gt;
  &lt;li&gt;适配器模式：适配器模式是一种事后的补救策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;代理模式&quot;&gt;代理模式&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Proxy Design Pattern ：在不改变原始类（或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能。一般情况下，我们让代理类和原始类实现同样的接口，或者让代理类继承原始类的方法。&lt;/p&gt;

  &lt;p&gt;动态代理（Dynamic Proxy），就是不事先为每个原始类编写代理类，而是在运行的时候，动态地创建原始类对应的代理类。&lt;/p&gt;

  &lt;p&gt;应用场景：业务系统的非功能性需求开发比如：监控、统计、鉴权、限流、事务、幂等、日志。&lt;/p&gt;

  &lt;p&gt;​					在 RPC(远程代理)、缓存中的应用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;桥接模式&quot;&gt;桥接模式&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Bridge Design Pattern ：Decouple an abstraction from its implementation so that the two can vary independently.  将抽象和实现解耦，让它们可以独立变化。&lt;/p&gt;

  &lt;p&gt;组合优于继承。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;装饰器模式&quot;&gt;装饰器模式&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;解决继承关系过于复杂的问题，通过组合来替代继承。主要作用是给原始类添加增强功能。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;适配器模式&quot;&gt;适配器模式&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Adapter Design Pattern 让原本由于接口不兼容而不能一起工作的类可以一起工作&lt;/p&gt;

  &lt;p&gt;两种实现方式：类适配器 (使用继承实现) 和对象适配器 (使用组合实现)&lt;/p&gt;

  &lt;p&gt;使用场景(事后补救)：封装有缺陷的接口设计、统一多个类的接口设计、替换依赖的外部系统、兼容老版本接口、适配不同格式的数据&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;行为型模式&quot;&gt;行为型模式&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;行为型设计模式主要解决的就是“类或对象之间的交互”问题，即将不同的行为代码解耦。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;观察者模式&quot;&gt;观察者模式&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Observer Design Pattern 或称发布订阅模式（Publish-Subscribe Design Pattern）。&lt;/p&gt;

  &lt;p&gt;Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically. 在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。&lt;/p&gt;

  &lt;p&gt;Subject-Observer、Publisher-Subscriber、Producer-Consumer、Event Emitter-Event Listener、Dispatcher-Listener。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;模板模式&quot;&gt;模板模式&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Template Method Design Pattern&lt;/p&gt;

  &lt;p&gt;Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure. 模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。&lt;/p&gt;

  &lt;p&gt;模板模式的两大作用：复用和扩展。复用指所有的子类可以复用父类中提供的模板方法的代码。扩展指框架通过模板模式提供功能扩展点，让框架用户可以在不修改框架源码的情况下，基于扩展点定制化框架的功能。回调具有同样功能。&lt;/p&gt;

  &lt;p&gt;应用场景上看，同步回调看起来更像模板模式，异步回调看起来更像观察者模式。&lt;/p&gt;

  &lt;p&gt;代码实现上看，回调基于组合，把一个对象传递给另一个对象。模板模式基于继承，子类重写父类的抽
象方法。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;策略模式&quot;&gt;策略模式&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Strategy Design Pattern&lt;/p&gt;

  &lt;p&gt;Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it. 定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。策略模式可以使算法的变化独立于使用它们的客户端（这里的客户端代指使用算法的代码）。&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;策略类的定义，包含一个策略接口和一组实现这个接口的策略类&lt;/li&gt;
    &lt;li&gt;策略的创建，一般会通过类型（type）来判断创建哪个策略来使用&lt;/li&gt;
    &lt;li&gt;策略的使用，运行时动态确定使用哪种策略&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;应用场景：利用它来避免冗长的 if-else 或 switch 分支判断。&lt;/p&gt;

  &lt;p&gt;​					本质上点讲，是借助“查表法”，根据 type 查表替代根据 type 分支判断。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;职责链模式&quot;&gt;职责链模式&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Chain Of Responsibility Design Pattern&lt;/p&gt;

  &lt;p&gt;Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it. 将请求的发送和接收解耦，让多个接收对象都有机会处理这个请求。将这些接收对象串成一条链，并沿着这条链传递这个请求，直到链上的某个接收对象能够处理它为止。&lt;/p&gt;

  &lt;p&gt;应用场景：常用来开发框架的过滤器和拦截器，让框架的使用者在不需要修改框架源码的情况下，添加新的过滤拦截功能。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;状态模式&quot;&gt;状态模式&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;状态机/有限状态机 FSM ，Finite State Machine&lt;/p&gt;

  &lt;p&gt;状态机有3 个组成部分：状态（State）、事件（Event）、动作（Action）&lt;/p&gt;

  &lt;p&gt;实现方式：分支逻辑法、查表法、状态模式&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;迭代器模式&quot;&gt;迭代器模式&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Iterator Design Pattern&lt;/p&gt;

  &lt;p&gt;用来遍历集合对象/容器，如数组、链表、树、图。&lt;/p&gt;

  &lt;p&gt;一个完整的迭代器模式，一般会涉及容器和容器迭代器两部分内容。&lt;/p&gt;

  &lt;p&gt;为了达到基于接口而非实现编程的目的，容器又包含容器接口、容器实现类，迭代器又包含迭代器接口、迭代器实现类。&lt;/p&gt;

  &lt;p&gt;容器中需要定义 iterator() 方法，用来创建迭代器。迭代器接口中需要定义hasNext()、currentItem()、next() 三个最基本的方法。容器对象通过依赖注入传递到迭代器类中。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;编程规范&quot;&gt;编程规范&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;编码规范能让我们写出可读性好的代码&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;代码重构&quot;&gt;代码重构&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;持续重构可以时刻保持代码的可维护性&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;重构的目的（why）、对象（what）、时机（when）、方法（how）&lt;/li&gt;
  &lt;li&gt;保证重构不出错的技术手段：单元测试 (代码的可测试性)
    &lt;ul&gt;
      &lt;li&gt;单元测试的测试对象是类或者函数，用来测试一个类和函数是否都按照预期的逻辑执行。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;两种不同规模的重构：大重构（大规模高层次）和小重构（小规模低层次、编程规范）。
    &lt;ul&gt;
      &lt;li&gt;大型重构：系统、模块、代码结构、类与类之间的关系等的重构
        &lt;ul&gt;
          &lt;li&gt;重构的手段有：分层、模块化、解耦、抽象可复用组件&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;小型重构：对类、函数、变量等代码级别的重构
        &lt;ul&gt;
          &lt;li&gt;编码规范：规范命名、规范注释、消除超大类或函数、提取重复代码&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="Software" /><summary type="html">奥卡姆剃刀 ： 如无必要，勿增实体</summary></entry><entry><title type="html">软件开发流程</title><link href="https://acemyzoe.github.io/_posts/2020-07-30-%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/" rel="alternate" type="text/html" title="软件开发流程" /><published>2020-07-30T00:00:00+08:00</published><updated>2020-07-30T00:00:00+08:00</updated><id>https://acemyzoe.github.io/_posts/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B</id><content type="html" xml:base="https://acemyzoe.github.io/_posts/2020-07-30-%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/">&lt;h1 id=&quot;software-development-process&quot;&gt;Software development &lt;a href=&quot;https://en.wikipedia.org/wiki/Software_development_process&quot;&gt;process&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;软件开发生命周期&lt;/strong&gt; software development life cycle（SDLC）&lt;/p&gt;

&lt;h2 id=&quot;方法&quot;&gt;方法&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Agile_software_development&quot;&gt;敏捷开发&lt;/a&gt;：迭代开发+增量开发
    &lt;ul&gt;
      &lt;li&gt;开发原则：
        &lt;ol&gt;
          &lt;li&gt;通过尽早并持续交付有价值的软件来使客户满意。&lt;/li&gt;
          &lt;li&gt;即使在后期开发中，也欢迎不断变化的需求。&lt;/li&gt;
          &lt;li&gt;频繁交付工作软件（数周而不是数月）&lt;/li&gt;
          &lt;li&gt;商界人士与开发人员之间的紧密日常合作&lt;/li&gt;
          &lt;li&gt;项目是围绕积极进取的个人建立的，应该值得信任&lt;/li&gt;
          &lt;li&gt;面对面的对话是最好的交流方式（同一地点）&lt;/li&gt;
          &lt;li&gt;工作软件是进度的主要衡量标准&lt;/li&gt;
          &lt;li&gt;可持续发展，能够保持稳定的步伐&lt;/li&gt;
          &lt;li&gt;持续关注技术卓越和良好的设计&lt;/li&gt;
          &lt;li&gt;简洁性（最大化未完成工作量的艺术）至关重要&lt;/li&gt;
          &lt;li&gt;自组织团队会提供最佳的架构，需求和设计&lt;/li&gt;
          &lt;li&gt;团队定期思考如何提高效率，并做出相应调整&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;敏捷软件开发框架
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Rapid_application_development&quot;&gt;快速应用程序开发&lt;/a&gt;（RAD）
            &lt;ul&gt;
              &lt;li&gt;主要通过迭代原型设计（在开发的任何阶段），积极的用户参与以及计算机化的开发工具来快速生产高质量的系统。这些工具可能包括&lt;a href=&quot;https://en.wikipedia.org/wiki/Graphical_User_Interface&quot;&gt;图形用户界面&lt;/a&gt;（GUI）生成器，&lt;a href=&quot;https://en.wikipedia.org/wiki/Computer_Aided_Software_Engineering&quot;&gt;计算机辅助软件工程&lt;/a&gt;（CASE）工具，&lt;a href=&quot;https://en.wikipedia.org/wiki/Database_Management_System&quot;&gt;数据库管理系统&lt;/a&gt;（DBMS），&lt;a href=&quot;https://en.wikipedia.org/wiki/Fourth-generation_programming_language&quot;&gt;第四代编程语言&lt;/a&gt;，代码生成器和面向对象的技术。&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;敏捷软件开发实践
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Test-driven_development&quot;&gt;测试驱动开发&lt;/a&gt;（TDD）：开发人员&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Acceptance_test-driven_development&quot;&gt;验收测试驱动开发&lt;/a&gt;（ATDD）：客户&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Behavior-driven_development&quot;&gt;行为驱动开发&lt;/a&gt;（BDD）：结合TDD&amp;amp;ATDD&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_integration&quot;&gt;持续集成&lt;/a&gt;（CI）&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;迭代开发
    &lt;ol&gt;
      &lt;li&gt;需求分析（requirements analysis）&lt;/li&gt;
      &lt;li&gt;设计（design）&lt;/li&gt;
      &lt;li&gt;编码（coding）&lt;/li&gt;
      &lt;li&gt;测试（testing）&lt;/li&gt;
      &lt;li&gt;部署和评估（deployment / evaluation）&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;实践&quot;&gt;实践&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;测试驱动开发  &lt;strong&gt;Test-driven development&lt;/strong&gt; (&lt;strong&gt;TDD&lt;/strong&gt;)
    &lt;ul&gt;
      &lt;li&gt;将需求转换为非常具体的测试用例，然后对代码进行改进以使测试通过&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;CI/CD&lt;/strong&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_integration&quot;&gt;持续集成&lt;/a&gt;以及&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_delivery&quot;&gt;持续交付&lt;/a&gt;或&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_deployment&quot;&gt;持续部署&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;持续集成CI是每天将所有开发人员的工作副本合并到共享主线中的一种做法。&lt;/li&gt;
      &lt;li&gt;工作流程
        &lt;ol&gt;
          &lt;li&gt;在本地进行测试&lt;/li&gt;
          &lt;li&gt;用CI编译代码&lt;/li&gt;
          &lt;li&gt;在CI中运行测试&lt;/li&gt;
          &lt;li&gt;从CI部署工件&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;CI / CD生态系统的关键组件是测试环境，它通过在软件交付的早期阶段自动发现最严重的错误来减少测试时间。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;saas&quot;&gt;SaaS&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;软件即服务&lt;/strong&gt; Software as a Service&lt;/p&gt;

&lt;p&gt;在这种交付模式中，软件仅需通过网络，不须经过传统的安装步骤即可使用，软件及其相关的数据集中托管于云端服务。&lt;/p&gt;

&lt;h1 id=&quot;rest&quot;&gt;Rest&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Representational State Transfer&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;web服务实现方案：Rest、&lt;a href=&quot;https://zh.wikipedia.org/wiki/SOAP&quot;&gt;SOAP&lt;/a&gt;和&lt;a href=&quot;https://zh.wikipedia.org/wiki/XML-RPC&quot;&gt;XML-RPC&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;基于&lt;a href=&quot;https://zh.wikipedia.org/wiki/HTTP&quot;&gt;HTTP&lt;/a&gt;、&lt;a href=&quot;https://zh.wikipedia.org/wiki/URI&quot;&gt;URI&lt;/a&gt;、&lt;a href=&quot;https://zh.wikipedia.org/wiki/XML&quot;&gt;XML&lt;/a&gt;以及&lt;a href=&quot;https://zh.wikipedia.org/wiki/HTML&quot;&gt;HTML&lt;/a&gt;现有的广泛流行的协议和标准。&lt;/li&gt;
  &lt;li&gt;资源是由URI来指定。&lt;/li&gt;
  &lt;li&gt;对资源的操作包括获取、创建、修改和删除，这些操作正好对应HTTP协议提供的GET、POST、PUT和DELETE方法。&lt;/li&gt;
  &lt;li&gt;通过操作资源的表现形式来操作资源。&lt;/li&gt;
  &lt;li&gt;资源的表现形式则是XML或者HTML，取决于读者是机器还是人、是消费Web服务的客户软件还是Web浏览器。当然也可以是任何其他的格式，例如JSON。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;restful-api&quot;&gt;&lt;strong&gt;RESTful API&lt;/strong&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;直观简短的资源地址：URI，比如：&lt;code&gt;http://example.com/resources&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;传输的资源：Web服务接受与返回的互联网媒体类型，比如：&lt;a href=&quot;https://zh.wikipedia.org/wiki/JSON&quot;&gt;JSON&lt;/a&gt;，&lt;a href=&quot;https://zh.wikipedia.org/wiki/XML&quot;&gt;XML&lt;/a&gt;，&lt;a href=&quot;https://zh.wikipedia.org/wiki/YAML&quot;&gt;YAML&lt;/a&gt;等。&lt;/li&gt;
  &lt;li&gt;对资源的操作：Web服务在该资源上所支持的一系列&lt;a href=&quot;https://zh.wikipedia.org/wiki/超文本传输协议#请求方法&quot;&gt;请求方法&lt;/a&gt;（比如：POST，GET，PUT或DELETE）。&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;资源&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;GET&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;PUT&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;POST&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;DELETE&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;一组资源的URI，比如&lt;code&gt;https://example.com/resources&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;列出&lt;/strong&gt;URI，以及该资源组中每个资源的详细信息（后者可选）。&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;使用给定的一组资源&lt;strong&gt;替换&lt;/strong&gt;当前整组资源。&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;在本组资源中&lt;strong&gt;创建/追加&lt;/strong&gt;一个新的资源。该操作往往返回新资源的URL。&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;删除&lt;/strong&gt;整组资源。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;单个资源的URI，比如&lt;code&gt;https://example.com/resources/142&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;获取&lt;/strong&gt;指定的资源的详细信息，格式可以自选一个合适的网络媒体类型（比如：XML、JSON等）&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;替换/创建&lt;/strong&gt;指定的资源。并将其追加到相应的资源组中。&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;把指定的资源当做一个资源组，并在其下&lt;strong&gt;创建/追加&lt;/strong&gt;一个新的元素，使其隶属于当前资源。&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;删除&lt;/strong&gt;指定的元素。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name></name></author><category term="Software" /><summary type="html">Software development process</summary></entry><entry><title type="html">ROSPY</title><link href="https://acemyzoe.github.io/_posts/2020-07-25-ROS%E5%8A%9F%E8%83%BD%E5%8C%85/" rel="alternate" type="text/html" title="ROSPY" /><published>2020-07-25T00:00:00+08:00</published><updated>2020-07-25T00:00:00+08:00</updated><id>https://acemyzoe.github.io/_posts/ROS%E5%8A%9F%E8%83%BD%E5%8C%85</id><content type="html" xml:base="https://acemyzoe.github.io/_posts/2020-07-25-ROS%E5%8A%9F%E8%83%BD%E5%8C%85/">&lt;h1 id=&quot;launch&quot;&gt;Launch&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;http://wiki.ros.org/roslaunch&quot;&gt;roslaunch&lt;/a&gt;可通过SSH 轻松地在本地和远程启动多个ROS &lt;a href=&quot;http://ros.org/wiki/Nodes&quot;&gt;节点&lt;/a&gt;，以及在&lt;a href=&quot;http://ros.org/wiki/Parameter Server&quot;&gt;Parameter Server&lt;/a&gt;上设置参数。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;​	&lt;a href=&quot;http://wiki.ros.org/roslaunch/CommandlineTools&quot;&gt;roslaunch命令行用法&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;roslaunch package_name file.launch
roslaunch -p 1234 package filename.launch # 远程端口
roslaunch my_file.launch arg:=value # 参数传递
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;​	&lt;a href=&quot;http://wiki.ros.org/roslaunch/XML&quot;&gt;roslaunch .launch / XML格式&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;launch&amp;gt;
  &amp;lt;!-- local machine already has a definition by default.
       This tag overrides the default definition with
       specific ROS_ROOT and ROS_PACKAGE_PATH values --&amp;gt;
  &amp;lt;machine name=&quot;local_alt&quot; address=&quot;localhost&quot; default=&quot;true&quot; ros-root=&quot;/u/user/ros/ros/&quot; ros-package-path=&quot;/u/user/ros/ros-pkg&quot; /&amp;gt;
  &amp;lt;!-- a basic listener node --&amp;gt;
  &amp;lt;node name=&quot;listener-1&quot; pkg=&quot;rospy_tutorials&quot; type=&quot;listener&quot; /&amp;gt;
  &amp;lt;!-- pass args to the listener node --&amp;gt;
  &amp;lt;node name=&quot;listener-2&quot; pkg=&quot;rospy_tutorials&quot; type=&quot;listener&quot; args=&quot;-foo arg2&quot; /&amp;gt;
  &amp;lt;!-- a respawn-able listener node --&amp;gt;
  &amp;lt;node name=&quot;listener-3&quot; pkg=&quot;rospy_tutorials&quot; type=&quot;listener&quot; respawn=&quot;true&quot; /&amp;gt;
  &amp;lt;!-- start listener node in the 'wg1' namespace --&amp;gt;
  &amp;lt;node ns=&quot;wg1&quot; name=&quot;listener-wg1&quot; pkg=&quot;rospy_tutorials&quot; type=&quot;listener&quot; respawn=&quot;true&quot; /&amp;gt;
  &amp;lt;!-- start a group of nodes in the 'wg2' namespace --&amp;gt;
  &amp;lt;group ns=&quot;wg2&quot;&amp;gt;
    &amp;lt;!-- remap applies to all future statements in this scope. --&amp;gt;
    &amp;lt;remap from=&quot;chatter&quot; to=&quot;hello&quot;/&amp;gt;
    &amp;lt;node pkg=&quot;rospy_tutorials&quot; type=&quot;listener&quot; name=&quot;listener&quot; args=&quot;--test&quot; respawn=&quot;true&quot; /&amp;gt;
    &amp;lt;node pkg=&quot;rospy_tutorials&quot; type=&quot;talker&quot; name=&quot;talker&quot;&amp;gt;
      &amp;lt;!-- set a private parameter for the node --&amp;gt;
      &amp;lt;param name=&quot;talker_1_param&quot; value=&quot;a value&quot; /&amp;gt;
      &amp;lt;!-- nodes can have their own remap args --&amp;gt;
      &amp;lt;remap from=&quot;chatter&quot; to=&quot;hello-1&quot;/&amp;gt;
      &amp;lt;!-- you can set environment variables for a node --&amp;gt;
      &amp;lt;env name=&quot;ENV_EXAMPLE&quot; value=&quot;some value&quot; /&amp;gt;
    &amp;lt;/node&amp;gt;
  &amp;lt;/group&amp;gt;
&amp;lt;/launch&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;http://wiki.ros.org/roslaunch/APIUsage&quot;&gt;roslaunch / PYTHON API&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 从软件包rqt_gui启动和停止rqt_gui的实例
import roslaunch
package = 'rqt_gui'
executable = 'rqt_gui'
node = roslaunch.core.Node(package, executable)

launch = roslaunch.scriptapi.ROSLaunch()
launch.start()

process = launch.launch(node)
print process.is_alive()
process.stop()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 具有参数列表的多个启动文件
import roslaunch
uuid = roslaunch.rlutil.get_or_generate_uuid(None, False)
roslaunch.configure_logging(uuid)

cli_args1 = ['pkg1', 'file1.launch', 'arg1:=arg1', 'arg2:=arg2']
cli_args2 = ['pkg2', 'file2.launch', 'arg1:=arg1', 'arg2:=arg2']
cli_args3 = ['pkg3', 'file3.launch']
roslaunch_file1 = roslaunch.rlutil.resolve_launch_arguments(cli_args1)
roslaunch_args1 = cli_args1[2:]

roslaunch_file2 = roslaunch.rlutil.resolve_launch_arguments(cli_args2)
roslaunch_args2 = cli_args2[2:]

roslaunch_file3 = roslaunch.rlutil.resolve_launch_arguments(cli_args3)

launch_files = [(roslaunch_file1, roslaunch_args1), (roslaunch_file2, roslaunch_args2), roslaunch_file3]
parent = roslaunch.parent.ROSLaunchParent(uuid, launch_files)
parent.start()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 从base启动文件“继承”
import roslaunch
roslaunch.configure_logging(uuid)
launch = roslaunch.scriptapi.ROSLaunch()
launch.parent = roslaunch.parent.ROSLaunchParent(uuid, &quot;path/to/base.launch&quot;)
launch.start()
# Start another node
node = roslaunch.core.Node(package, executable)
launch.launch(node)
try:
  launch.spin()
finally:
  # After Ctrl+C, stop all nodes from running
  launch.shutdown()
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;tf2&quot;&gt;&lt;a href=&quot;http://wiki.ros.org/tf2&quot;&gt;TF2&lt;/a&gt;&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;TF是一个让用户随时间跟踪多个坐标系的功能包，它使用树型数据结构，根据时间缓冲并维护多个坐标系之间的坐标变换关系，可以帮助开发者在任意时间，在坐标系间完成点、向量等坐标的变换。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;# 工作区
source /opt/ros/noetic/setup.bash
mkdir -p ~/tutorial_ws/src
cd ~/tutorial_ws
catkin_init_workspace src
catkin_make
source devel/setup.bash
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# run demo
# 该demo使用tf2库创建三个坐标系：世界框架，turtle1框架和turtle2框架。
# 使用tf2广播器(broadcaster)发布乌龟坐标帧，并使用tf2侦听器(listener)计算乌龟帧中的差异并移动一只乌龟跟随另一只乌龟。
sudo apt-get install ros-noetic-turtle-tf2 ros-noetic-tf2-tools ros-noetic-tf
roslaunch turtle_tf2 turtle_tf2_demo.launch
rosrun tf2_tools view_frames.py # 通过ROS广播的帧
evince frames.pdf # 绘制帧连接方式的树
rosrun tf tf_echo turtle1 turtle2 # 通过ROS广播的任何两个帧之间的转换
rosrun rviz rviz -d `rospack find turtle_tf2`/rviz/turtle_rviz.rviz # 可视化tf2帧
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;tf2-broadcaster-python&quot;&gt;tf2 broadcaster (Python)&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;如何将坐标系广播到tf2 : 广播海龟移动时不断变化的坐标系。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;# 名为learning_tf2的catkin包将继承tf2，tf2_ros,roscpp,rospy和turtlesim.
catkin_create_pkg learning_tf2 tf2 tf2_ros roscpp rospy turtlesim
roscd learning_tf2
mkdirs nodes
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# nodes / turtle_tf2_broadcaster.py
#!/usr/bin/env python  
import rospy
import tf_conversions # Because of transformations
import tf2_ros
import geometry_msgs.msg
import turtlesim.msg
def handle_turtle_pose(msg, turtlename):
    br = tf2_ros.TransformBroadcaster()
    t = geometry_msgs.msg.TransformStamped()

    t.header.stamp = rospy.Time.now() # 时间戳
    t.header.frame_id = &quot;world&quot; # 设置要创建的链接的父框架的名称
    t.child_frame_id = turtlename # 设置要创建的链接的子节点的名称
    # 从框架“world”到框架“turtle”的转换
    t.transform.translation.x = msg.x
    t.transform.translation.y = msg.y
    t.transform.translation.z = 0.0
    q = tf_conversions.transformations.quaternion_from_euler(0, 0, msg.theta)
    t.transform.rotation.x = q[0]
    t.transform.rotation.y = q[1]
    t.transform.rotation.z = q[2]
    t.transform.rotation.w = q[3]

    br.sendTransform(t)

if __name__ == '__main__':
    rospy.init_node('tf2_turtle_broadcaster')
    turtlename = rospy.get_param('turtle1') # 该节点采用一个参数
    rospy.Subscriber('/%s/pose' % turtlename, # 订阅turtle/pose主题
                     turtlesim.msg.Pose,
                     handle_turtle_pose,
                     turtlename)
    rospy.spin()
# chmod +x nodes/turtle_tf2_broadcaster.py
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!--start_demo.launch--&amp;gt;
&amp;lt;launch&amp;gt;
    &amp;lt;node pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node&quot; name=&quot;sim&quot;/&amp;gt;
    &amp;lt;node pkg=&quot;turtlesim&quot; type=&quot;turtle_teleop_key&quot; name=&quot;teleop&quot; output=&quot;screen&quot;/&amp;gt;

    &amp;lt;node name=&quot;turtle1_tf2_broadcaster&quot; pkg=&quot;learning_tf2&quot; type=&quot;turtle_tf2_broadcaster.py&quot; respawn=&quot;false&quot; output=&quot;screen&quot; &amp;gt;
    &amp;lt;param name=&quot;turtle&quot; type=&quot;string&quot; value=&quot;turtle1&quot; /&amp;gt;
    &amp;lt;/node&amp;gt;
    
    &amp;lt;node name=&quot;turtle2_tf2_broadcaster&quot; pkg=&quot;learning_tf2&quot; type=&quot;turtle_tf2_broadcaster.py&quot; respawn=&quot;false&quot; output=&quot;screen&quot; &amp;gt;
    &amp;lt;param name=&quot;turtle&quot; type=&quot;string&quot; value=&quot;turtle2&quot; /&amp;gt; 
    &amp;lt;/node&amp;gt;
    
    &amp;lt;!--tf2 listener--&amp;gt;
	&amp;lt;node pkg=&quot;learning_tf2&quot; type=&quot;turtle_tf2_listener.py&quot; name=&quot;listener&quot; output=&quot;screen&quot;/&amp;gt;
&amp;lt;/launch&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;roslaunch learning_tf2 start_demo.launch
rosrun tf tf_echo /world/turtle1
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;tf2-listener-python&quot;&gt;tf2 listener (Python)&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# nodes/turtle_tf2_listener.py
#!/usr/bin/env python  
import rospy

import math
import tf2_ros # tf2_ros包提供了tf2_ros.TransformListener的实现
import geometry_msgs.msg
import turtlesim.srv

if __name__ == '__main__':
    rospy.init_node('tf2_turtle_listener')

    tfBuffer = tf2_ros.Buffer()
    listener = tf2_ros.TransformListener(tfBuffer) # 创建侦听器

    rospy.wait_for_service('spawn')
    spawner = rospy.ServiceProxy('spawn', turtlesim.srv.Spawn)
    turtle_name = rospy.get_param('turtle', 'turtle2')
    spawner(4, 2, 0, turtle_name)

    turtle_vel = rospy.Publisher('%s/cmd_vel' % turtle_name, geometry_msgs.msg.Twist, queue_size=1)

    rate = rospy.Rate(10.0)
    while not rospy.is_shutdown():
        try:
            trans = tfBuffer.lookup_transform(turtle_name, 'turtle1', rospy.Time())
        except (tf2_ros.LookupException, tf2_ros.ConnectivityException, tf2_ros.ExtrapolationException):
            rate.sleep()
            continue

        msg = geometry_msgs.msg.Twist()

        msg.angular.z = 4 * math.atan2(trans.transform.translation.y, trans.transform.translation.x)
        msg.linear.x = 0.5 * math.sqrt(trans.transform.translation.x ** 2 + trans.transform.translation.y ** 2)

        turtle_vel.publish(msg)

        rate.sleep()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;四元数&quot;&gt;四元数&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;四元数具有4个分量（&lt;code&gt;x&lt;/code&gt;，&lt;code&gt;y&lt;/code&gt;，&lt;code&gt;z&lt;/code&gt;，&lt;code&gt;w&lt;/code&gt;），不绕x / y / z轴旋转的常用单位四元数为（0,0,0,1）。&lt;/p&gt;

  &lt;p&gt;ROS使用两种四元数数据类型：msg和’tf’&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;from geometry_msgs.msg import Quaternion
# Create a list of floats, which is compatible with tf
# quaternion methods
quat_tf = [0, 1, 0, 0]
quat_msg = Quaternion(quat_tf[0], quat_tf[1], quat_tf[2], quat_tf[3])

#（绕X轴滚动）/（绕Y轴俯仰）/（绕Z轴偏航），然后转换为四元数
# tf.transformations alternative is not yet available in tf2
from tf.transformations import quaternion_from_euler  
# RPY to convert: 90deg, 0, -90deg
q = quaternion_from_euler(1.5707, 0, -1.5707)
print(&quot;The quaternion representation is %s %s %s %s.&quot; % (q[0], q[1], q[2], q[3]))
print(q[0], q[1], q[2], -q[3]) # 反转四元数的一种简单方法是对w分量求反
# 在同一帧中从q1到q2的相对旋转qr
# q2=qr*q1,故相对旋转qr=q2*q1_inverse

# 将一个四元数的旋转应用于姿势，只需将姿势的前一个四元数乘以表示所需旋转的四元数即可
q_orig = quaternion_from_euler(0, 0, 0)
q_rot = quaternion_from_euler(pi, 0, 0)
q_new = quaternion_multiply(q_rot, q_orig)
print(q_new)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 四元数&amp;amp;欧拉角
import sys
import math

def quart2rpy(w,x,y,z):
    angles = {'roll': 0.0, 'pitch': 0.0, 'yaw': 0.0}
    r = math.atan2(2*(w*x+y*z),1-2*(x*x+y*y))
    p = math.asin(2*(w*y-z*x))
    y = math.atan2(2*(w*z+x*y),1-2*(z*z+y*y))
    angles['roll'] = r*180/math.pi
    angles['pitch'] = p*180/math.pi
    angles['yaw'] = y*180/math.pi
    print(angles)
    return [r,p,y]

def rpy2quart(roll,pitch,yaw):
    qx = math.sin(roll/2) * math.cos(pitch/2) * math.cos(yaw/2) - math.cos(roll/2) * math.sin(pitch/2) * math.sin(yaw/2)
    qy = math.cos(roll/2) * math.sin(pitch/2) * math.cos(yaw/2) + math.sin(roll/2) * math.cos(pitch/2) * math.sin(yaw/2)
    qz = math.cos(roll/2) * math.cos(pitch/2) * math.sin(yaw/2) - math.sin(roll/2) * math.sin(pitch/2) * math.cos(yaw/2)
    qw = math.cos(roll/2) * math.cos(pitch/2) * math.cos(yaw/2) + math.sin(roll/2) * math.sin(pitch/2) * math.sin(yaw/2)
    print([qw,qx,qy,qz])
    return [qw,qx,qy,qz]

if __name__ == &quot;__main__&quot;:
    rpy2quart(1,0,0)
    q=quart2rpy(0.8775825618903728, 0.479425538604203, 0.0, 0.0)
    rpy2quart(q[0],q[1],q[2])
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;rviz&quot;&gt;&lt;a href=&quot;https://wiki.ros.org/rviz&quot;&gt;Rviz&lt;/a&gt;&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;机器人通过ROS发布数据，rviz订阅消息接收数据，然后3D可视化。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;markers&quot;&gt;&lt;a href=&quot;https://wiki.ros.org/rviz/Tutorials/Markers%3A Basic Shapes&quot;&gt;Markers&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;rosrun rviz rviz --help
# 发送四个基本形状（框，球体，圆柱体和箭头）
catkin_create_pkg using_markers roscpp visualization_msgs
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt;//// src/basic_shapes.cpp
#include &amp;lt;ros/ros.h&amp;gt;
#include &amp;lt;visualization_msgs/Marker.h&amp;gt;
//原始对象是通过visualization_msgs/Marker消息发送到显示器的。

int main( int argc, char** argv )
{
  ros::init(argc, argv, &quot;basic_shapes&quot;);
  ros::NodeHandle n;
  ros::Rate r(1);
  ros::Publisher marker_pub = n.advertise&amp;lt;visualization_msgs::Marker&amp;gt;(&quot;visualization_marker&quot;, 1);

  // Set our initial shape type to be a cube,创建一个整数来跟踪要发布的形状
  uint32_t shape = visualization_msgs::Marker::CUBE;

  while (ros::ok())
  {
    visualization_msgs::Marker marker;
    // Set the frame ID and timestamp.  See the TF tutorials for information on these.
    marker.header.frame_id = &quot;/my_frame&quot;;
    marker.header.stamp = ros::Time::now();

    // Set the namespace and id for this marker.  This serves to create a unique ID
    // Any marker sent with the same namespace and id will overwrite the old one
    // 名称空间（ns）和id用于为此标记创建唯一的名称
    marker.ns = &quot;basic_shapes&quot;;
    marker.id = 0;

    // Set the marker type.  Initially this is CUBE, and cycles between that and SPHERE, ARROW, and CYLINDER
    marker.type = shape;

    // Set the marker action.  Options are ADD, DELETE, and new in ROS Indigo: 3 (DELETEALL)
    marker.action = visualization_msgs::Marker::ADD;

    // Set the pose of the marker.  This is a full 6DOF pose relative to the frame/time specified in the header
    // xyz位置 &amp;amp; xyzw方向
    marker.pose.position.x = 0;
    marker.pose.position.y = 0;
    marker.pose.position.z = 0;
    marker.pose.orientation.x = 0.0;
    marker.pose.orientation.y = 0.0;
    marker.pose.orientation.z = 0.0;
    marker.pose.orientation.w = 1.0;

    // Set the scale of the marker -- 1x1x1 here means 1m on a side
    // 比例 1：1m
    marker.scale.x = 1.0;
    marker.scale.y = 1.0;
    marker.scale.z = 1.0;

    // Set the color -- be sure to set alpha to something non-zero!
    marker.color.r = 0.0f;
    marker.color.g = 1.0f;
    marker.color.b = 0.0f;
    marker.color.a = 1.0; //alpha（a）值0表示完全透明（不可见），而1则完全不透明。

    marker.lifetime = ros::Duration(); //标记的持续时间/生命周期

    // Publish the marker
    while (marker_pub.getNumSubscribers() &amp;lt; 1)
    {
      if (!ros::ok())
      {
        return 0;
      }
      ROS_WARN_ONCE(&quot;Please create a subscriber to the marker&quot;);
      sleep(1);
    }
    marker_pub.publish(marker);

    // Cycle between different shapes
    // CUBE立方体 SPHERE球 ARROW箭头 CYLINDER圆柱
    switch (shape)
    {
    case visualization_msgs::Marker::CUBE:
      shape = visualization_msgs::Marker::SPHERE;
      break;
    case visualization_msgs::Marker::SPHERE:
      shape = visualization_msgs::Marker::ARROW;
      break;
    case visualization_msgs::Marker::ARROW:
      shape = visualization_msgs::Marker::CYLINDER;
      break;
    case visualization_msgs::Marker::CYLINDER:
      shape = visualization_msgs::Marker::CUBE;
      break;
    }

    r.sleep();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-cmake&quot;&gt;add_executable(basic_shapes src/basic_shapes.cpp)
target_link_libraries(basic_shapes ${catkin_LIBRARIES})
# catkin_make
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;rosmake rviz
rosrun using_markers basic_shapes
rosrun rviz rviz
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt;//产生一个旋转的螺旋线
#include &amp;lt;ros/ros.h&amp;gt;
#include &amp;lt;visualization_msgs/Marker.h&amp;gt;

#include &amp;lt;cmath&amp;gt;

int main( int argc, char** argv )
{
  ros::init(argc, argv, &quot;points_and_lines&quot;);
  ros::NodeHandle n;
  ros::Publisher marker_pub = n.advertise&amp;lt;visualization_msgs::Marker&amp;gt;(&quot;visualization_marker&quot;, 10);
  ros::Rate r(30);

  float f = 0.0;
  while (ros::ok())
  {

    visualization_msgs::Marker points, line_strip, line_list;
    points.header.frame_id = line_strip.header.frame_id = line_list.header.frame_id = &quot;/my_frame&quot;;
    points.header.stamp = line_strip.header.stamp = line_list.header.stamp = ros::Time::now();
    points.ns = line_strip.ns = line_list.ns = &quot;points_and_lines&quot;;
    points.action = line_strip.action = line_list.action = visualization_msgs::Marker::ADD;
    points.pose.orientation.w = line_strip.pose.orientation.w = line_list.pose.orientation.w = 1.0;

    points.id = 0;
    line_strip.id = 1;
    line_list.id = 2;

    points.type = visualization_msgs::Marker::POINTS;
    line_strip.type = visualization_msgs::Marker::LINE_STRIP;
    line_list.type = visualization_msgs::Marker::LINE_LIST;

    // POINTS markers use x and y scale for width/height respectively
    points.scale.x = 0.2;
    points.scale.y = 0.2;

    // LINE_STRIP/LINE_LIST markers use only the x component of scale, for the line width
    line_strip.scale.x = 0.1;
    line_list.scale.x = 0.1;

    // Points are green
    points.color.g = 1.0f;
    points.color.a = 1.0;

    // Line strip is blue
    line_strip.color.b = 1.0;
    line_strip.color.a = 1.0;

    // Line list is red
    line_list.color.r = 1.0;
    line_list.color.a = 1.0

    // Create the vertices for the points and lines
    for (uint32_t i = 0; i &amp;lt; 100; ++i)
    {
      float y = 5 * sin(f + i / 100.0f * 2 * M_PI);
      float z = 5 * cos(f + i / 100.0f * 2 * M_PI);

      geometry_msgs::Point p;
      p.x = (int32_t)i - 50;
      p.y = y;
      p.z = z;

      points.points.push_back(p);
      line_strip.points.push_back(p);

      // The line list needs two points for each line
      line_list.points.push_back(p);
      p.z += 1.0;
      line_list.points.push_back(p);
    }

    marker_pub.publish(points);
    marker_pub.publish(line_strip);
    marker_pub.publish(line_list);

    r.sleep();
    f += 0.04;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;interactive-markers&quot;&gt;&lt;a href=&quot;https://wiki.ros.org/rviz/Tutorials/InteractiveMarkers%3AGettingStarted&quot;&gt;Interactive Markers&lt;/a&gt;&lt;/h3&gt;

&lt;h1 id=&quot;urdf&quot;&gt;&lt;a href=&quot;https://wiki.ros.org/urdf&quot;&gt;urdf&lt;/a&gt;&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;URDF（Unified Robot Description Format，统一机器人描述格式）是ROS中一个非常重要的机器人模型描述格式。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;apt-get install urdf_tutorial
roslaunch urdf_tutorial display.launch model:=urdf/01-myfirst.urdf
roslaunch urdf_tutorial display.launch model:='$(find urdf_tutorial)/urdf/01-myfirst.urdf'
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;gazebo&quot;&gt;&lt;a href=&quot;http://gazebosim.org/tutorials&quot;&gt;gazebo&lt;/a&gt;&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;gazebo是一款功能强大的三维物理仿真平台，其中的机器人模型与rviz使用的模型相同，但是需要在模型中加入机器人和周围环境的物理属性，例如质量、摩擦系数、弹性系数等。机器人的传感器信息也可以通过插件的形式加入仿真环境，以可视化的方式进行显示。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;gazebo
gazebo worlds/pioneer2dx.world
# gzserver可执行文件运行物理更新循环和传感器数据生成。这是gazebo的核心，可以独立于图形界面使用。
gzserver
# gzclient可执行文件运行QT基于用户界面。
gzclient
&lt;/code&gt;&lt;/pre&gt;</content><author><name></name></author><category term="ros" /><summary type="html">Launch</summary></entry><entry><title type="html">ROSPY</title><link href="https://acemyzoe.github.io/_posts/2020-07-25-rospy/" rel="alternate" type="text/html" title="ROSPY" /><published>2020-07-25T00:00:00+08:00</published><updated>2020-07-25T00:00:00+08:00</updated><id>https://acemyzoe.github.io/_posts/rospy</id><content type="html" xml:base="https://acemyzoe.github.io/_posts/2020-07-25-rospy/">&lt;h2 id=&quot;rospy参数--log&quot;&gt;Rospy参数 &amp;amp; log&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;# 从rospy设置参数
roscd rospy_tutorials/006_parameters
# 获取一个全局参数
rospy.get_param('/global_param_name')
# 从我们的父命名空间获取一个参数
rospy.get_param('param_name')
# 从我们的私有名称空间获取参数
rospy.get_param('~private_param_name')
# 参数不存在，指定默认值：
rospy.get_param('foo', 'default_value')
# 设置参数
rospy.set_param(param_name, param_value)
rospy.set_param('some_numbers', [1., 2., 3., 4.])
rospy.set_param('truth', True)
rospy.set_param('~private_bar', 1+2)
# 判断删除
if rospy.has_param('to_delete'):
    rospy.delete_param('to_delete')
# 重映射来打印参数的值 
value = rospy.get_param('~foo')
rospy.loginfo('Parameter %s has value %s', rospy.resolve_name('~foo'), value)
# 搜索参数
full_param_name = rospy.search_param（'foo'）
param_value = rospy.get_param（full_param_name）
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;# 当您运行多个节点时，很难看到节点的命令行输出。相反，将调试消息发布到rosout然后使用rqt_console/rxconsole查看它要容易得多
rospy.logdebug(msg, *args)
rospy.logwarn(msg, *args)
rospy.loginfo(msg, *args)
rospy.logerr(msg, *args)
rospy.logfatal(msg, *args)
rospy.init_node('my_node', log_level=rospy.DEBUG)
rospy.logerr(&quot;%s returned the invalid value %s&quot;, other_name, other_value)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# example
def talker():
    topic = 'floats'
    pub = rospy.Publisher(topic, numpy_msg(Floats))
    rospy.init_node(topic, anonymous=True)
    rospy.loginfo(&quot;I will publish to the topic %s&quot;, topic)
    while not rospy.is_shutdown():
        a = numpy.array([1.0, 2.1, 3.2, 4.3, 5.4, 6.5], dtype=numpy.float32)
        rospy.loginfo(a)
        pub.publish(a)
        rospy.sleep(0.1)

if __name__ == '__main__':
    talker()
    
# rostopic echo rosout
# rqt_console
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;makefile&quot;&gt;Makefile&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;# 编写ROS Python Makefile
# 这些构建文件CMakeLists.txt，Makefile提供的功能：自动生成消息和服务代码，运行测试
cd ~/catkin_ws/src
catkin_create_pkg my_pkg message_generation rospy
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-cmake&quot;&gt;cmake_minimum_required(VERSION 2.8.3)
project(my_pkg)
find_package(catkin REQUIRED COMPONENTS message_generation rospy)
add_message_files(
  FILES  # e.g. Floats.msg HeaderString.msg
)
add_service_files(
  DIRECTORY srv 
  FILES AddTwoInts.srv BadTwoInts.srv
)
## Generate services in the 'srv' folder
# add_service_files(
#  FILES  # e.g. Floats.srv HeaderString.srv
#)
## Generate added messages and services with any dependencies
generate_messages()
catkin_package(
  CATKIN_DEPENDS message_runtime
)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;安装脚本和导出模块&quot;&gt;安装脚本和导出模块&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;cd ~/catkin_ws/src/my_pkg    # new catkin package, in the workspace
mkdir bin
mkdir src
mkdir src/tutorial_package
touch src/tutorial_package/__init__.py
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# Within my_pkg, create file src/tutorial_package/hello.py
def say(name):
    print('Hello ' + name)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# create file bin/hello
#! /usr/bin/env python
import tutorial_package.hello
if __name__ == '__main__':
    tutorial_package.hello.say('my friend!')
# chmod u+x bin/hello
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# create setup.py 定义一个安装过程，将文件移至PYTHONPATH中。
## ! DO NOT MANUALLY INVOKE THIS setup.py, USE CATKIN INSTEAD
from distutils.core import setup
from catkin_pkg.python_setup import generate_distutils_setup
# fetch values from package.xml
# 仅需提供的信息就是package.xml中没有的信息，要安装的脚本的名称，python软件包的名称，在何处可以找到这些软件包以及python软件包的依赖关系
setup_args = generate_distutils_setup(
    packages=['tutorial_package'],
    package_dir={'': 'src'},
)
setup(**setup_args)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-cmake&quot;&gt;## Uncomment if the package has a setup.py
catkin_python_setup()
catkin_install_python(PROGRAMS bin/hello
  DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION})
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;cd ~/catkin_ws
catkin_make
. devel/setup.bash
rosrun my_pkg hello 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;设置pythonpath&quot;&gt;设置pythonpath&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;cd catkin_ws/src
catkin_create_pkg listener_extend rospy beginner_tutorials
cd listener_extend
mkdir nodes
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# create a file listener_extend.py
#!/usr/bin/env python
import beginner_tutorials.msg
num = beginner_tutorials.msg.Num()
print(num)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;source ~/catkin_ws/devel/setup.bash
chmod u+x nodes/listener_extend.py
python nodes/listener_extend.py
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;numpy&quot;&gt;Numpy&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;catkin_create_pkg numpy_tutorial rospy rospy_tutorials
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;build_depend&amp;gt;python-numpy&amp;lt;/build_depend&amp;gt;
&amp;lt;run_depend&amp;gt;python-numpy&amp;lt;/run_depend&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# numpy_listener.py
#!/usr/bin/env python
PKG = 'numpy_tutorial'
import roslib; roslib.load_manifest(PKG)
import rospy
from rospy_tutorials.msg import Floats
from rospy.numpy_msg import numpy_msg
def callback(data):
    print rospy.get_name(), &quot;I heard %s&quot;%str(data.data)
def listener():
    rospy.init_node('listener')
    # rospy.Subscriber(&quot;floats&quot;, Floats, callback)
    rospy.Subscriber(&quot;floats&quot;, numpy_msg(Floats), callback) # Numpy-ize the Listener
    rospy.spin()
if __name__ == '__main__':
    listener()   
 # chmod +x numpy_listener.py
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;# terminal 1
roscore
# termianl 2
rosrun numpy_tutorial numpy_listener.py
# termianl 3
rostopic pub -r 1 floats rospy_tutorials/Floats &quot;[1.1, 2.2, 3.3, 4.4, 5.5]&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# numpy_talker.py
#!/usr/bin/env python
PKG = 'numpy_tutorial'
import roslib; roslib.load_manifest(PKG)
import rospy
from rospy.numpy_msg import numpy_msg
from rospy_tutorials.msg import Floats
import numpy
def talker():
    pub = rospy.Publisher('floats', numpy_msg(Floats),queue_size=10)
    rospy.init_node('talker', anonymous=True)
    r = rospy.Rate(10) # 10hz
    while not rospy.is_shutdown():
        a = numpy.array([1.0, 2.1, 3.2, 4.3, 5.4, 6.5], dtype=numpy.float32)
        pub.publish(a)
        r.sleep()
if __name__ == '__main__':
    talker()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;more-eg&quot;&gt;more eg&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# talker_color.py
#!/usr/bin/env python
import roslib; roslib.load_manifest('beginner_tutorials')
import rospy
from std_msgs.msg import ColorRGBA
def talker():
    #pub = rospy.Publisher('chatter', String)
    pub = rospy.Publisher('chatter_color', ColorRGBA)
    rospy.init_node('talker_color')
    while not rospy.is_shutdown():
        pub.publish(a=1.0)
        rospy.sleep(1.0)
if __name__ == '__main__':
    try:
        talker()
    except rospy.ROSInterruptException: pass
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# listener_color.py
#!/usr/bin/env python
import roslib; roslib.load_manifest('beginner_tutorials')
import rospy
from std_msgs.msg import ColorRGBA
def callback(data):
    rospy.loginfo(rospy.get_name()+ &quot;I heard r=%s g=%s b=%s a=%s&quot;, data.r, data.g, data.b, data.a)

def listener():
    rospy.init_node('listener_color', anonymous=True)
    rospy.Subscriber(&quot;chatter_color&quot;, ColorRGBA, callback)
    rospy.spin()

if __name__ == '__main__':
    listener()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# Python CompressedImage订阅服务器发布者
# 本示例订阅了一个包含sensor_msgs::CompressedImage的ros主题,
# 将CompressedImage转换为numpy.ndarray,
# 然后opencv检测并标记该图像中的特征,
# 最后，它显示并发布新图像-再次作为CompressedImage主题。

#!/usr/bin/env python
&quot;&quot;&quot;OpenCV feature detectors with ros CompressedImage Topics in python.

This example subscribes to a ros topic containing sensor_msgs 
CompressedImage. It converts the CompressedImage into a numpy.ndarray, 
then detects and marks features in that image. It finally displays 
and publishes the new image - again as CompressedImage topic.
&quot;&quot;&quot;
__author__ =  'Simon Haller &amp;lt;simon.haller at uibk.ac.at&amp;gt;'
__version__=  '0.1'
__license__ = 'BSD'
# Python libs
import sys, time

# numpy and scipy
import numpy as np
from scipy.ndimage import filters

# OpenCV
import cv2

# Ros libraries
import roslib
import rospy

# Ros Messages
from sensor_msgs.msg import CompressedImage
# We do not use cv_bridge it does not support CompressedImage in python
# from cv_bridge import CvBridge, CvBridgeError

VERBOSE=False # True将在命令行上打印一些其他信息(特征检测方法，点数，检测时间)

class image_feature:
    def __init__(self):
        '''Initialize ros publisher, ros subscriber'''
        # topic where we publish
        self.image_pub = rospy.Publisher(&quot;/output/image_raw/compressed&quot;,
            CompressedImage)
        # self.bridge = CvBridge()
        # subscribed Topic
        self.subscriber = rospy.Subscriber(&quot;/camera/image/compressed&quot;,
            CompressedImage, self.callback,  queue_size = 1)
        if VERBOSE :
            print &quot;subscribed to /camera/image/compressed&quot;
            
    def callback(self, ros_data):
        '''Callback function of subscribed topic. 
        Here images get converted and features detected'''
        if VERBOSE :
            print 'received image of type: &quot;%s&quot;' % ros_data.format
            
        #### direct conversion to CV2 #### 将压缩的图像直接转换为cv2
        np_arr = np.fromstring(ros_data.data, np.uint8)
        image_np = cv2.imdecode(np_arr, cv2.CV_LOAD_IMAGE_COLOR)
        #image_np = cv2.imdecode(np_arr, cv2.IMREAD_COLOR) # OpenCV &amp;gt;= 3.0:
        
        #### Feature detectors using CV2 #### 选择并创建特征检测器
        # &quot;&quot;,&quot;Grid&quot;,&quot;Pyramid&quot; + 
        # &quot;FAST&quot;,&quot;GFTT&quot;,&quot;HARRIS&quot;,&quot;MSER&quot;,&quot;ORB&quot;,&quot;SIFT&quot;,&quot;STAR&quot;,&quot;SURF&quot;
        method = &quot;GridFAST&quot;
        feat_det = cv2.FeatureDetector_create(method)
        time1 = time.time()

        # convert np image to grayscale 
        featPoints = feat_det.detect(
            cv2.cvtColor(image_np, cv2.COLOR_BGR2GRAY))
        time2 = time.time()
        if VERBOSE :
            print '%s detector found: %s points in: %s sec.'%(method,
                len(featPoints),time2-time1)

        for featpoint in featPoints:
            x,y = featpoint.pt
            cv2.circle(image_np,(int(x),int(y)), 3, (0,0,255), -1)
        
        cv2.imshow('cv_img', image_np)
        cv2.waitKey(2)

        #### Create CompressedIamge #### 创建要发布的压缩图像
        msg = CompressedImage()
        msg.header.stamp = rospy.Time.now()
        msg.format = &quot;jpeg&quot;
        msg.data = np.array(cv2.imencode('.jpg', image_np)[1]).tostring()
        # Publish new image
        self.image_pub.publish(msg)
        
        #self.subscriber.unregister()

def main(args):
    '''Initializes and cleanup ros node'''
    ic = image_feature()
    rospy.init_node('image_feature', anonymous=True)
    try:
        rospy.spin()
    except KeyboardInterrupt:
        print &quot;Shutting down ROS Image feature detector module&quot;
    cv2.destroyAllWindows()

if __name__ == '__main__':
    main(sys.argv)
&lt;/code&gt;&lt;/pre&gt;</content><author><name></name></author><category term="ros" /><summary type="html">Rospy参数 &amp;amp; log</summary></entry><entry><title type="html">初识SQL</title><link href="https://acemyzoe.github.io/_posts/2020-07-16-SQL/" rel="alternate" type="text/html" title="初识SQL" /><published>2020-07-16T00:00:00+08:00</published><updated>2020-07-16T00:00:00+08:00</updated><id>https://acemyzoe.github.io/_posts/SQL</id><content type="html" xml:base="https://acemyzoe.github.io/_posts/2020-07-16-SQL/">&lt;h1 id=&quot;数据库&quot;&gt;数据库&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;数据库按照数据结构来组织、存储和管理数据：层次模型HDB、网状模型、关系模型RDB。&lt;/li&gt;
  &lt;li&gt;主流的关系数据库：
    &lt;ol&gt;
      &lt;li&gt;商用数据库，例如：&lt;a href=&quot;https://www.oracle.com/&quot;&gt;Oracle&lt;/a&gt;，&lt;a href=&quot;https://www.microsoft.com/sql-server/&quot;&gt;SQL Server&lt;/a&gt;，&lt;a href=&quot;https://www.ibm.com/db2/&quot;&gt;DB2&lt;/a&gt;等；&lt;/li&gt;
      &lt;li&gt;开源数据库，例如：&lt;a href=&quot;https://www.mysql.com/&quot;&gt;MySQL&lt;/a&gt;，&lt;a href=&quot;https://www.postgresql.org/&quot;&gt;PostgreSQL&lt;/a&gt;等；&lt;/li&gt;
      &lt;li&gt;桌面数据库，以微软&lt;a href=&quot;https://products.office.com/access&quot;&gt;Access&lt;/a&gt;为代表，适合桌面应用程序使用；&lt;/li&gt;
      &lt;li&gt;嵌入式数据库，以&lt;a href=&quot;https://sqlite.org/&quot;&gt;Sqlite&lt;/a&gt;为代表，适合手机应用和桌面程序。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;NoSQL
    &lt;ul&gt;
      &lt;li&gt;非关系型数据库又被称为 &lt;a href=&quot;http://c.biancheng.net/nosql/&quot;&gt;NoSQL&lt;/a&gt;（Not Only SQL )，意为不仅仅是 SQL。通常指数据以对象的形式存储在数据库中，而对象之间的关系通过每个对象自身的属性来决定。&lt;/li&gt;
      &lt;li&gt;面向文档数据库有 MongDB 和 CouchDB。&lt;/li&gt;
      &lt;li&gt;列存储数据库有 Cassandra 和 &lt;a href=&quot;http://c.biancheng.net/hbase/&quot;&gt;HBase&lt;/a&gt;。&lt;/li&gt;
      &lt;li&gt;键值存储数据库有 &lt;a href=&quot;http://c.biancheng.net/redis/&quot;&gt;Redis&lt;/a&gt;、Memcached 和 MemcachedDB。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;sql&quot;&gt;SQL&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;Structured Query Language (结构化查询语言)，用来访问和操作数据库系统。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;BIGINT&lt;/code&gt; &lt;em&gt;长整型&lt;/em&gt;  \  &lt;code&gt;VARCHAR(N)&lt;/code&gt;  &lt;em&gt;变长字符串&lt;/em&gt; 是日常用于最广泛的数据类型。&lt;/li&gt;
  &lt;li&gt;DDL-定义数据（增删表，修改表结构）、DML-管理数据（增删改数据）、DQL-查询数据。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;关系模型&quot;&gt;关系模型&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;表的每一&lt;strong&gt;行&lt;/strong&gt;称为&lt;strong&gt;记录（Record）&lt;/strong&gt;，记录是一个逻辑意义上的数据。&lt;/p&gt;

  &lt;p&gt;表的每一&lt;strong&gt;列&lt;/strong&gt;称为&lt;strong&gt;字段（Column）&lt;/strong&gt;，同一个表的每一行记录都拥有相同的若干字段。&lt;/p&gt;

  &lt;p&gt;字段定义了数据类型（整型、浮点型、字符串、日期等）。NULL是空的，不是0也不是空字符串。&lt;/p&gt;

  &lt;p&gt;通常情况下，字段应该避免允许为NULL。不允许为NULL可以简化查询条件，加快查询速度，也利于应用程序读取数据后无需判断是否为NULL。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;主键&lt;/strong&gt;&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;主键是关系表中记录的唯一标识，即&lt;code&gt;id&lt;/code&gt;，如身份证号。&lt;/p&gt;

      &lt;p&gt;主键的选取非常重要：&lt;strong&gt;不使用任何业务相关的字段作为主键。&lt;/strong&gt;，而应该使用BIGINT自增或者GUID类型。主键也不应该允许&lt;code&gt;NULL&lt;/code&gt;。可以使用多个列作为联合主键，但联合主键并不常用。&lt;/p&gt;

      &lt;p&gt;GUID算法通过网卡MAC地址、时间戳和随机数保证任意计算机在任意时间生成的字符串都是不同的，大部分编程语言都内置了GUID算法，可以自己预算出主键。类似&lt;code&gt;8f55d96b-8acc-4636-8cb8-76bf8abc2f57&lt;/code&gt;。&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;python &lt;a href=&quot;https://docs.python.org/3/library/uuid.html&quot;&gt;uuid&lt;/a&gt;&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# UUID是128位的通用唯一识别码（universally unique identifier）。
import uuid 
# 基于MAC地址，时间戳，随机数来生成唯一的uuid，可以保证全球范围内的唯一性。
guid1 = uuid.uuid1() # &amp;gt; 2879f1ea-c703-11ea-88ab-2cf05d0031b3
guid4 = uuid.uuid4()
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;外键&lt;/strong&gt;&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;关系数据库通过外键可以实现一对多、多对多和一对一的关系。&lt;/p&gt;

      &lt;p&gt;外键既可以通过数据库来约束（即在中间表的字段上设置外键），也可以不设置约束，仅依靠应用程序的逻辑来保证。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;索引&lt;/strong&gt;&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;索引是关系数据库中对某一列或多个列的值进行预排序的数据结构。&lt;/p&gt;

      &lt;p&gt;对于主键，关系数据库会自动对其创建主键索引。&lt;/p&gt;

      &lt;p&gt;在设计关系数据表的时候，看上去唯一的列，例如身份证号、邮箱地址等，因为他们具有业务含义，因此不宜作为主键。&lt;/p&gt;

      &lt;p&gt;但是，这些列根据业务要求，又具有唯一性约束：即不能出现两条记录存储了同一个身份证号。这个时候，就可以给该列添加一个&lt;strong&gt;唯一索引&lt;/strong&gt;。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;sql语法&quot;&gt;SQL语法&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/1177760294764384/1179611432985088&quot;&gt;在线sql&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://c.biancheng.net/mysql/function/&quot;&gt;MySQL 常用函数汇总&lt;/a&gt;：数值型函数、字符串型函数、日期时间函数、聚合函数。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/functions.html&quot;&gt;Mysql官方8.0参考手册&lt;/a&gt; ：强制转换函数、加密压缩、JSON函数等。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;MYSQL数据库名表名列名在Linux区分大小写，建议以小写字母方式来存储；关键字不区分，建议大写。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;中文&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;英文&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;意思&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/SQL&quot;&gt;SQL&lt;/a&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;HTTP&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/表现层状态转换&quot;&gt;REST表现层状态转换&lt;/a&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;数据分散服务&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/MongoDB&quot;&gt;MongoDB&lt;/a&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;增加&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Create&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;创建&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/插入_(SQL)&quot;&gt;INSERT&lt;/a&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;PUT / POST&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;POST&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;WRITE&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Insert&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;删除&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Delete&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;删除&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/删除_(SQL)&quot;&gt;DELETE&lt;/a&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;DELETE&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;DELETE&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;DISPOSE&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Remove&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;查询&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Read&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;读取&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/查询_(SQL)&quot;&gt;SELECT&lt;/a&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;GET&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;GET&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;READ / TAKE&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Find&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;改正&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Update&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;更新&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/更新_(SQL)&quot;&gt;UPDATE&lt;/a&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;PUT / POST / PATCH&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;PUT&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;WRITE&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Update&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;查询数据&quot;&gt;查询数据&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;-- 语句格式
SELECT
[DISTINCT] -- 去重
{* | &amp;lt;字段列名&amp;gt;}
[
FROM &amp;lt;表 1&amp;gt;, &amp;lt;表 2&amp;gt;…
[WHERE &amp;lt;表达式&amp;gt; -- 条件
[GROUP BY &amp;lt;group by definition&amp;gt; -- 分组
[HAVING &amp;lt;expression&amp;gt; [{&amp;lt;operator&amp;gt; &amp;lt;expression&amp;gt;}…]] --过滤分组后的数据~WHERE
[ORDER BY &amp;lt;order by definition&amp;gt;] -- 排序
[LIMIT[&amp;lt;offset&amp;gt;,] &amp;lt;row count&amp;gt;] -- 分页
]
------
-- 查询students表的所有数据，结果是一个二维表
-- SELECT是关键字，表示将要执行一个查询，*表示“所有列”，FROM表示将要从哪个表查询
SELECT * FROM &amp;lt;表名&amp;gt;;
-- 判断当前到数据库的连接是否有效
SELECT 1;

-- 按条件查询students:
SELECT * FROM &amp;lt;表名&amp;gt; WHERE &amp;lt;条件表达式&amp;gt;
SELECT * FROM students WHERE (score &amp;lt; 80 OR score &amp;gt; 90) AND gender = 'M';
-- 去重
SELECT COUNT(DISTINCT name,age) FROM students;
-- 模糊查询
[NOT] LIKE  '字符串'
SELECT * FROM students WHERE name LIKE [BINARY] 't%' 
-- 通配符%代表任何长度的字符串(含0)，通配符_只能代表单个字符(不含0),BINARY区分大小写
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;​	&lt;strong&gt;算术运算符&lt;/strong&gt;：&lt;strong&gt;+ - * / % mod&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;​	&lt;strong&gt;逻辑运算符&lt;/strong&gt;：**NOT或!  ； AND或&amp;amp;&amp;amp; ； OR或&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;； XOR**&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;​	&lt;strong&gt;比较运算符 :&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;条件&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;表达式举例1&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;表达式举例2&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;使用=判断相等&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;score = 80&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;name = ‘ace’&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;字符串需要用单引号括起来。安全等于&amp;lt;=&amp;gt;,可判断NULL&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;使用&amp;gt;判断大于&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;score &amp;gt; 80&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;name &amp;gt; ‘ace’&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;字符串比较根据ASCII码，中文字符比较根据数据库设置&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;使用&amp;gt;=判断大于或相等&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;score &amp;gt;= 80&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;name &amp;gt;= ‘ace’&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;使用&amp;lt;判断小于&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;score &amp;lt; 80&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;name &amp;lt;= ‘ace’&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;使用&amp;lt;=判断小于或相等&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;score &amp;lt;= 80&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;name &amp;lt;= ‘ace’&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;使用&amp;lt;&amp;gt;判断不相等&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;score &amp;lt;&amp;gt; 80&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;name &amp;lt;&amp;gt; ‘ace’&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;!=&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;使用LIKE判断相似&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;name LIKE ‘ab%’&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;name LIKE ‘%bc%’&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;%表示任意字符，例如’ab%’将匹配’ab’，’abc’，’abcd’&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;IS NULL(ISNULL)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;10 IS NULL&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;ISNULL(10)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;空值查询&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;IS NOT NULL&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;BETWEEN AND 运算符&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;4 BETWEEN 2 AND 5&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;age BETWEEN 20 AND 23&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;范围查询&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;IN&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;集合内查询&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;NOT IN&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;​	&lt;strong&gt;位运算符&lt;/strong&gt;：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;运算符&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
      &lt;th&gt;使用形式&lt;/th&gt;
      &lt;th&gt;举例&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;|&lt;/td&gt;
      &lt;td&gt;位或&lt;/td&gt;
      &lt;td&gt;a | b&lt;/td&gt;
      &lt;td&gt;5 | 8&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&amp;amp;&lt;/td&gt;
      &lt;td&gt;位与&lt;/td&gt;
      &lt;td&gt;a &amp;amp; b&lt;/td&gt;
      &lt;td&gt;5 &amp;amp; 8&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;^&lt;/td&gt;
      &lt;td&gt;位异或&lt;/td&gt;
      &lt;td&gt;a ^ b&lt;/td&gt;
      &lt;td&gt;5 ^ 8&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;~&lt;/td&gt;
      &lt;td&gt;位取反&lt;/td&gt;
      &lt;td&gt;~a&lt;/td&gt;
      &lt;td&gt;~5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;«&lt;/td&gt;
      &lt;td&gt;位左移&lt;/td&gt;
      &lt;td&gt;a « b&lt;/td&gt;
      &lt;td&gt;5 « 2，表示整数 5 按位左移 2 位&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;»&lt;/td&gt;
      &lt;td&gt;位右移&lt;/td&gt;
      &lt;td&gt;a » b&lt;/td&gt;
      &lt;td&gt;5 » 2，表示整数 5 按位右移 2 位&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;-- 投影查询，仅返回指定列并进行重名
SELECT 列1 [AS] 别名1, 列2 别名2, 列3 别名3 FROM &amp;lt;表名&amp;gt; 别名4 WHERE &amp;lt;条件&amp;gt;
SELECT id, score points, name FROM students AS STU;

-- 排序，ASC升序(default)，DESC降序
-- WHERE子句在前，按score(降序), gender排序(前一字段值可排序时才对后面字段排	序)
SELECT id, name, gender, score
FROM students
WHERE class_id = 1
ORDER BY score DESC,gender;

-- 分页查询
LIMIT &amp;lt;M&amp;gt; OFFSET &amp;lt;N&amp;gt; --M记录数，N初始位置
-- LIMIT总是设定为pageSize；OFFSET计算公式为pageSize * (pageIndex - 1)。
LIMIT 3 OFFSET 0;
LIMIT 3 OFFSET 3;
LIMIT 3 OFFSET 6;
LIMIT 6,3;

-- 聚合查询：返回该表的记录总数量，结果仍是一行一列，列名是COUNT(*)的二维表，可设置别名便于处理。
SELECT COUNT(*) num FROM students;
SELECT COUNT(*) boys FROM students WHERE gender = 'M';
-- SUM()数值列的合计值，AVG()数值列的平均值，MAX()列最大值，MIN()列最小值
SELECT AVG(score) average FROM students WHERE gender = 'M';

-- 每页3条记录，如何通过聚合查询获得总页数
-- round() 遵循四舍五入，round(1.45,0) = 1；
-- ceiling()向上舍入为指定小数位数，ceiling(1.45,0) = 2；
-- floor()向下舍入为指定小数位数，floor(1.45,0)= 1;
SELECT CEILING(COUNT(*) / 3) FROM students;

-- 分组聚合，按class_id分组，得出每个class的男女生人数
-- GROUP_CONCAT() 函数：把每个分组的字段值都显示出来
-- WITH ROLLUP关键词：统计记录数量
SELECT class_id , gender, COUNT(*) num FROM students GROUP BY class_id;
SELECT age,sex,GROUP_CONCAT(name) FROM students GROUP BY age,sex;

-- 多表查询，返回多表的乘积(M*N行)，尽量不使用。
-- 要使用‘表名.列名’这样的方式来引用列和设置别名，避免了结果集的列名重复问题。同时表也可以设置别名。
-- set table alias:
SELECT
    s.id sid,
    s.name,
    s.gender,
    s.score,
    c.id cid,
    c.name cname
FROM students s, classes c;
WHERE s.gender = 'M' AND c.id = 1;

-- 连接查询(Join查询)
SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score
FROM students s -- 主表
INNER JOIN classes c -- 内连接，返回同时存在于两张表的行数据
ON s.class_id = c.id; -- 连接条件
-- RIGHT OUTER JOIN返回右表都存在的行；LEFT OUTER JOIN则返回左表都存在的行；FULL OUTER JOIN。

-- 子查询
SELECT name FROM students 
WHERE course_id IN (SELECT id FROM tb_course WHERE course_name = 'Java');

-- 正则表达式
属性名 REGEXP '匹配方式'
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;选项&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
      &lt;th&gt;例子&lt;/th&gt;
      &lt;th&gt;匹配值示例&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;^&lt;/td&gt;
      &lt;td&gt;匹配文本的开始字符&lt;/td&gt;
      &lt;td&gt;‘^b’ 匹配以字母 b 开头的字符串&lt;/td&gt;
      &lt;td&gt;book、big、banana、bike&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;$&lt;/td&gt;
      &lt;td&gt;匹配文本的结束字符&lt;/td&gt;
      &lt;td&gt;‘st$’ 匹配以 st 结尾的字符串&lt;/td&gt;
      &lt;td&gt;test、resist、persist&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;.&lt;/td&gt;
      &lt;td&gt;匹配任何单个字符&lt;/td&gt;
      &lt;td&gt;‘b.t’ 匹配任何 b 和 t 之间有一个字符&lt;/td&gt;
      &lt;td&gt;bit、bat、but、bite&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;*&lt;/td&gt;
      &lt;td&gt;匹配零个或多个在它前面的字符&lt;/td&gt;
      &lt;td&gt;‘f*n’ 匹配字符 n 前面有任意个字符 f&lt;/td&gt;
      &lt;td&gt;fn、fan、faan、abcn&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;+&lt;/td&gt;
      &lt;td&gt;匹配前面的字符 1 次或多次&lt;/td&gt;
      &lt;td&gt;‘ba+’ 匹配以 b 开头，后面至少紧跟一个 a&lt;/td&gt;
      &lt;td&gt;ba、bay、bare、battle&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;字符串&gt;&lt;/字符串&gt;&lt;/td&gt;
      &lt;td&gt;匹配包含指定字符的文本&lt;/td&gt;
      &lt;td&gt;‘fa’ 匹配包含‘fa’的文本&lt;/td&gt;
      &lt;td&gt;fan、afa、faad&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[字符集合]&lt;/td&gt;
      &lt;td&gt;匹配字符集合中的任何一个字符&lt;/td&gt;
      &lt;td&gt;‘[xz]’ 匹配 x 或者 z&lt;/td&gt;
      &lt;td&gt;dizzy、zebra、x-ray、extra&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[^]&lt;/td&gt;
      &lt;td&gt;匹配不在括号中的任何字符&lt;/td&gt;
      &lt;td&gt;’[ ^abc]’ 匹配任何不包含 a、b 或 c 的字符串&lt;/td&gt;
      &lt;td&gt;desk、fox、f8ke&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;字符串{n,}&lt;/td&gt;
      &lt;td&gt;匹配前面的字符串至少 n 次&lt;/td&gt;
      &lt;td&gt;‘b{2}’ 匹配 2 个或更多的 b&lt;/td&gt;
      &lt;td&gt;bbb、bbbb、bbbbbbb&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;字符串 {n,m}&lt;/td&gt;
      &lt;td&gt;匹配前面的字符串至少 n 次， 至多 m 次&lt;/td&gt;
      &lt;td&gt;‘b{2,4}’ 匹配最少 2 个，最多 4 个 b&lt;/td&gt;
      &lt;td&gt;bbb、bbbb&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;修改数据&quot;&gt;修改数据&lt;/h2&gt;

&lt;h3 id=&quot;insert&quot;&gt;INSERT&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;-- 添加多条新记录
INSERT INTO &amp;lt;表名&amp;gt; (字段1, 字段2, ...) VALUES (值1, 值2, ...);
INSERT INTO students (class_id, name, gender, score) VALUES
(1, '大宝', 'M', 87),
(2, '二宝', 'M', 81);
-- 方式二
INSERT INTO &amp;lt;表名&amp;gt;
SET &amp;lt;列名1&amp;gt; = &amp;lt;值1&amp;gt;,
    &amp;lt;列名2&amp;gt; = &amp;lt;值2&amp;gt;;
-- 使用 INSERT INTO…FROM 语句复制表数据
INSERT INTO &amp;lt;表2&amp;gt;
(字段1, 字段2,...)
SELECT 字段1, 字段2,...
FROM &amp;lt;表1&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;update&quot;&gt;UPDATE&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;-- 更新id=1的记录
UPDATE &amp;lt;表名&amp;gt; SET 字段1=值1 [,字段2=值2… ] [WHERE 子句 ] [ORDER BY 子句] [LIMIT 子句];
UPDATE students SET name='大牛', score=66 WHERE id=1;
UPDATE students SET score=score+10 WHERE score&amp;lt;80; -- 更新字段可用表达式
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;delete&quot;&gt;DELETE&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;-- 删除id=1，3，5的记录
DELETE FROM &amp;lt;表名&amp;gt; WHERE ...;
DELETE FROM students WHERE  id IN (1,3,5);
-- 清空表数据,无法回滚
TRUNCATE [TABLE] 表名;
-- 当不需要该表时，用 DROP；当仍要保留该表，但要删除所有记录时，用 TRUNCATE；当要删除部分记录时，用 DELETE。
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;mysql&quot;&gt;MYSQL&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;MySQL适用场景：web网站系统、日志记录系统、数据仓库系统、嵌入式系统。&lt;/p&gt;

  &lt;p&gt;MySQL Client的可执行程序是mysql，MySQL Server的可执行程序是mysqld，在后台运行。&lt;/p&gt;

  &lt;p&gt;可视化图形界面&lt;a href=&quot;https://dev.mysql.com/downloads/workbench/&quot;&gt;MySQL Workbench&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;mysql数据格式&quot;&gt;Mysql数据格式&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;整数类型有 &lt;strong&gt;TINYINT&lt;/strong&gt;、&lt;strong&gt;SMALLINT&lt;/strong&gt;、&lt;strong&gt;MEDIUMINT&lt;/strong&gt;、&lt;strong&gt;INT&lt;/strong&gt;、&lt;strong&gt;BIGINT&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;小数类型有单精度浮点数（&lt;strong&gt;FLOAT&lt;/strong&gt;）和双精度浮点数（&lt;strong&gt;DOUBLE&lt;/strong&gt;），定点类型 &lt;strong&gt;DECIMAL&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;日期的数据类型：&lt;strong&gt;YEAR&lt;/strong&gt;、&lt;strong&gt;TIME&lt;/strong&gt;、&lt;strong&gt;DATE&lt;/strong&gt;、&lt;strong&gt;DTAETIME&lt;/strong&gt;、&lt;strong&gt;TIMESTAMP&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;字符串类型有 &lt;strong&gt;CHAR&lt;/strong&gt;(M)、&lt;strong&gt;VARCHAR&lt;/strong&gt;(M)、&lt;strong&gt;TINYTEXT&lt;/strong&gt;、&lt;strong&gt;TEXT&lt;/strong&gt;、&lt;strong&gt;MEDIUMTEXT&lt;/strong&gt;、&lt;strong&gt;LONGTEXT&lt;/strong&gt;、&lt;strong&gt;ENUM&lt;/strong&gt;、&lt;strong&gt;SET&lt;/strong&gt;。
    &lt;ul&gt;
      &lt;li&gt;CHAR 是固定长度字符，VARCHAR 是可变长度字符。&lt;/li&gt;
      &lt;li&gt;性别字段适合定义，为 ENUM；要存储一个人兴趣爱好，最好使用SET类型。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;二进制字符串有 &lt;strong&gt;BIT&lt;/strong&gt;(M)、&lt;strong&gt;BINARY&lt;/strong&gt;(M)、&lt;strong&gt;VARBINARY&lt;/strong&gt;(M)、&lt;strong&gt;TINYBLOB&lt;/strong&gt;(M)、&lt;strong&gt;BLOB&lt;/strong&gt;(M)、&lt;strong&gt;MEDIUMBLOB&lt;/strong&gt;(M) 和 &lt;strong&gt;LONGBLOB&lt;/strong&gt;(M)。
    &lt;ul&gt;
      &lt;li&gt;BLOB 主要存储图片、音频信息等&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;mysqlcrud&quot;&gt;MYSQL(CRUD)&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;# 连接 MySQL Server
mysql -u root -p
mysql -h 10.0.1.99 -u root -p
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;HELP 查询内容;
/*多行
  注释*/
-- 列出所有数据库
show databases;
SHOW DATABASES [LIKE '数据库名']; --匹配数据库,部分匹配‘%db’、‘%db%’
-- 创建数据库
create database test;
-- 语法格式
CREATE DATABASE [IF NOT EXISTS] &amp;lt;数据库名&amp;gt;
[[DEFAULT] CHARACTER SET &amp;lt;字符集名&amp;gt;] 
[[DEFAULT] COLLATE &amp;lt;校对规则名&amp;gt;];
show create database test;
-- 修改数据库，只能对数据库使用的字符集和校对规则进行修改
ALTER DATABASE [数据库名] { 
[ DEFAULT ] CHARACTER SET &amp;lt;字符集名&amp;gt; |
[ DEFAULT ] COLLATE &amp;lt;校对规则名&amp;gt;}
-- 删除数据库
DROP DATABASE [ IF EXISTS ] &amp;lt;数据库名&amp;gt;
-- 切换数据库
use test;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;information_schema：主要存储了系统中的一些数据库对象信息，比如用户表信息、列信息、权限信息、字符集信息和分区信息等。&lt;/li&gt;
    &lt;li&gt;mysql：MySQL 的核心数据库，类似于 SQL Server 中的 master 表，主要负责存储数据库用户、用户访问权限等 MySQL 自己需要使用的控制和管理信息。常用的比如在 mysql 数据库的 user 表中修改 root 用户密码。&lt;/li&gt;
    &lt;li&gt;performance_schema：主要用于收集数据库服务器性能参数。&lt;/li&gt;
    &lt;li&gt;sakila：MySQL 提供的样例数据库，该数据库共有 16 张表，这些数据表都是比较常见的，在设计数据库时，可以参照这些样例数据表来快速完成所需的数据表。&lt;/li&gt;
    &lt;li&gt;sys：MySQL 5.7 安装完成后会多一个 sys 数据库。sys 数据库主要提供了一些视图，数据都来自于 performation_schema，主要是让开发者和使用者更方便地查看性能问题。&lt;/li&gt;
    &lt;li&gt;world：world 数据库是 MySQL 自动创建的数据库，该数据库中只包括 3 张数据表，分别保存城市，国家和国家使用的语言等内容。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;-- 列出当前数据库所有表
show tables;

-- MYSQL视图
-- 查看表结构 DESCRIBE
desc students;
	-- 字段含义:
    -- Null：表示该列是否可以存储 NULL 值。
    -- Key：表示该列是否已编制索引。PRI 表示该列是表主键的一部分，UNI 表示该列是 UNIQUE 索引的一部分，MUL 表示在列中某个给定值允许出现多次。
    -- Default：表示该列是否有默认值，如果有，值是多少。
    -- Extra：表示可以获取的与给定列有关的附加信息，如 AUTO_INCREMENT 等。
CREATE VIEW &amp;lt;视图名&amp;gt; AS &amp;lt;SELECT语句&amp;gt;
ALTER VIEW &amp;lt;视图名&amp;gt; AS &amp;lt;SELECT语句&amp;gt;

-- 参考创建表的sql语句
show create table students;
+----------+-------------------------------------------------------+
| students | CREATE TABLE `students` (                             |
|          |   `id` bigint(20) NOT NULL AUTO_INCREMENT,            |
|          |   `class_id` bigint(20) NOT NULL,                     |
|          |   `name` varchar(100) NOT NULL,                       |
|          |   `gender` varchar(1) NOT NULL,                       |
|          |   `score` int(11) NOT NULL,                           |
|          |   PRIMARY KEY (`id`)                                  |
|          | ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 |
+----------+-------------------------------------------------------+
-- 删除表
DROP TABLE [IF EXISTS] 表名1 [ ,表名2, 表名3 ...]
drop table students;

-- 修改表
ALTER TABLE &amp;lt;表名&amp;gt; [修改选项]
-- 修改选项
{ ADD COLUMN &amp;lt;列名&amp;gt; &amp;lt;类型&amp;gt;[约束条件]; -- 在末尾添加字段
  ADD COLUMN &amp;lt;列名&amp;gt; &amp;lt;类型&amp;gt;[约束条件]FIRST; -- 在开头添加字段
  ADD COLUMN &amp;lt;列名&amp;gt; &amp;lt;类型&amp;gt;[约束条件]AFTER &amp;lt;已经存在的字段名&amp;gt;; -- 在已有字段后添加
| CHANGE COLUMN &amp;lt;旧列名&amp;gt; &amp;lt;新列名&amp;gt; &amp;lt;新列类型&amp;gt; -- 修改字段名称
| ALTER COLUMN &amp;lt;列名&amp;gt; { SET DEFAULT &amp;lt;默认值&amp;gt; | DROP DEFAULT }
| MODIFY COLUMN &amp;lt;列名&amp;gt; &amp;lt;类型&amp;gt; -- 修改字段数据类型
| DROP COLUMN &amp;lt;列名&amp;gt;
| RENAME [TO] &amp;lt;新表名&amp;gt;
| CHARACTER SET &amp;lt;字符集名&amp;gt;
| COLLATE &amp;lt;校对规则名&amp;gt; }

ALTER TABLE students ADD COLUMN birth VARCHAR(10) NOT NULL; -- 新增一列birth
ALTER TABLE students CHANGE COLUMN birth birthday VARCHAR(20) NOT NULL; -- 把列名改为birthday，类型改为VARCHAR(20)
ALTER TABLE students DROP COLUMN birthday; -- 删除列
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;mysql约束constraint&quot;&gt;MYSQL约束(CONSTRAINT)&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;主键约束(一个表中只有一个)&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;-- 在创建表时设置主键约束
CREATE TABLE &amp;lt;数据表名&amp;gt; 
(
[CONSTRAINT &amp;lt;约束名&amp;gt;] PRIMARY KEY [字段名] -- 单字段主键
PRIMARY KEY [字段1，字段2，…,字段n] -- 设置联合主键
字段名 数据类型 AUTO_INCREMENT -- 给字段(只能是整数类型)添加 AUTO_INCREMENT 属性来实现主键自增长
AUTO_INCREMENT=1 -- 指定自增字段初始值
);
  
-- 在修改表时添加主键约束
ALTER TABLE &amp;lt;数据表名&amp;gt; 
ADD PRIMARY KEY(&amp;lt;字段名&amp;gt;);
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;外键约束&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;-- 在创建表时设置外键约束
CREATE TABLE &amp;lt;数据表名&amp;gt; 
(
[CONSTRAINT &amp;lt;外键名&amp;gt;] FOREIGN KEY 字段名 [，字段名2，…] 
REFERENCES &amp;lt;主表名&amp;gt; 主键列1 [，主键列2，…]
);
  
-- 在修改表时添加外键约束
ALTER TABLE &amp;lt;数据表名&amp;gt; 
ADD CONSTRAINT &amp;lt;外键名&amp;gt;
FOREIGN KEY(&amp;lt;列名&amp;gt;) REFERENCES &amp;lt;主表名&amp;gt; (&amp;lt;列名&amp;gt;);
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;唯一约束(一个表中可有多个)&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;&amp;lt;字段名&amp;gt; &amp;lt;数据类型&amp;gt; UNIQUE
  
ALTER TABLE &amp;lt;数据表名&amp;gt; ADD CONSTRAINT &amp;lt;唯一约束名&amp;gt; UNIQUE(&amp;lt;列名&amp;gt;);
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;检查约束(检查数据表中字段值有效性)&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;-- 创建表时
CHECK(&amp;lt;检查约束&amp;gt;)
CHECK(salary&amp;gt;0 AND salary&amp;lt;100)
-- 修改表
ALTER TABLE &amp;lt;数据表名&amp;gt;
ADD CONSTRAINT &amp;lt;检查约束名&amp;gt; 
CHECK(&amp;lt;检查约束&amp;gt;);
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;默认值约束&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;-- 创建表时
&amp;lt;字段名&amp;gt; &amp;lt;数据类型&amp;gt; DEFAULT &amp;lt;默认值&amp;gt;;
-- 修改表
ALTER TABLE &amp;lt;数据表名&amp;gt;
CHANGE COLUMN &amp;lt;字段名&amp;gt;	
&amp;lt;字段名&amp;gt; &amp;lt;数据类型&amp;gt; DEFAULT &amp;lt;默认值&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;非空约束&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;-- 创建表时
&amp;lt;字段名&amp;gt; &amp;lt;数据类型&amp;gt; NOT NULL;
-- 修改表
ALTER TABLE &amp;lt;数据表名&amp;gt;
CHANGE COLUMN &amp;lt;字段名&amp;gt;
&amp;lt;字段名&amp;gt; &amp;lt;数据类型&amp;gt; NOT NULL;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;mysql索引&quot;&gt;MYSQL索引&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;在物理上分为  BTREE 索引和 HASH 索引&lt;/p&gt;

  &lt;p&gt;哈希（Hash）：把任意长度的输入（又叫作预映射，pre-image）通过散列算法变换成固定长度的输出（散列值）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;-- 创建表时
CREATE TABLE &amp;lt;数据表名&amp;gt; 
KEY|INDEX [&amp;lt;索引名&amp;gt;] [&amp;lt;索引类型&amp;gt;] (&amp;lt;列名&amp;gt;,…) -- 普通索引
UNIQUE [INDEX|KEY] [&amp;lt;索引名&amp;gt;] [&amp;lt;索引类型&amp;gt;] (&amp;lt;列名&amp;gt;,…) -- 唯一索引
-- 修改表
ALTER TABLE &amp;lt;数据表名&amp;gt;
ADD INDEX [&amp;lt;索引名&amp;gt;] [&amp;lt;索引类型&amp;gt;] (&amp;lt;列名&amp;gt;,…)
ADD UNIQUE [INDEX|KEY] [&amp;lt;索引名&amp;gt;] [&amp;lt;索引类型&amp;gt;] (&amp;lt;列名&amp;gt;,…)
-- 查看索引
SHOW INDEX FROM &amp;lt;表名&amp;gt; [ FROM &amp;lt;数据库名&amp;gt;]\G;
show index from students\G;
        Table: students -- 数据表名
   Non_unique: 0        -- 是否是唯一索引
     Key_name: PRIMARY  -- 索引的名称:主键索引
 Seq_in_index: 1		-- 该列在索引中的位置，如果索引是单列的，则该列的值为1
  Column_name: id		-- 定义索引的列字段
    Collation: A		-- 升序显示值“A”（升序），若显示为 NULL，则表示无分类
  Cardinality: 10		-- 索引中唯一值数目的估计值
     Sub_part: NULL		-- 列中被编入索引的字符的数量，列的值为 NULL表示整列被编入索引。
       Packed: NULL		-- 关键字如何被压缩
         Null:			-- 显示索引列中是否包含 NULL
   Index_type: BTREE	-- 索引使用的类型和方法（BTREE、FULLTEXT、HASH、RTREE）
      Comment:			-- 评注
Index_comment:
      Visible: YES
   Expression: NULL
-- 删除索引
DROP INDEX &amp;lt;索引名&amp;gt; ON &amp;lt;表名&amp;gt;
DROP PRIMARY KEY
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;实用sql语句&quot;&gt;实用SQL语句&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;-- 查看系统所支持的存储引擎类型
-- 常用引擎：MyISAM、InnoDB 和 MEMORY 
show engines;
SHOW VARIABLES LIKE 'default_storage_engine%'; -- 查看默认引擎
SET default_storage_engine=InnoDB; -- 设置默认引擎
-- 修改数据表的存储引擎
ALTER TABLE &amp;lt;表名&amp;gt; ENGINE=&amp;lt;存储引擎名&amp;gt;;

-- 插入或替换
REPLACE INTO students (id, class_id, name, gender, score) VALUES (1, 1, '小明', 'F', 99);
-- 插入或更新
INSERT INTO students (id, class_id, name, gender, score) VALUES (1, 1, '小明', 'F', 99) ON DUPLICATE KEY UPDATE name='小明', gender='F', score=99;
-- 插入或忽略
INSERT IGNORE INTO students (id, class_id, name, gender, score) VALUES (1, 1, '小明', 'F', 99);
-- 快照
CREATE TABLE students_of_class1 SELECT * FROM students WHERE class_id=1;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;操作示例&quot;&gt;操作示例&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;set character set utf8;
-- 如果test数据库不存在，就创建test数据库：
CREATE DATABASE IF NOT EXISTS test;

-- 切换到test数据库
USE test;

-- 删除classes表和students表（如果存在）：
DROP TABLE IF EXISTS classes;
DROP TABLE IF EXISTS students;

-- 创建classes表：
CREATE TABLE classes (
    id BIGINT NOT NULL AUTO_INCREMENT,
    name VARCHAR(100) NOT NULL,
    PRIMARY KEY (id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- 创建students表：
CREATE TABLE students (
    id BIGINT NOT NULL AUTO_INCREMENT,
    class_id BIGINT NOT NULL,
    name VARCHAR(100) NOT NULL,
    gender VARCHAR(1) NOT NULL,
    score INT NOT NULL,
    PRIMARY KEY (id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- 插入classes记录：
INSERT INTO classes(id, name) VALUES (1, '一班');
INSERT INTO classes(id, name) VALUES (2, '二班');

-- 插入students记录：
INSERT INTO students (id, class_id, name, gender, score) VALUES (1, 1, '小明', 'M', 90);
INSERT INTO students (id, class_id, name, gender, score) VALUES (2, 1, '小红', 'F', 95);
INSERT INTO students (id, class_id, name, gender, score) VALUES (5, 2, '小白', 'F', 81);

-- OK:
SELECT 'ok' as 'result:';
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;存储过程&quot;&gt;存储过程&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;（可编程函数）一组为了完成特定功能的 SQL 语句集合，经编译和优化后存储在数据库服务器中，可以被 Java 和 C# 等编程语言调用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;CREATE PROCEDURE &amp;lt;过程名&amp;gt; ([过程参数[,…]]) &amp;lt;过程体&amp;gt;
-- [过程参数[,…] ] 格式
[IN|OUT|INOUT] &amp;lt;参数名&amp;gt; &amp;lt;类型&amp;gt;
-- &amp;lt;过程体&amp;gt; 以关键字 BEGIN 开始，以关键字 END 结束
-- 使用命令行创建存储过程时，使用 DELIMITER 命令将结束命令修改为其他字符
DELIMITER $$
CREATE PROCEDURE ShowStuScore()
BEGIN
SELECT * FROM tb_students_score;
END $$
-- 查看存储过程的状态
SHOW PROCEDURE STATUS LIKE 存储过程名;
-- 查看存储过程的定义
SHOW CREATE PROCEDURE 存储过程名;
-- 删除
DROP PROCEDURE [ IF EXISTS ] &amp;lt;过程名&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;触发器&quot;&gt;触发器&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;在 MySQL 中，只有执行 INSERT、UPDATE 和 DELETE 操作时才能激活触发器&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;-- 创建触发器
CREATE TRIGGER &amp;lt;触发器名&amp;gt; 
&amp;lt;BEFORE|AFTER&amp;gt; &amp;lt;INSERT| UPDATE| DELETE &amp;gt; ON &amp;lt;表名&amp;gt; 
FOR EACH Row
&amp;lt;触发器主体&amp;gt;;	
-- 创建一个名为 SumOfSalary 的触发器，触发的条件是向数据表 tb_emp8 中插入数据之前，对新插入的 salary 字段值进行求和计算。
CREATE TRIGGER SumOfSalary
BEFORE INSERT ON tb_emp8
FOR EACH ROW
SET @sum=@sum+NEW.salary;
-- 查看触发器
SHOW TRIGGERS;
SELECT * FROM information_schema.triggers WHERE trigger_name= '触发器名';
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;事件&quot;&gt;事件&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;执行定时任务，事件调度器Event Scheduler&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;-- 查看even_scheduler是否开启
show processlist;
select @@event_scheduler;
show variables like 'event_scheduler';
-- 开启关闭调度器
set global event_scheduler=On;
-- 创建事件
CREATE EVENT [IF NOT EXISTS] event_name
    ON SCHEDULE &amp;lt;schedule&amp;gt; -- 用于定义执行的时间和时间间隔,schedule 的值为一个 AT 子句
    [ON COMPLETION [NOT] PRESERVE] -- 用于定义事件是否循环执行，默认为一次执行，即 NOT PRESERVE
    [ENABLE | DISABLE | DISABLE ON SLAVE] -- 用于指定事件的一种属性
    [COMMENT 'comment'] -- 定义事件的注释
    DO &amp;lt;event_body&amp;gt;; -- 指定事件启动时所要执行的代码： SQL 语句、存储过程或者一个计划执行的事件
    
CREATE EVENT IF NOT EXISTS e_test 
ON SCHEDULE EVERY 5 SECOND
ON COMPLETION PRESERVE
DO INSERT INTO tb_eventtest(user,createtime) VALUES ('MySQL',NOW());
-- 查看事件
show events;
SELECT * FROM information_schema.events limit 1\G;
-- 修改事件，同创建。
ALTER EVENT event_name DISABLE;-- 临时关闭事件
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;数据库事务&quot;&gt;数据库事务&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;数据库事务用来保证多条SQL的全部执行，可以确保该事务范围内的所有操作都可以全部成功或者全部失败，如转账。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;A：Atomic，原子性，将所有SQL作为原子工作单元执行，要么全部执行，要么全部不执行；&lt;/li&gt;
  &lt;li&gt;C：Consistent，一致性，事务完成后，所有数据的状态都是一致的，即A账户只要减去了100，B账户则必定加上了100；&lt;/li&gt;
  &lt;li&gt;I：Isolation，隔离性，如果有多个事务并发执行，每个事务作出的修改必须与其他事务隔离；&lt;/li&gt;
  &lt;li&gt;D：Duration，持久性，即事务完成后，对数据库数据的修改被持久化存储。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;-- 从id=1的账户给id=2的账户转账100元
BEGIN; -- 开启一个事务
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
COMMIT; -- 提交该显式事务
ROLLBACK; -- 回滚，主动事务失败

-- 查看当前事务自动提交模式，默认开启即每一条sql指令为一个事务
SHOW VARIABLES LIKE 'autocommit';
SET autocommit = 0|1|ON|OFF;-- 开启关闭
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;mysql-事务隔离级别&quot;&gt;MySQL 事务隔离级别&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;隔离级别&lt;/th&gt;
      &lt;th&gt;脏读&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;不可重复读&lt;/th&gt;
      &lt;th&gt;幻读&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;READ UNCOMITTED 读未提交&lt;/td&gt;
      &lt;td&gt;√&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;√&lt;/td&gt;
      &lt;td&gt;√&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;READ COMMITTED 读提交&lt;/td&gt;
      &lt;td&gt;×&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;√&lt;/td&gt;
      &lt;td&gt;√&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;REPEATABLE READ 可重复读&lt;/td&gt;
      &lt;td&gt;×&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;×&lt;/td&gt;
      &lt;td&gt;√&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;SERIALIZABLE 串行化&lt;/td&gt;
      &lt;td&gt;×&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;×&lt;/td&gt;
      &lt;td&gt;×&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;用户管理&quot;&gt;用户管理&lt;/h2&gt;

&lt;h2 id=&quot;数据库备份恢复&quot;&gt;数据库备份恢复&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;# 数据库备份
mysqldump -u username -p &amp;lt;数据库&amp;gt; [&amp;lt;数据表&amp;gt; ...]&amp;gt; filename.sql
mysqldump -u root -p test &amp;gt; C:\student.sql
mysqldump -u username -p --databases &amp;lt;数据库1&amp;gt; &amp;lt;数据库2&amp;gt; ... &amp;gt; filename.sql #备份多个库
mysqldump -u username -p --all-databases &amp;gt; filename.sql #备份all

#student.sql 文件中的所有表和记录必须恢复到一个已经存在的数据库中。
#恢复数据时，CREATE TABLE 语句会在数据库中创建表，然后执行 INSERT 语句向表中插入记录。
#数据库恢复
mysql -u username -p [&amp;lt;数据库&amp;gt;] &amp;lt; filename.sql
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;-- 数据表导出
SELECT 列名 FROM table [WHERE 语句] INTO OUTFILE '目标文件'[OPTIONS]
SELECT * FROM test.person INTO OUTFILE 'C://person.txt';
-- 数据表导入
CREATE TABLE tb_students_copy LIKE tb_students_info;

LOAD DATA INFILE 'C:/file.txt' INTO TABLE test_db.tb_students_copy
FIELDS TERMINATED BY ',' -- 设置字符串为字段之间的分隔符
OPTIONALLY ENCLOSED BY '&quot;' --设置字符来括上 CHAR、VARCHAR 和 TEXT 等字符型字段。
LINES TERMINATED BY '?'; -- 设置每行结尾的字符
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;日志&quot;&gt;日志&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果 MySQL 数据库系统意外停止服务，通过&lt;strong&gt;错误日志&lt;/strong&gt;查看出现错误的原因。&lt;/p&gt;

  &lt;p&gt;通过&lt;strong&gt;二进制日志&lt;/strong&gt;来查看用户分别执行了哪些操作、对数据库文件做了哪些修改，然后来修复数据库。&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;通用查询日志&lt;/strong&gt;记录用户的所有操作，包括启动和关闭 MySQL 服务、更新语句和查询语句等。&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;慢查询日志&lt;/strong&gt;记录执行事件超过指定时间的操作，通过工具分析慢查询日志可以定位 MySQL 服务器性能瓶颈所在。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;在 MySQL 配置文件添加相应选项来开启日志
[mysqld]
log-bin=dir/filename # 二进制日志
log-error=dir/filename # 错误日志
log=dir/filename # 通用查询日志
log-slow-queries=dir\filename # 慢查询日志
long_query_time=n # 设置慢查询时间值(s)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;-- 错误日志
-- 默认路径：C:\ProgramData\MySQL\MySQL Server\Data\
SHOW VARIABLES LIKE 'log_error';
-- mysqladmin -u root -p flush-logs # 开启新的日志

-- 二进制日志
SHOW VARIABLES LIKE 'log_bin';
SHOW binary logs; -- 查看二进制日志文件列表
SHOW master status; -- 查看当前正在写入的二进制日志文件
-- mysqlbinlog filename.number # 在当前文件夹下查找指定的二进制日志
RESET MASTER; -- 重置
PURGE MASTER LOGS TO 'filename.number'; -- 删除指定
PURGE MASTER LOGS TO 'yyyy-mm-dd hh:MM:ss'; -- 按时间
SET SQL_LOG_BIN=0/1; -- 暂停/开启
-- mysqlbinlog filename.number | mysql -u root -p # 还原数据库

-- 通用查询日志
SHOW VARIABLES LIKE '%general%';
SET GLOBAL general_log=off;

-- 慢查询日志
SHOW VARIABLES LIKE 'slow_query%';
SHOW VARIABLES LIKE 'long_query_time';
SET GLOBAL slow_query_log=ON;
SET GLOBAL long_query_time=0.001;

-- 日志输出方式：文件或数据表
SHOW VARIABLES LIKE '%log_out%';
SET GLOBAL log_output='FILE,TABLE';
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;python-mysql&quot;&gt;PYTHON-MYSQL&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://wiki.python.org/moin/MySQL&quot;&gt;DRIVER&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://dev.mysql.com/doc/connector-python/en/&quot;&gt;MySQL Connector&lt;/a&gt; &lt;code&gt;pip install mysql-connector-python&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.runoob.com/python3/python-mysql-connector.html&quot;&gt;mysql-connector&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/PyMySQL/PyMySQL&quot;&gt;PyMySQL&lt;/a&gt; &lt;code&gt;import pymysql.cursors&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.runoob.com/python3/python3-mysql.html&quot;&gt;pymysql&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><category term="数据库" /><summary type="html">数据库</summary></entry><entry><title type="html">TCP/IP-Socket、http、websockets</title><link href="https://acemyzoe.github.io/_posts/2020-07-10-TCP&IP@SOCKET/" rel="alternate" type="text/html" title="TCP/IP-Socket、http、websockets" /><published>2020-07-10T00:00:00+08:00</published><updated>2020-07-10T00:00:00+08:00</updated><id>https://acemyzoe.github.io/_posts/TCP&amp;IP@SOCKET</id><content type="html" xml:base="https://acemyzoe.github.io/_posts/2020-07-10-TCP&amp;IP@SOCKET/">&lt;h1 id=&quot;cs结构与套接字&quot;&gt;C/S结构与套接字&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.python.org/3/library/socketserver.html#module-socketserver&quot;&gt;docs&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;服务端socket&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;创建socket对象，调用socket构造函数：socket.socket()&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将socket绑定到指定地址上，socket.bind()监听，准备好套接字，以便接受链接请求：socket.listen()&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;等待客户请求一个链接：socket.accept()&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;处理阶段，服务器与客户端通过send和recv方法通信(传输数据)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;传输结束，服务器调用socked的close方法以关闭连接&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;客户端socket&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;创建一个socket以连接服务器&lt;/li&gt;
  &lt;li&gt;connect方法连接服务器&lt;/li&gt;
  &lt;li&gt;客户端和服务器通过send和recv方法通信&lt;/li&gt;
  &lt;li&gt;客户端通过调用socket的close方法关闭连接&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;import socket
# socket.socket(familly,type)
# AF_INET：IPv4协议
# AF_INET6： IPv6协议
# AF_UNIX：Unix域，用于同一台机器上的进程间通讯
# SOCK_STREAM：面向流的TCP协议
# SOCK_DGRAM： 面向无连接UDP协议

def server():
    # 1、创建服务端的socket对象
    server = socket.socket()
    # 2、绑定一个ip和端口
    server.bind((&quot;127.0.0.1&quot;,2333))
    # 3、服务器端一直监听是否有客户端进行连接
    server.listen(5)
    while True:
        # 4、如果有客户端进行连接、则接受客户端的连接
        conn,addr = server.accept() # 返回客户端socket通信对象和客户端的ip
        # 5、客户端与服务端进行通信
        rev_data = conn.recv(1024)
        print('服务端收到客户端发来的消息:%s' % (rev_data.decode('GB2312')))
        # 6、服务端给客户端回消息
        conn.send(b&quot;HTTP/1.1 200 OK 、\r\n\r\n&quot;)  #http协议(B/S架构)-&amp;gt;浏览器
        show_str = &quot;&amp;lt;h1&amp;gt; 不要回答！！！不要回答！！！不要回答！！！&amp;lt;/h1&amp;gt;&quot;
        conn.send(show_str.encode('GB2312'))	# C/S架构
    # 7、关闭socket对象
    conn.close()
          
def client():
    # 1、创建socket通信对象
    clientSocket = socket.socket()
    # 2、使用正确的ip和端口去链接服务器
    clientSocket.connect((&quot;127.0.0.1&quot;,2333))
    # 3、客户端与服务器端进行通信
    while True:
        # 给socket服务器发送信息
        send_data = input(&quot;&amp;gt;&amp;gt;&quot;)
        if not send_data:  # 如果传入空字符会阻塞
            print(&quot;connect close..&quot;)
            break
        clientSocket.send(send_data.encode('GB2312'))
        # 接收服务器的响应(服务器回复的消息)
        recvData = clientSocket.recv(1024).decode('GB2312')
        print('客户端收到服务器回复的消息:%s' % (recvData))
    # 4、关闭socket对象
    clientSocket.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;文件传输&quot;&gt;文件传输&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;基于TCP&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Client打开文件，通过socket发送数据到Server&lt;/li&gt;
  &lt;li&gt;Server保存数据到文件&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;多线程&quot;&gt;多线程&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.python.org/3/library/socketserver.html&quot;&gt;socketserver&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;threadingmixin&quot;&gt;&lt;strong&gt;ThreadingMixin&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.python.org/3/library/socketserver.html#asynchronous-mixins&quot;&gt;示例&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# ThreadingMixin 服务器，利用多线程实现异步，支持多用户。
import socketserver
class MyHandler(socketserver.BaseRequestHandler):
    &quot;&quot;&quot;
    从BaseRequestHander继承，并重写handle方法
    &quot;&quot;&quot;
    def handle(self):
        while(self):
            try:
                self.data = self.request.recv(2048).strip()  # 接收
                if not self.data:
                    break
                print(&quot;receive from (%r):%r&quot; % (self.client_address, self.data))
                self.request.send(self.data.upper())  # 发送
                #self.requset.sendall(data.upper())
                if self.data == 'exit':
                    print('server exit')
                    break
            except ConnectionResetError as e:
                print(e)
                break
def serverplus():
    host, port = &quot;127.0.0.1&quot;, 2333
    # server = socketserver.TCPServer((host, port), MyHandler)   # 单线程交互
    server = socketserver.ThreadingTCPServer((host, port), MyHandler)   # 多线程交互
    print(&quot;服务器已开启&quot;)
    server.serve_forever()

if __name__ == &quot;__main__&quot;:
    serverplus()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;多线程-全双工&quot;&gt;多线程-&amp;gt;全双工&lt;/h2&gt;

&lt;p&gt;将输入与接收分开来，将接收的函数（或方法）从主线程里抓出来丢到另一个线程里单独运行。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;import socket
import threading
flag=True
def rec(sock):
    global flag
    while flag:
        t=sock.recv(1024).decode('utf8')
        if t == &quot;exit&quot;:
            flag=False
        print(t)

def io(sock):
    '''多线程
    '''
    trd=threading.Thread(target=rec,args=(sock,))
    trd.start()
    global flag
    while flag:
        t=input()
        sock.send(t.encode('utf8'))
        if t == &quot;exit&quot;:
            flag=False

def server():
    '''服务端
    '''
    s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    s.bind((&quot;127.0.0.1&quot;,2333))
    s.listen(2)
    sock,addr=s.accept()
    io(sock)
    s.close()

def client():
    '''客户端
    '''
    s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    s.connect((&quot;127.0.0.1&quot;,2333))
    io(s)
    s.close()

if __name__ == &quot;__main__&quot;:
    server()
	#client()
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;websocket&quot;&gt;WebSocket&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;websocket&amp;amp;socket&amp;amp;http&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;WebSocket基于 TCP 协议之上的「长连接」协议，在网络七层协议上的层级等同于Http，属应用层协议，是在单个 &lt;strong&gt;TCP 连接&lt;/strong&gt;上进行&lt;strong&gt;全双工通讯&lt;/strong&gt;的协议。WebSocket常见于&lt;strong&gt;客户端-服务端全双工&lt;/strong&gt;的场景，比如聊天，客户端可以发送消息给服务端，同时服务端也可以主动发送消息给客户端。&lt;/p&gt;

  &lt;p&gt;HTTP 基于 TCP 协议之上的「短连接」应用层协议。Http是单向的，只能客户端发送请求，服务端被动接收，服务端没有主动发起请求的能力，只能维持Http长链接，或者客户端定时轮询服务端，获取最新的信息。&lt;/p&gt;

  &lt;p&gt;对于 WebSocket 来说，它必须依赖HTTP 协议进行一次握手，握手成功后，数据就直接从 TCP 通道传输，与 HTTP 无关了。&lt;/p&gt;

  &lt;p&gt;Socket属于处于七层协议中的第四层，Socket是操作系统对TCP、UDP的封装，便于使用 TCP/UDP 的接口规范、API接口。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;python &lt;code&gt;pip install websockets&lt;/code&gt;  &lt;a href=&quot;https://websockets.readthedocs.io/en/stable/intro.html&quot;&gt;docs&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;异步I/O ` pip install asyncio ` &lt;a href=&quot;https://docs.python.org/zh-cn/3/library/asyncio-task.html&quot;&gt;docs&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;c-socket&quot;&gt;c# socket&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;language-c#&quot;&gt; ///字符串处理
 string s = &quot;fc2a0001000201010101000102009a4887009a4888020203e83c0000000000000000000000C6875a&quot;;
 string s1 = string.Join(&quot; &quot;, System.Text.RegularExpressions.Regex.Split(s, &quot;(?&amp;lt;=\\G.{2})(?!$)&quot;));
 string s2 = System.Text.RegularExpressions.Regex.Replace(s, @&quot;.{2}&quot;, &quot;$0 &quot;);
 string s3=s;
 for (int i = 2; i &amp;lt; s3.Length; i += 3)
 {
 s3 = s3.Insert(i, &quot; &quot;);
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;服务端&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c#&quot;&gt;using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Net;
using System.Net.Sockets; 
namespace server
{
    class Program
    {
        static void Main(string[] args)
        {
             int port = 2000;
            string host = &quot;127.0.0.1&quot;;
 
       	 ///创建终结点（EndPoint）
            IPAddress ip = IPAddress.Parse(host);//把ip地址字符串转换为IPAddress类型的实例
            IPEndPoint ipe = new IPEndPoint(ip, port);//用指定的端口和ip初始化IPEndPoint类的新实例
 
         ///创建socket并开始监听
            Socket s　=　new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
            //创建一个socket对像，如果用udp协议，则要用SocketType.Dgram类型的套接字
         	//Socket s = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
            s.Bind(ipe);//绑定EndPoint对像（2000端口和ip地址）
            s.Listen(0);//开始监听
            Console.WriteLine(&quot;等待客户端连接&quot;);
 
         ///接受到client连接，为此连接建立新的socket，并接受信息
            Socket temp = s.Accept();//为新建连接创建新的socket
            Console.WriteLine(&quot;建立连接&quot;);
            string recvStr = &quot;&quot;;
            byte[] recvBytes = new byte[1024];
            int bytes;
            bytes = temp.Receive(recvBytes, recvBytes.Length, 0);//从客户端接受信息
            recvStr += Encoding.ASCII.GetString(recvBytes, 0, bytes);
 
         ///给client端返回信息
            Console.WriteLine(&quot;server get message:{0}&quot;, recvStr);//把客户端传来的信息显示出来
            string sendStr = &quot;ok!Client send message successful!&quot;;
            byte[] bs = Encoding.ASCII.GetBytes(sendStr);
            temp.Send(bs, bs.Length, 0);//返回信息给客户端
            temp.Close();
            s.Close();
            Console.ReadLine();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;客户端&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c#&quot;&gt;using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Net;
using System.Net.Sockets;
 
namespace Client
{
    class Program
    {
        static void Main(string[] args)
        {
            try
            {
                int port = 2000;
                string host = &quot;127.0.0.1&quot;;
                ///创建终结点EndPoint
                IPAddress ip = IPAddress.Parse(host);
                //IPAddress ipp = new IPAddress(&quot;127.0.0.1&quot;);
                IPEndPoint ipe = new IPEndPoint(ip, port);//把ip和端口转化为IPEndpoint实例
 
                ///创建socket并连接到服务器
                Socket c = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);//创建Socket
                Console.WriteLine(&quot;Conneting…&quot;);
                c.Connect(ipe);//连接到服务器
 
                ///向服务器发送信息
                string sendStr = &quot;hello!This is a socket test&quot;;
                byte[] bs = Encoding.ASCII.GetBytes(sendStr);//把字符串编码为字节
                Console.WriteLine(&quot;Send Message&quot;);
                c.Send(bs, bs.Length, 0);//发送信息
 
                ///接受从服务器返回的信息
                string recvStr = &quot;&quot;;
                byte[] recvBytes = new byte[1024];
                int bytes;
                bytes = c.Receive(recvBytes, recvBytes.Length, 0);//从服务器端接受返回信息
                recvStr += Encoding.ASCII.GetString(recvBytes, 0, bytes);
                Console.WriteLine(&quot;client get message:{0}&quot;, recvStr);//显示服务器返回信息
                ///一定记着用完socket后要关闭
                c.Close();
            }
            catch (ArgumentNullException e)
            {
                Console.WriteLine(&quot;argumentNullException: {0}&quot;, e);
            }
            catch (SocketException e)
            {
                Console.WriteLine(&quot;SocketException:{0}&quot;, e);
            }
            Console.WriteLine(&quot;Press Enter to Exit&quot;);
            Console.ReadLine();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;systemnethttplistener&quot;&gt;System.Net.HttpListener&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.net.httplistener?view=netcore-3.1&quot;&gt;microsoft&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;more&quot;&gt;More&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;QUIC :  &lt;strong&gt;快速UDP网络连接&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="通信" /><summary type="html">C/S结构与套接字</summary></entry><entry><title type="html">CRC校验及延伸</title><link href="https://acemyzoe.github.io/_posts/2020-07-04-CRC%E6%A0%A1%E9%AA%8C/" rel="alternate" type="text/html" title="CRC校验及延伸" /><published>2020-07-04T00:00:00+08:00</published><updated>2020-07-04T00:00:00+08:00</updated><id>https://acemyzoe.github.io/_posts/CRC%E6%A0%A1%E9%AA%8C</id><content type="html" xml:base="https://acemyzoe.github.io/_posts/2020-07-04-CRC%E6%A0%A1%E9%AA%8C/">&lt;h1 id=&quot;crc校验及延伸&quot;&gt;CRC校验及延伸&lt;/h1&gt;

&lt;h2 id=&quot;online-crc&quot;&gt;Online CRC&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://www.ip33.com/crc.html&quot;&gt;ip33_zn&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://crccalc.com/&quot;&gt;crccalc&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;modbus&quot;&gt;Modbus&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%87%AA%E5%8B%95%E5%8C%96%E9%80%9A%E8%A8%8A%E5%8D%94%E5%AE%9A%E5%88%97%E8%A1%A8&quot;&gt;自动化通讯协定&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.simplymodbus.ca/index.html&quot;&gt;simply modbus&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Modbus&lt;/strong&gt;是一种串行&lt;a href=&quot;https://zh.wikipedia.org/wiki/通信协议&quot;&gt;通信协议&lt;/a&gt;，是Modicon公司（现在的&lt;a href=&quot;https://zh.wikipedia.org/wiki/施耐德电气&quot;&gt;施耐德电气&lt;/a&gt; Schneider Electric）于1979年为使用&lt;a href=&quot;https://zh.wikipedia.org/wiki/可编程逻辑控制器&quot;&gt;可编程逻辑控制器&lt;/a&gt;（PLC）通信而发表。Modbus已经成为工业领域通信协议事实上的&lt;a href=&quot;https://zh.wikipedia.org/wiki/業界標準&quot;&gt;业界标准&lt;/a&gt;，并且现在是工业电子设备之间常用的连接方式。[&lt;a href=&quot;https://zh.wikipedia.org/wiki/Modbus#cite_note-Drury2009-1&quot;&gt;1]&lt;/a&gt; Modbus比其他通信协议使用的更广泛的主要原因有：&lt;/p&gt;

  &lt;ol&gt;
    &lt;li&gt;公开发表并且无著作权要求&lt;/li&gt;
    &lt;li&gt;易于部署和维护&lt;/li&gt;
    &lt;li&gt;对供应商来说，修改移动本地的比特或字节没有很多限制&lt;/li&gt;
  &lt;/ol&gt;

  &lt;p&gt;Modbus允许多个 (大约240个) 设备连接在同一个网络上进行通信，举个例子，一个由测量温度和湿度的设备，并且将结果发送给&lt;a href=&quot;https://zh.wikipedia.org/wiki/计算机&quot;&gt;计算机&lt;/a&gt;。在&lt;a href=&quot;https://zh.wikipedia.org/wiki/数据采集与监视控制系统&quot;&gt;数据采集与监视控制系统&lt;/a&gt;（SCADA）中，Modbus通常用来连接监控计算机和&lt;a href=&quot;https://zh.wikipedia.org/wiki/远程终端控制系统&quot;&gt;远程终端控制系统&lt;/a&gt;（RTU）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;c-crc校验实现&quot;&gt;c# crc校验实现&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-c#&quot;&gt;byte[] cmd = new byte[] { 0x02, 0x01, 0x00, 0x1f, 0x10, 0x11, 0x11, 0x11, 0x01, 0x2c, 0x01, 0x2c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x01, 0x00, 0x37, 0x03, 0xe8, 0x03, 0xe8, 0x64, 0x05, 0x03, 0xe8, 0x03, 0xe8, 0x00, 0x00, 0x11, 0x11, 0x00, 0x01 };
/////////////////////crc16 xmodem  demo
static ushort Cal_crc16(byte[] data)
{
    ushort wCRC = 0;
    for (int i = 0; i &amp;lt; data.Length; i++)
    {
        wCRC ^= (ushort)(data[i] &amp;lt;&amp;lt; 8);
        for (int j = 0; j &amp;lt; 8; j++)
        {
            if ((wCRC &amp;amp; 0x8000) != 0)
                wCRC = (ushort)((wCRC &amp;lt;&amp;lt; 1) ^ 0x1021);
            else
                wCRC &amp;lt;&amp;lt;= 1;
        }
    }
    return wCRC;
}
ushort vv = Cal_crc16(cmd);
Console.WriteLine(&quot;crc16-xmodem：{0}&quot;,Convert.ToString(vv, 16));

/////////////////crc16 rtu/modbus demo
// 如何计算Modbus RTU消息CRC (https://ctlsys.com/support/how_to_compute_the_modbus_rtu_message_crc/)
// 为了确保消息数据的完整性，除了验证消息CRC之外，建议实施代码以检查串行端口（UART）成帧错误。如果接收到的消息中的CRC与接收设备计算出的CRC不匹配，则应忽略该消息。下面的C语言代码片段显示了如何使用按位移位和异或运算来计算Modbus消息CRC。使用消息帧中的每个字节（组成CRC本身的最后两个字节除外）计算CRC。
// Compute the MODBUS RTU CRC
ushort ModRTU_CRC(byte[] buf, int len)
{
    ushort crc = 0xFFFF;

    for (int i = 0; i &amp;lt; len; i++)
    {
        crc ^= (ushort)buf[i];          // XOR byte into least sig. byte of crc

        for (int j = 8; j != 0; j--)
        {    // Loop over each bit
            if ((crc &amp;amp; 0x0001) != 0)
            {      // If the LSB is set
                crc &amp;gt;&amp;gt;= 1;                    // Shift right and XOR 0xA001
                crc ^= 0xA001;
            }
            else                            // Else LSB is not set
                crc &amp;gt;&amp;gt;= 1;                    // Just shift right
        }
    }
    // Note, this number has low and high bytes swapped, so use it accordingly (or swap bytes)
    return crc;
}
ushort vv2 = ModRTU_CRC(cmd, cmd.Length);
Console.WriteLine(&quot;crc16-rtu/modbus:{0}&quot;,Convert.ToString(vv2, 16));
//////////////////////////////crc16 rtu/modbus demo
ushort[] CrcTable = {
                    0X0000, 0XC0C1, 0XC181, 0X0140, 0XC301, 0X03C0, 0X0280, 0XC241,
                    0XC601, 0X06C0, 0X0780, 0XC741, 0X0500, 0XC5C1, 0XC481, 0X0440,
                    0XCC01, 0X0CC0, 0X0D80, 0XCD41, 0X0F00, 0XCFC1, 0XCE81, 0X0E40,
                    0X0A00, 0XCAC1, 0XCB81, 0X0B40, 0XC901, 0X09C0, 0X0880, 0XC841,
                    0XD801, 0X18C0, 0X1980, 0XD941, 0X1B00, 0XDBC1, 0XDA81, 0X1A40,
                    0X1E00, 0XDEC1, 0XDF81, 0X1F40, 0XDD01, 0X1DC0, 0X1C80, 0XDC41,
                    0X1400, 0XD4C1, 0XD581, 0X1540, 0XD701, 0X17C0, 0X1680, 0XD641,
                    0XD201, 0X12C0, 0X1380, 0XD341, 0X1100, 0XD1C1, 0XD081, 0X1040,
                    0XF001, 0X30C0, 0X3180, 0XF141, 0X3300, 0XF3C1, 0XF281, 0X3240,
                    0X3600, 0XF6C1, 0XF781, 0X3740, 0XF501, 0X35C0, 0X3480, 0XF441,
                    0X3C00, 0XFCC1, 0XFD81, 0X3D40, 0XFF01, 0X3FC0, 0X3E80, 0XFE41,
                    0XFA01, 0X3AC0, 0X3B80, 0XFB41, 0X3900, 0XF9C1, 0XF881, 0X3840,
                    0X2800, 0XE8C1, 0XE981, 0X2940, 0XEB01, 0X2BC0, 0X2A80, 0XEA41,
                    0XEE01, 0X2EC0, 0X2F80, 0XEF41, 0X2D00, 0XEDC1, 0XEC81, 0X2C40,
                    0XE401, 0X24C0, 0X2580, 0XE541, 0X2700, 0XE7C1, 0XE681, 0X2640,
                    0X2200, 0XE2C1, 0XE381, 0X2340, 0XE101, 0X21C0, 0X2080, 0XE041,
                    0XA001, 0X60C0, 0X6180, 0XA141, 0X6300, 0XA3C1, 0XA281, 0X6240,
                    0X6600, 0XA6C1, 0XA781, 0X6740, 0XA501, 0X65C0, 0X6480, 0XA441,
                    0X6C00, 0XACC1, 0XAD81, 0X6D40, 0XAF01, 0X6FC0, 0X6E80, 0XAE41,
                    0XAA01, 0X6AC0, 0X6B80, 0XAB41, 0X6900, 0XA9C1, 0XA881, 0X6840,
                    0X7800, 0XB8C1, 0XB981, 0X7940, 0XBB01, 0X7BC0, 0X7A80, 0XBA41,
                    0XBE01, 0X7EC0, 0X7F80, 0XBF41, 0X7D00, 0XBDC1, 0XBC81, 0X7C40,
                    0XB401, 0X74C0, 0X7580, 0XB541, 0X7700, 0XB7C1, 0XB681, 0X7640,
                    0X7200, 0XB2C1, 0XB381, 0X7340, 0XB101, 0X71C0, 0X7080, 0XB041,
                    0X5000, 0X90C1, 0X9181, 0X5140, 0X9301, 0X53C0, 0X5280, 0X9241,
                    0X9601, 0X56C0, 0X5780, 0X9741, 0X5500, 0X95C1, 0X9481, 0X5440,
                    0X9C01, 0X5CC0, 0X5D80, 0X9D41, 0X5F00, 0X9FC1, 0X9E81, 0X5E40,
                    0X5A00, 0X9AC1, 0X9B81, 0X5B40, 0X9901, 0X59C0, 0X5880, 0X9841,
                    0X8801, 0X48C0, 0X4980, 0X8941, 0X4B00, 0X8BC1, 0X8A81, 0X4A40,
                    0X4E00, 0X8EC1, 0X8F81, 0X4F40, 0X8D01, 0X4DC0, 0X4C80, 0X8C41,
                    0X4400, 0X84C1, 0X8581, 0X4540, 0X8701, 0X47C0, 0X4680, 0X8641,
                    0X8201, 0X42C0, 0X4380, 0X8341, 0X4100, 0X81C1, 0X8081, 0X4040 };

static UInt16 ComputeCrc(byte[] data, ushort[] crcTable)
{
    ushort crc = 0xFFFF;

    foreach (byte datum in data)
    {
        crc = (ushort)((crc &amp;gt;&amp;gt; 8) ^ crcTable[(crc ^ datum) &amp;amp; 0xFF]);
    }

    return crc;
}
ushort vv3 = ComputeCrc(cmd, CrcTable);
Console.WriteLine(&quot;crc16-rtu/modbus demo:{0}&quot;,Convert.ToString(vv3, 16));

//////////////////crc16 ccitt-false demo
ushort Crc16Ccitt(byte[] bytes)
{
    const ushort poly = 0x1021;
    ushort[] table = new ushort[256];
    ushort initialValue = 0xffff;
    ushort temp, a;
    ushort crc = initialValue;
    for (int i = 0; i &amp;lt; table.Length; ++i)
    {
        temp = 0;
        a = (ushort)(i &amp;lt;&amp;lt; 8);
        for (int j = 0; j &amp;lt; 8; ++j)
        {
            if (((temp ^ a) &amp;amp; 0x8000) != 0)
                temp = (ushort)((temp &amp;lt;&amp;lt; 1) ^ poly);
            else
                temp &amp;lt;&amp;lt;= 1;
            a &amp;lt;&amp;lt;= 1;
        }
        table[i] = temp;
    }
    for (int i = 0; i &amp;lt; bytes.Length; ++i)
    {
        crc = (ushort)((crc &amp;lt;&amp;lt; 8) ^ table[((crc &amp;gt;&amp;gt; 8) ^ (0xff &amp;amp; bytes[i]))]);
    }
    return crc;
}
ushort vv4 = Crc16Ccitt(cmd);
Console.WriteLine(&quot;crc16-ccitt-false：{0}&quot;,Convert.ToString(vv4, 16));

&lt;/code&gt;&lt;/pre&gt;</content><author><name></name></author><category term="通信" /><summary type="html">CRC校验及延伸</summary></entry><entry><title type="html">Bytes &amp;amp; String</title><link href="https://acemyzoe.github.io/_posts/2020-07-02-Bytes&String/" rel="alternate" type="text/html" title="Bytes &amp; String" /><published>2020-07-02T00:00:00+08:00</published><updated>2020-07-02T00:00:00+08:00</updated><id>https://acemyzoe.github.io/_posts/Bytes&amp;String</id><content type="html" xml:base="https://acemyzoe.github.io/_posts/2020-07-02-Bytes&amp;String/">&lt;p&gt;通信控制协议文档里面的命令是十六进制的bytes类型。用python生成指令时我用了字符串和bytes拼接，例如，给出一个指令：02(bytes)&lt;/p&gt;

&lt;p&gt;b’\x02’(bytes)&lt;/p&gt;

&lt;p&gt;接收端直接显示了十六进制的字符串：02(str)&lt;/p&gt;

&lt;p&gt;涉及python标准库的内置类型(bytes、str)及binascii。&lt;/p&gt;

&lt;p&gt;同时项目以c#为主，又研究了c#的处理数据。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;16进制编码的bytes数据 &amp;lt;——&amp;gt; 16进制的string数据显示&lt;/p&gt;

  &lt;p&gt;b’\x5a’	&amp;lt;——&amp;gt;	“5a”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;encode : string2bytes&lt;/p&gt;

  &lt;p&gt;decode : bytes2string&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;pyhon&quot;&gt;Pyhon&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Python 3清晰地区分文本和二进制数据。文本总是Unicode，由str类型表示，二进制数据则由bytes类型表示。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;bytes对象只负责以二进制字节序列的形式记录所需记录的对象，至于该对象到底表示什么则由相应的编码格式解码所决定。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://docs.python.org/zh-cn/3/library/stdtypes.html#bytearray&quot;&gt;&lt;code&gt;bytearray&lt;/code&gt;&lt;/a&gt; 对象是 &lt;a href=&quot;https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; 对象的可变对应物。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;字符串开头r b u f各含义及format：&lt;/strong&gt;&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# bytes字节符 &amp;gt; b'ha\n'
print(b'ha\n') 
# 非转义原生字符，经处理'\n'变成了'\\'和'n'。也就是\n表示的是两个字符，而不是换行 &amp;gt; ha\n
print(r'ha\n') 
# unicode编码字符，python3默认字符串编码方式 &amp;gt; ha
print(u'ha\n') 
  
# 以f开头表示在字符串内支持大括号内的python表达式 &amp;gt; processing done in 1.00 s
import time
t0 = time.time()
time.sleep(1)
name = 'processing'
print(f'{name} done in {time.time() - t0:.2f} s')  
  
# format 类似于f开头，大括号变量，:定义格式
coord = (3, 5)
print('X: {0[0]};  Y: {0[1]}'.format(coord)) # &amp;gt; X: 3;  Y: 5
print('{:,}'.format(1234567890)) # &amp;gt; 1,234,567,890
print('answers: {:.2%}'.format(coord[0]/coord[1])) # &amp;gt; answers: 60.00%
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;二进制序列类型：bytes、bytearray、memoryview&lt;a href=&quot;https://docs.python.org/zh-cn/3/library/stdtypes.html#binary-sequence-types-bytes-bytearray-memoryview&quot;&gt;¶&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes&quot;&gt;bytes&lt;/a&gt;&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;bytes()函数是python的一个内置函数，用此函数可以创建不可变的（immutable）bytes对象（bytes对象，可以理解为byte string）。&lt;/p&gt;

      &lt;p&gt;每一个byte的值只能是0到255&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;print(bytes(range(256))) # 可迭代对象
# &amp;gt; b'\x00\x01\x02\x03\x04\x05\x06\x07\x08\t\n\x0b\x0c\r\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f !&quot;#$%&amp;amp;\'()*+,-./0123456789:;&amp;lt;=&amp;gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\x7f\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff'
print(bytes('哈', 'utf-8').decode()) # 普通string转换到bytes &amp;gt; 哈
print(bytes(3)) #bytes（int） &amp;gt; b'\x00\x00\x00'
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;binascii— 二进制和 ASCII 码互转&lt;a href=&quot;https://docs.python.org/zh-cn/3/library/binascii.html#module-binascii&quot;&gt;¶&lt;/a&gt;&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;import re
import binascii
a =&quot;0201001f10111111012c012c000000000000000201003703e803e8640503e803e8000011110001&quot;
print(re.sub(r&quot;(?&amp;lt;=\w)(?=(?:\w\w)+$)&quot;, &quot; &quot;, a))
## &amp;gt; 02 01 00 1f 10 11 11 11 01 2c 01 2c 00 00 00 00 00 00 00 02 01 00 37 03 e8 03 e8 64 05 03 e8 03 e8 00 00 11 11 00 01
  
b=b'\x02\x01\x00\x1f\x10\x11\x11\x11\x01,\x01,\x00\x00\x00\x00\x00\x00\x00\x02\x01\x007\x03\xe8\x03\xe8d\x05\x03\xe8\x03\xe8\x00\x00\x11\x11\x00\x01'
print(&quot;返回二进制数据 data 的十六进制表示形式:&quot;,binascii.hexlify(b,' ') , type(binascii.hexlify(b)))
## &amp;gt;  b'02 01 00 1f 10 11 11 11 01 2c 01 2c 00 00 00 00 00 00 00 02 01 00 37 03 e8 03 e8 64 05 03 e8 03 e8 00 00 11 11 00 01' &amp;lt;class 'bytes'&amp;gt;
  
print(&quot;解码成字符串：&quot;,binascii.hexlify(b,' ').decode() , type(binascii.hexlify(b).decode()))
## &amp;gt;  02 01 00 1f 10 11 11 11 01 2c 01 2c 00 00 00 00 00 00 00 02 01 00 37 03 e8 03 e8 64 05 03 e8 03 e8 00 00 11 11 00 01 &amp;lt;class 'str'&amp;gt;
  
print(&quot;返回一个字符串对象，该对象包含实例中每个字节的两个十六进制数字：&quot;,b.hex(' '),type(b.hex()))
## &amp;gt;  02 01 00 1f 10 11 11 11 01 2c 01 2c 00 00 00 00 00 00 00 02 01 00 37 03 e8 03 e8 64 05 03 e8 03 e8 00 00 11 11 00 01 &amp;lt;class 'str'&amp;gt;
  
data=b.hex()
print(&quot;返回由十六进制字符串 hexstr 表示的二进制数据:&quot;,binascii.unhexlify(data.rstrip('\r\n')))
## &amp;gt;  b'\x02\x01\x00\x1f\x10\x11\x11\x11\x01,\x01,\x00\x00\x00\x00\x00\x00\x00\x02\x01\x007\x03\xe8\x03\xe8d\x05\x03\xe8\x03\xe8\x00\x00\x11\x11\x00\x01'
  
print(&quot;此 bytes 类方法返回一个解码给定字符串的 bytes 对象：&quot;, bytes.fromhex(data) , type(bytes.fromhex(data)))
## &amp;gt;  b'\x02\x01\x00\x1f\x10\x11\x11\x11\x01,\x01,\x00\x00\x00\x00\x00\x00\x00\x02\x01\x007\x03\xe8\x03\xe8d\x05\x03\xe8\x03\xe8\x00\x00\x11\x11\x00\x01' &amp;lt;class 'bytes'&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;c&quot;&gt;C#&lt;/h1&gt;

&lt;p&gt;与硬件交互数据的步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;获得原始数据data，一般为字符串表示形式。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;通过Encoding.ASCII.GetBytes(data)函数将原始数据转换为ASCII码表示形式data2。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;为提高存储效率，可以通过将data2进一步转换为16进制表示形式data3。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将data3存入硬件。&lt;/p&gt;
    &lt;pre&gt;&lt;code class=&quot;language-c#&quot;&gt;////byte[]初始化赋值
byte[] myByteArray = new byte[10]; //创建一个长度为10的byte数组，每个byte的值为0
byte[] myByteArray = Enumerable.Repeat((byte)0x08, 10).ToArray(); //创建一个长度为10的byte数组，每个byte的值为0x08
byte[] bytes = new byte[] { 0xfc, 0x5a }; //直接赋值
////ascii编码
string str = Encoding.ASCII.GetString(bytes);
Console.WriteLine(str); // &amp;gt; ?Z
////byte[] -&amp;gt; string
string hexs = BitConverter.ToString(bytes);
hexs=hexs.Replace(&quot;-&quot;, &quot;&quot;);
Console.WriteLine(hexs); // &amp;gt; FC5A
////进制转换
int d = 10;
Console.WriteLine(&quot;十进制转二进制字符串:{0}&quot;,Convert.ToString(d, 2)); // &amp;gt; 1010
Console.WriteLine(&quot;十进制转十六进制字符串:{0}&quot;, Convert.ToString(d, 16)); // &amp;gt; a
string bin = &quot;1010&quot;;
Console.WriteLine(&quot;二进制字符串转十进制数:{0}&quot;, Convert.ToInt32(bin, 2)); // &amp;gt; 10
Console.WriteLine(string.Format(&quot;二进制字符串转十六进制数:{0:x}&quot;, Convert.ToInt32(bin, 2))); // &amp;gt; a
Console.WriteLine(&quot;十六进制转二进制字符串:{0}&quot;, Convert.ToString(0xa, 2)); // &amp;gt; 1010
Console.WriteLine(&quot;十六进制转十进制数:{0}&quot;, Convert.ToString(0xa, 10)); // &amp;gt; 10
////string -&amp;gt; bytes[]
// https://stackoverflow.com/questions/321370/how-can-i-convert-a-hex-string-to-a-byte-array
//string hex = &quot;02 01 00 1f 10 11 11 11 01 2c 01 2c 00 00 00 00 00 00 00 02 01 00 37 03 e8 03 e8 64 05 03 e8 03 e8 00 00 11 11 00 01&quot;;
string hex = &quot;0201001F10111111006E00C8000000000000000201003703E803E8640503E803E8000011110001&quot;;
//hex = hex.Replace(&quot; &quot;, &quot;&quot;);
//way1
static byte[] StringToByteArray(string hex)
{
 return Enumerable.Range(0, hex.Length)
                     .Where(x =&amp;gt; x % 2 == 0)
                     .Select(x =&amp;gt; Convert.ToByte(hex.Substring(x, 2), 16))
                     .ToArray();
}
byte[] cmd1 = StringToByteArray(hex); //LINQ示例
//way2
static byte[] StringToByteArray2(string hex)
{
 int NumberChars = hex.Length;
 byte[] bytes = new byte[NumberChars / 2];
 for (int i = 0; i &amp;lt; NumberChars; i += 2)
     bytes[i / 2] = Convert.ToByte(hex.Substring(i, 2), 16);
 return bytes;
}
byte[] cmd2 = StringToByteArray2(hex); //
//way3
static byte[] StrToByteArray3(string str)
{
 Dictionary&amp;lt;string, byte&amp;gt; hexindex = new Dictionary&amp;lt;string, byte&amp;gt;();
 for (int i = 0; i &amp;lt;= 255; i++)
     hexindex.Add(i.ToString(&quot;X2&quot;), (byte)i);

 List&amp;lt;byte&amp;gt; hexres = new List&amp;lt;byte&amp;gt;();
 for (int i = 0; i &amp;lt; str.Length; i += 2)
     hexres.Add(hexindex[str.Substring(i, 2)]);

 return hexres.ToArray();
}
byte[] cmd3 = StrToByteArray3(hex);
//显示
Console.WriteLine(&quot;转成十六进制字符串：&quot;);
Console.WriteLine(BitConverter.ToString(cmd1));
Console.WriteLine(BitConverter.ToString(cmd2));
Console.WriteLine(BitConverter.ToString(cmd3));
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><category term="通信" /><summary type="html">通信控制协议文档里面的命令是十六进制的bytes类型。用python生成指令时我用了字符串和bytes拼接，例如，给出一个指令：02(bytes)</summary></entry></feed>